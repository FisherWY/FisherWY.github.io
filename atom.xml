<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fisher&#39;s Blog</title>
  
  <subtitle>大都会に僕はもう一人で  投げ捨てられた空きカンのようだ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fisher.lazybone.xyz/"/>
  <updated>2021-08-06T06:01:19.153Z</updated>
  <id>http://fisher.lazybone.xyz/</id>
  
  <author>
    <name>Fisher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenWrt的DDNS配置</title>
    <link href="http://fisher.lazybone.xyz/openwrt%E7%9A%84ddns%E9%85%8D%E7%BD%AE.html"/>
    <id>http://fisher.lazybone.xyz/openwrt的ddns配置.html</id>
    <published>2021-08-06T03:27:28.000Z</published>
    <updated>2021-08-06T06:01:19.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近着手改造家里的网络，买了一个D2550软路由，把家里的光猫由拨号改成了桥接，并使用D2550拨号和管理家里的网络。很久之前就向电信申请了公网IP，一直没用上，此次趁着网络改造，顺带给这个公网IP配置DDNS，利用起来并为后续NAS的搭建提供外网访问的环境。</p><h1 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h1><p>首先是需要有一个域名，在阿里云购买一个域名非常简单，填写实名制模版，使用模版购买域名即可，现在好像不需要背景布拍照上传手持身份证的照片了，跟以前相比简直太方便了，这里就不详细描述如何购买域名和实名制认证了。</p><a id="more"></a><p>打开阿里云的<code>云解析DNS</code>，点击需要修改解析设置的域名，点击<code>添加记录</code>，每项的配置如下：</p><ul><li>记录类型：<code>A</code>（如果需要解析IPv6地址就选择<code>AAAA</code>）</li><li>主机记录：<code>myhome</code>（修改为自己想要的三级域名，留空则不使用三级域名）</li><li>解析线路：<code>默认</code>（一般默认即可）</li><li>记录值：<code>xx.xxx.xx.xx</code>（填入D2550的wan口IP地址）</li><li>TTL：<code>10分钟</code>（一般默认即可）</li></ul><p>点击添加后，看到页面记录显示解析状态正常，域名解析配置就完成了。</p><p><img src="images/router/D2550_Aliyun_DNS.png" alt="云解析配置"></p><h1 id="访问控制配置"><a href="#访问控制配置" class="headerlink" title="访问控制配置"></a>访问控制配置</h1><p>接下来需要配置的是云解析DNS的访问控制，配置访问控制的目的是让D2550获得更改解析记录的权限。</p><p>打开阿里云的<code>访问控制/RAM访问控制</code>，打开<code>身份管理</code>中的<code>用户</code>，点击<code>创建用户</code>，<code>登录名称</code>和<code>显示名称</code>自定，勾选<code>Open API调用访问</code>。</p><p>创建用户后，阿里云会提供该用户的<code>AccessKey ID</code>和<code>AccessKey Secret</code>，将其记录下来，页面关闭后就不再显示Secret了。点击用户操作选项中的<code>添加权限</code>，在系统策略中找到<code>管理云解析DNS的权限</code>，选择添加并确定。</p><p><img src="images/router/D2550_Aliyun_RAM.png" alt="访问控制配置"></p><p>这一步完成后，云端的配置工作就完成了。</p><h1 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h1><p>打开D2550的管理界面，打开<code>动态DNS</code>服务页面，添加一份配置，配置如下：</p><ul><li>启用：☑️</li><li>查询主机名：<code>myhome.fisheryung.top</code>（填入在域名解析配置中设置的域名）</li><li>IP地址版本：<code>IPv4地址</code>（如果用IPv6则改成v6地址）</li><li>DDNS服务提供商：<code>aliyun.com</code></li><li>域名：<code>myhome.fisheryung.top</code>（同查询主机名）</li><li>用户名：<code>AccessKey ID</code>（访问控制配置中提供的ID）</li><li>密码：<code>AccessKey Secret</code>（访问控制配置中提供的Secret）</li></ul><p>保存并应用，过一段时间查看日志，如果有定时检查并更新IP地址，则表示配置成功。</p><p><img src="images/router/D2550_DDNS.png" alt="DDNS"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>给D2550配置端口转发，在本地启动Hexo博客，用手机流量尝试进行访问，可以看到访问成功，自此DDNS配置完成。</p><p><img src="images/router/D2550_DDNS_test.png" alt="测试" style="zoom: 50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近着手改造家里的网络，买了一个D2550软路由，把家里的光猫由拨号改成了桥接，并使用D2550拨号和管理家里的网络。很久之前就向电信申请了公网IP，一直没用上，此次趁着网络改造，顺带给这个公网IP配置DDNS，利用起来并为后续NAS的搭建提供外网访问的环境。&lt;/p&gt;&lt;h1 id=&quot;域名解析配置&quot;&gt;&lt;a href=&quot;#域名解析配置&quot; class=&quot;headerlink&quot; title=&quot;域名解析配置&quot;&gt;&lt;/a&gt;域名解析配置&lt;/h1&gt;&lt;p&gt;首先是需要有一个域名，在阿里云购买一个域名非常简单，填写实名制模版，使用模版购买域名即可，现在好像不需要背景布拍照上传手持身份证的照片了，跟以前相比简直太方便了，这里就不详细描述如何购买域名和实名制认证了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://fisher.lazybone.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://fisher.lazybone.xyz/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>小米路由器4千兆版刷OpenWrt</title>
    <link href="http://fisher.lazybone.xyz/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A84%E5%8D%83%E5%85%86%E7%89%88%E5%88%B7openwrt.html"/>
    <id>http://fisher.lazybone.xyz/小米路由器4千兆版刷openwrt.html</id>
    <published>2021-07-08T08:53:37.000Z</published>
    <updated>2021-07-14T13:54:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在家用了一段时间的小米路由器4千兆版，使用一段时间之后就会发生网络不稳定，甚至无法连接网络等情况，怀疑是官方固件的问题。同时也有一些插件上的需求，于是就开始动手把OpenWrt固件刷入到小米路由器4千兆版中。</p><h1 id="刷机环境"><a href="#刷机环境" class="headerlink" title="刷机环境"></a>刷机环境</h1><ul><li>刷机使用的系统：macOS 11.4</li><li>编译OpenWrt使用的系统：Ubuntu 21.04</li><li>小米路由器4千兆版固件版本：MiWiFi 稳定版 2.28.58</li></ul><a id="more"></a><h1 id="开启SSH"><a href="#开启SSH" class="headerlink" title="开启SSH"></a>开启SSH</h1><p>开启路由器的SSH需要用到<a href="https://github.com/acecilia/OpenWRTInvasion" target="_blank" rel="noopener">OpenWRTInvasion</a>，首先克隆仓库，安装依赖。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/acecilia/OpenWRTInvasion.git</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> OpenWRTInvasion/</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>接下来打开路由器管理界面，获取<code>stok</code>，<code>stok</code>在路由器的地址栏处，如下图所示，<code>stok=xxxx</code>一直到<code>/</code>前，那么<code>stok</code>就是<code>ff43b68c8e20a6bcd3d33377c0c889dd</code>。</p><p><img src="images/router/Mi4G_stok.png" alt="Stok"></p><p>运行<code>OpenWRTInvasion</code>中的<code>remote_command_execution_vulnerability.py</code>，输入路由器<code>IP地址</code>和<code>stok</code>，脚本会执行命令并开启SSH、Telnet和FTP。如果出现如下图提示，表示开启成功。</p><p><img src="images/router/Mi4G_ssh.png" alt="开启SSH成功"></p><p><strong>如果等了很久都没有反应，则有可能是下载<code>busybox</code>和<code>dropbear</code>时遇到了网络问题，此时需要手动修改一下<code>busybox</code>和<code>dropbear</code>的下载地址</strong>。</p><p>打开<code>OpenWRTInvasion</code>文件夹中的<code>script.sh</code>文件，找到<code>setup_busybox()</code>函数和<code>start_ssh()</code>函数中的<code>curl</code>命令，将其中的下载地址进行修改，这里我使用自己的服务器提供下载。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup_busybox函数</span></span><br><span class="line"><span class="comment"># Rationale for using --insecure: https://github.com/acecilia/OpenWRTInvasion/issues/31#issuecomment-690755250</span></span><br><span class="line">curl -L <span class="string">"https://fisher.lazybone.xyz/downloads/busybox-mipsel"</span> --insecure --output busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># start_ssh函数</span></span><br><span class="line"><span class="comment"># Donwload dropbear static mipsel binary</span></span><br><span class="line">curl -L <span class="string">"https://fisher.lazybone.xyz/downloads/dropbearStaticMipsel.tar.bz2"</span> --output dropbear.tar.bz2</span><br></pre></td></tr></table></figure><p>再次运行<code>OpenWRTInvasion</code>，网络状态良好的情况下能够正常开启ssh了。复制执行脚本给出的ssh命令，输入密码<code>root</code>，就能够ssh登录到路由器中了。</p><p><img src="images/router/Mi4G_login.png" alt="SSH登录"></p><h1 id="刷入Breed"><a href="#刷入Breed" class="headerlink" title="刷入Breed"></a>刷入Breed</h1><p>ssh登录路由器后，使用Curl下载Breed，将其重命名为breed.bin并进行md5校验，md5一致后才能刷Breed。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">curl -o breed.bin https://breed.hackpascal.net/breed-mt7621-pbr-m1.bin</span><br><span class="line">md5sum breed.bin</span><br></pre></td></tr></table></figure><p>使用mtd将Breed刷入Bootloader分区中，此时路由器会自动重启。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r write /tmp/breed.bin Bootloader</span><br></pre></td></tr></table></figure><p><img src="images/router/Mi4G_breed.png" alt="刷入Breed"></p><p>使用网线连接路由器，待网卡正确获取到IP为<code>192.168.1.x</code>的地址后，路由器电源指示灯为淡紫色，表示正常进入Breed中了。</p><p><img src="images/router/Mi4G_breedindex.png" alt="进入Breed"></p><h1 id="编译OpenWrt"><a href="#编译OpenWrt" class="headerlink" title="编译OpenWrt"></a>编译OpenWrt</h1><p>如果从网上下载别人编译好的固件，这一步就可以省略了，下面说说我在编译固件时踩过的坑。</p><ul><li>首先是直接使用coolsnowwolf的<a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener">LEDE</a>编译出来的固件，用Breed刷入后是无法正常引导的，这里需要修改一下内存分区的源码，具体操作流程可参考恩山大佬的<a href="https://www.right.com.cn/forum/thread-4052254-1-1.html" target="_blank" rel="noopener">帖子</a>。</li><li>接着是编译后的固件没有2.4g无线网卡的驱动，这个需要在编译配置中勾选<code>kmod-mt7603</code>，以支持小米路由器4千兆版的2.4g无线网卡。</li></ul><h1 id="刷入OpenWrt"><a href="#刷入OpenWrt" class="headerlink" title="刷入OpenWrt"></a>刷入OpenWrt</h1><p>打开Breed的固件更新页面，选择要刷入的Openwrt固件，直接刷入即可。</p><p><img src="images/router/Mi4G_overview.png" alt="OpenWrt"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在家用了一段时间的小米路由器4千兆版，使用一段时间之后就会发生网络不稳定，甚至无法连接网络等情况，怀疑是官方固件的问题。同时也有一些插件上的需求，于是就开始动手把OpenWrt固件刷入到小米路由器4千兆版中。&lt;/p&gt;&lt;h1 id=&quot;刷机环境&quot;&gt;&lt;a href=&quot;#刷机环境&quot; class=&quot;headerlink&quot; title=&quot;刷机环境&quot;&gt;&lt;/a&gt;刷机环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;刷机使用的系统：macOS 11.4&lt;/li&gt;
&lt;li&gt;编译OpenWrt使用的系统：Ubuntu 21.04&lt;/li&gt;
&lt;li&gt;小米路由器4千兆版固件版本：MiWiFi 稳定版 2.28.58&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://fisher.lazybone.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://fisher.lazybone.xyz/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SCNU校园网IPv6配置</title>
    <link href="http://fisher.lazybone.xyz/scnu%E6%A0%A1%E5%9B%AD%E7%BD%91ipv6%E9%85%8D%E7%BD%AE.html"/>
    <id>http://fisher.lazybone.xyz/scnu校园网ipv6配置.html</id>
    <published>2021-06-24T03:03:47.000Z</published>
    <updated>2021-06-24T04:55:00.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因教育网IPv6不限速，使用清华TUNA的开源镜像站下载资源能够跑满带宽，体验非常好，所以就有了给路由器配置IPv6的想法。之前使用极路由官方固件时有官方的教育网插件可以用（使用6relay），但换了Openwrt后使用的是odhcpd，需要自己重新配置一下。这篇博客纪录了我的配置过程，其中参考了恩山论坛的<a href="https://www.right.com.cn/forum/thread-316405-1-1.html" target="_blank" rel="noopener">这篇</a>帖子。</p><a id="more"></a><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ol><li>本次配置使用的硬件设备：极路由3（HC5861、MT7620）</li><li>本次配置使用的固件：Lean’s Openwrt R21.6.22</li><li>本次配置使用的Mentohust：<a href="https://github.com/KyleRicardo/MentoHUST-OpenWrt-ipk" target="_blank" rel="noopener">Mentohust-ipk</a>、<a href="https://github.com/BoringCat/luci-app-mentohust" target="_blank" rel="noopener">Luci-App-Mentohust</a></li></ol><p>Lean’s Openwrt中内核模块默认勾选了NAT6功能，因此编译时只需要勾选编译Mentohust相关的软件包即可，编译的过程在此就不赘述了。</p><h1 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h1><p>刷入固件后，先不要连接路由器的WAN口，待电脑DHCP获取到由路由器分发的IP地址后，再将网线连接到WAN口。（如果一直连接WAN口，电脑会首先获取到校园网DHCP的IP地址，此时需要断开并重启电脑与路由器的连接）</p><h2 id="WAN6接口配置"><a href="#WAN6接口配置" class="headerlink" title="WAN6接口配置"></a>WAN6接口配置</h2><p>在基本设置中，各项配置如下：</p><ul><li>协议：DHCPv6客户端</li><li>请求IPv6地址：try</li><li>请求指定长度的IPv6前缀：自动</li></ul><p>在高级设置中，各项配置如下：</p><ul><li>使用内置的IPv6管理：不勾选</li><li>使用对端通告的 DNS 服务器：不勾选（SCNU校园网不分发IPv6的DNS服务器地址，IPv6的地址解析全都是用v4的DNS服务器，因此需要自行指定）</li><li>使用自定义的DNS服务器：<code>2001:da8::666</code></li></ul><p>保存并应用，可以看到WAN口同时获得了IPv4和IPv6的地址，接下来可以进行Mentohust的配置了。</p><p><img src="images/router/ipv6_wan6.png" alt="WAN口状态"></p><h2 id="Mentohust配置"><a href="#Mentohust配置" class="headerlink" title="Mentohust配置"></a>Mentohust配置</h2><p>打开<code>服务-MentoHUST</code>，在常规设置中进行如下配置：</p><ul><li>用户名和密码：填入自己的校园网用户名和密码</li><li>接口：选择WAN口网卡，我的路由器是WAN口是<code>eth0.2</code></li><li>Ping主机：如果需要掉线检测功能，就填入一个公网IP地址，我使用了自己的云服务器IP地址</li></ul><p>在高级设置中进行如下配置，其他无需修改：</p><ul><li>验证失败等待时间：5</li><li>DHCP设置：认证前</li><li>DHCP的脚本：<code>udhcpc -i eth0.2</code></li></ul><p>最后在常规设置中勾选启用，保存并应用，查看日志，试试能否登录成功。</p><p><img src="images/router/ipv6_mentohust.png" alt="Mentohust日志"></p><p>确认能够连上互联网后，ssh连接路由器，尝试ping一下IPv6的地址，验证路由器是否正确获取IPv6地址并连接成功，以下是ping6的命令和执行结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping6 -c 4 bt.byr.cn</span><br></pre></td></tr></table></figure><p><img src="images/router/ipv6_ping6.png" alt="Ping结果"></p><h2 id="LAN口配置"><a href="#LAN口配置" class="headerlink" title="LAN口配置"></a>LAN口配置</h2><p>在<code>接口</code>页面，找到<code>全局网络选项</code>，修改<code>IPv6 ULA前缀</code>：</p><ul><li>将地址的首位改为<code>d</code>（你喜欢改什么都行），我从<code>fd73:1f1d:a603::/48</code>改为了<code>dd73:1f1d:a603::/48</code></li></ul><p>编辑LAN口配置，找到<code>DHCP服务器</code>，修改<code>IPv6</code>设置：</p><ul><li>路由通告服务：服务器模式</li><li>DHCPv6服务：服务器模式</li><li>NDP代理：已禁用</li><li>DHCPv6模式：无状态的+有状态的</li><li>总是通告默认路由：取消勾选</li></ul><p>保存并等待一段时间，此时电脑应该获取到了路由器自行分发的IPv6地址，LAN口也有自己的IPv6地址。</p><p><img src="images/router/ipv6_interface.png" alt="接口配置"></p><h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><p>打开防火墙的<code>自定义规则</code>，添加如下一行规则并点击重启防火墙，开启IPv6数据包的转发。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -t nat -A POSTROUTING -o eth0.2 -j MASQUERADE</span><br></pre></td></tr></table></figure><h2 id="网关配置"><a href="#网关配置" class="headerlink" title="网关配置"></a>网关配置</h2><p>首先ssh登录路由器，查看当前IPv6的默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -6 route | grep default</span><br></pre></td></tr></table></figure><p>可以看到有2条路由配置</p><p><img src="images/router/ipv6_route.png" alt="默认路由"></p><p>复制这个<code>fe80</code>开头的IPv6地址，将当前的默认网关添加到默认路由中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -A inet6 add default gw fe80::274:9cff:fe80:dc7d dev eth0.2</span><br></pre></td></tr></table></figure><p>再次查看当前的默认路由，可以看到有3条记录</p><p><img src="images/router/ipv6_route1.png" alt="默认路由"></p><p>重启网络服务，验证局域网设备能否连上IPv6网络（重启后记得手动重启Mentohust服务）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure><p>由于默认路由重启后会重置，因此需要添加一个脚本，让路由器开机自动添加默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hotplug.d/iface/90-ipv6</span><br></pre></td></tr></table></figure><p>添加如下内容，其中的默认路由地址修改为自己的默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="string">"<span class="variable">$ACTION</span>"</span> = ifup ] || <span class="built_in">exit</span> 0</span><br><span class="line">route -A inet6 add default gw fe80::274:9cff:fe80:dc7d dev eth0.2</span><br></pre></td></tr></table></figure><p>保存退出后，赋予执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/hotplug.d/iface/90-ipv6</span><br></pre></td></tr></table></figure><h1 id="IPv6测试"><a href="#IPv6测试" class="headerlink" title="IPv6测试"></a>IPv6测试</h1><p>打开<a href="http://ipv6-test.com/" target="_blank" rel="noopener">http://ipv6-test.com/</a></p><p><img src="images/router/ipv6_test2.png" alt="测试结果"></p><p>打开<a href="http://test-ipv6.com/" target="_blank" rel="noopener">http://test-ipv6.com/</a></p><p><img src="images/router/ipv6_test1.png" alt="测试结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于SCNUNET，一开始我使用的IPv6方案为全中继的模式，路由器局域网设备IPv6地址全由上级路由器分发，局域网设备的确是获得了公网IPv6的地址，但是这个地址是上不了网的，而路由器的IPv6地址却使用正常，个人猜测是因为这些IPv6地址没有登录校园网，因此也无法使用。</p><p>既然在中继IPv6的方案下不可行，那就只能使用NAT6的方法了。在参考了许多篇配置的文章后，终于是配置成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因教育网IPv6不限速，使用清华TUNA的开源镜像站下载资源能够跑满带宽，体验非常好，所以就有了给路由器配置IPv6的想法。之前使用极路由官方固件时有官方的教育网插件可以用（使用6relay），但换了Openwrt后使用的是odhcpd，需要自己重新配置一下。这篇博客纪录了我的配置过程，其中参考了恩山论坛的&lt;a href=&quot;https://www.right.com.cn/forum/thread-316405-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇&lt;/a&gt;帖子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://fisher.lazybone.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://fisher.lazybone.xyz/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从High Sierra升级到Big Sur</title>
    <link href="http://fisher.lazybone.xyz/%E4%BB%8Ehigh-sierra%E5%8D%87%E7%BA%A7%E5%88%B0big-sur.html"/>
    <id>http://fisher.lazybone.xyz/从high-sierra升级到big-sur.html</id>
    <published>2021-05-30T03:52:26.000Z</published>
    <updated>2021-05-30T09:26:28.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看着Dock栏的图标一个个变成了正方形，软件慢慢开始不支持High Sierra系统，我也按耐不住想要升级系统了。但插在主板上的GTX1060告诉我，升级了系统之后就再也用不了它了，并且升级后的系统也不知道能不能正常使用。为了解决显卡这个问题，我去网上查了许多资料，研究了几种不同的解法，最终在不变动当前配置的情况下成功升级到Big Sur，Windows系统也毫无影响，付出的代价有2个：一是Big Sur下GTX1060无法使用；二是需要频繁插拔HDMI线，想要切换到Windows系统并使用GTX1060，需要把HDMI线从板载HDMI口拔下并插到显卡HDMI口上。</p><a id="more"></a><h1 id="升级思路"><a href="#升级思路" class="headerlink" title="升级思路"></a>升级思路</h1><p>升级系统的思路主要有以下几种：</p><ul><li>只用集显的方法，这是最简单的一种方法了，把GTX1060拔了，舍弃独显，重新配置机型，全新安装Big Sur。这种方法最简单，但是Windows下只能用UHD630，游戏没法好好玩了。</li><li>显卡置换的方法，把GTX1060卖了之后换免驱的A卡，前一个星期我都在观察RX560和R9 Nano，想要入手一张。奈何是ITX机箱，A卡的ITX卡存量较少，价格较高，没舍得采用这种方案。</li><li>系统分开使用显卡的方法，在Big Sur中只用UHD630集显，在Windows中使用GTX1060。这种方法的好处是机器不需要对配置进行任何改动，但想要启动Windows打游戏的时候，需要把HDMI线插到独显上，想要启动Big Sur干活的时候，需要把HDMI线插到板载HDMI口上。</li></ul><p>最终，我使用了第三种方法，虽然频繁插拔HDMI线麻烦了一点，但是不需要花钱，也不需要动硬件，也算是一种比较省心的方法了。</p><h1 id="Bios设置"><a href="#Bios设置" class="headerlink" title="Bios设置"></a>Bios设置</h1><p>本次升级中，Bios设置主要集中在北桥中，设置如下：</p><ul><li>首选显卡：CPU Graphics</li><li>iGPU：Disable（启用后，主板会将板载和独显的HDMI口当成两个屏幕的输出，这样子就无法做输出区分了）</li><li>DVMT Pre-Allocated：128M（网上资料说：分配显存过小可能会出现花屏和黑屏，具体我没验证过）</li><li>RC6：Auto</li></ul><p><img src="images/hackintosh/bigsur_bios.png" alt="Bios设置"></p><h1 id="系统下载"><a href="#系统下载" class="headerlink" title="系统下载"></a>系统下载</h1><p>由于百度云没会员实在是太慢了，我使用了<a href="https://github.com/munki/macadmin-scripts" target="_blank" rel="noopener">macadmin-scripts</a>脚本下载系统，该脚本的使用方法很简单，下载的镜像也是官方的纯净镜像。</p><ul><li>拉取仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop/</span><br><span class="line">git clone https://github.com/munki/macadmin-scripts.git</span><br><span class="line">cd macadmin-scripts/</span><br></pre></td></tr></table></figure><ul><li>以管理员身份运行脚本，如果提示缺少依赖，使用pip3安装对应依赖即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 ./installinstallmacos.py</span><br></pre></td></tr></table></figure><ul><li>在更新资源目录之后，脚本会询问想要下载哪个版本的镜像，这里我直接选择最新版的Big Sur，序号是18</li></ul><p><img src="images/hackintosh/downloadimage.png" alt="选择需要下载的镜像"></p><ul><li>接着脚本就会自动下载镜像，下载完成之后在文件夹中会自动生成一个dmg文件，该文件就是系统镜像了</li></ul><p>提示：如果下载过程中由于网络波动等原因导致下载失败，没有关系，重新运行脚本并选择相同的镜像序号，脚本会自动从下载失败的地方继续下载。</p><h1 id="OpenCore配置"><a href="#OpenCore配置" class="headerlink" title="OpenCore配置"></a>OpenCore配置</h1><p>这一步中，我们需要准备一个U盘，往里面放一份当前系统的EFI配置，然后进行修改。接下来的升级安装过程中全程使用这一份配置来引导系统。</p><p>由于之前的OpenCore配置文件中启用了独立显卡并指定为N卡，我们需要修改一下，将独显禁用并添加核显配置参数。如有需要，还要更换机型配置。（我从iMac18,2更换到Macmini8,1）</p><ul><li>首先是添加对集显的支持，我的集显是UHD630，添加的参数配置如下，其他型号的集显可以在各种黑苹果论坛查对应的键值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>PciRoot(0x0)/Pci(0x2,0x0)<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>AAPL,ig-platform-id<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>BwCbPg==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>AAPL,slot-name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Internal@0,2,0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>device-id<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>mz4AAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>device_type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>VGA compatible controller<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>dpcd-max-link-rate<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>FAAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-dpcd-max-link-rate-fix<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-hdmi20<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-lspcon-support<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-busid<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-has-lspcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAgAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-has-lspcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AwAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CAAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAgAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-busid<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-patch-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-unifiedmem<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAAAgA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>hda-gfx<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>onboard-1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>model<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Intel UHD Graphics 630<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加后的OC配置如下图所示</p><p><img src="images/hackintosh/ocdeviceproperties_update_bigsur.png" alt="集显配置"></p><ul><li>接下来是禁用Intel网卡和蓝牙的驱动，因为不同系统版本有对应编译的驱动，升级完系统后还需要对这两个驱动升级，最后才能启用这两个驱动</li><li>同时，对于我的主板（Asus B360i），我还需要勾选<code>DisableRtcChecksum</code>，否则升级系统后每次开机主板都会进入安全模式</li></ul><p><img src="images/hackintosh/ockernel_update_bigsur.png" alt="禁用驱动"></p><ul><li>随后是启动参数的修改，清空之前的所有参数，填入以下参数：<ul><li><code>-v</code>：启动Debug模式，出问题时方便排查</li><li><code>debug=0x100</code>：显示更多的Debug信息</li><li><code>keepsyms=1</code>：出现问题后不自动重启，而是卡住并保持输出Debug信息</li><li><code>alcid=7</code>：声卡驱动ID注入</li><li><code>igfxfw=2</code>：使用核显启动</li><li><code>igfxonln=1</code>：修复视频线热插拔问题</li><li><code>-wegnoegpu</code>：禁用独立显卡</li></ul></li></ul><p><img src="images/hackintosh/ocnvram_update_bigsur.png" alt="启动参数的修改"></p><ul><li>最后是机型的修改（可选），由于我之前的机型参数<code>iMac18,2</code>使用的是7代酷睿，因此在Hackintool中CPU架构显示为<code>???</code>。本次升级顺带将机型参数也更换掉，更换为配置更接近的<code>Macmini8,1</code></li><li>具体操作在OCC的PlatformInfo中选择对应机型，检查序列号，确定该序列号无效后即可</li></ul><h1 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h1><p>本次升级中，我曾尝试制作U盘启动盘，然后从<code>安装Big Sur</code>中启动并升级系统，但是升级到一大半就会提示该镜像已损坏，请重新下载的提醒。没办法，我只好放弃从U盘启动盘中升级系统。</p><p>随后我在硬盘EFI中删除<code>nvda_drv=1</code>，添加<code>-wegnoegpu</code>参数禁用独立显卡，将HDMI线接到板载HDMI接口，启动系统，此时系统是没有显卡驱动的。直接双击打开镜像然后点击升级，当系统自动重启时，转成使用U盘EFI进行引导，并在随后的启动中都使用U盘EFI进行引导。没想到这种方法居然升级成功了，因为不确定是否会成功，所以没有拍什么图片，只有下面这一张。</p><p><img src="images/hackintosh/bigsur_update.png" alt="升级成功"></p><p>值得注意的是，刚刚升级成功后电脑非常的卡，以至于在系统初始化设置界面，每点一次下一步都要等很久，这是正常现象，慢慢等就好了。</p><h1 id="完成升级"><a href="#完成升级" class="headerlink" title="完成升级"></a>完成升级</h1><p>进入系统之后，首先提醒的是N卡的WebDriver不再使用于本系统，直接卸载就可以了。</p><p>接下来更新驱动，把OC中能更新的驱动全部更新，注意Intel的Wi-Fi和蓝牙驱动要下载Big Sur版本的，在配置文件中重新勾选启用这两个驱动，保存重启测试，确认能够正常启动之后，我们就可以将新版的EFI从U盘覆盖到硬盘中了。</p><p>注意：这次升级之后我还遇到了一个问题是USB驱动问题，刚开机的时候鼠标和键盘非常卡，并且蓝牙驱动不会加载，这很明显就是USB定制驱动的问题，需要重新定制一次。重新定制之后，蓝牙驱动能够正常加载了，但是开机速度慢了很多，通过Debug的日志可以看到，蓝牙驱动一直在循环等待<code>IO USB Controller</code>这个控制器启动，而这个控制器的启动速度慢的离谱，具体解决方案目前还没有。如果你知道这个问题的解决方法，请在<a href="https://github.com/FisherWY/Asus-B360i-Hackintosh-EFI" target="_blank" rel="noopener">我的仓库</a>中提issue，非常感谢。</p><p>至此，一次系统的升级终于完成，可以开始好好体验Big Sur的新功能了。</p><p><img src="images/hackintosh/bigsur_version.png" alt="升级完成"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看着Dock栏的图标一个个变成了正方形，软件慢慢开始不支持High Sierra系统，我也按耐不住想要升级系统了。但插在主板上的GTX1060告诉我，升级了系统之后就再也用不了它了，并且升级后的系统也不知道能不能正常使用。为了解决显卡这个问题，我去网上查了许多资料，研究了几种不同的解法，最终在不变动当前配置的情况下成功升级到Big Sur，Windows系统也毫无影响，付出的代价有2个：一是Big Sur下GTX1060无法使用；二是需要频繁插拔HDMI线，想要切换到Windows系统并使用GTX1060，需要把HDMI线从板载HDMI口拔下并插到显卡HDMI口上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://fisher.lazybone.xyz/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>从Clover迁移到OpenCore</title>
    <link href="http://fisher.lazybone.xyz/%E4%BB%8Eclover%E8%BF%81%E7%A7%BB%E5%88%B0opencore.html"/>
    <id>http://fisher.lazybone.xyz/从clover迁移到opencore.html</id>
    <published>2021-04-11T01:48:59.000Z</published>
    <updated>2021-04-11T04:18:30.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前，OpenCore Bootloader已经开发了相当一段时间，已经趋近于稳定。OpenCore的启动方式更接近于原生macOS电脑，对系统的注入更少，越来越多的驱动都基于OpenCore适配开发。因此，将Bootloader从Clover迁移到OpenCore也是时候提上日程了。以下博客记录了我的迁移过程，并向大家分享一下我的迁移方法。不同于网上的纯ProperTree手动配置、纯OpenCore Configurator图形配置或OC Gen-X直接生成，我同时用到了以上三种工具，节省了迁移成本的同时，也避免遇到了很多错误。</p><a id="more"></a><h1 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h1><p>首先介绍的是我的硬件信息，如下表所示。</p><table><thead><tr><th style="text-align:center">硬件类型</th><th style="text-align:center">型号</th></tr></thead><tbody><tr><td style="text-align:center">主板</td><td style="text-align:center">Asus Rog Strix B360-i Mini ITX</td></tr><tr><td style="text-align:center">处理器</td><td style="text-align:center">Intel Core i5-8500</td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">Crucial By Micron DDR4 2666MHz 8GB + Corsair LPX DDR4 3000MHz 8GB(运行在2666MHz)</td></tr><tr><td style="text-align:center">显卡</td><td style="text-align:center">Nvidia GeForce GTX 1060 3GB</td></tr><tr><td style="text-align:center">硬盘</td><td style="text-align:center">Asgard AN2 NVMe 250GB</td></tr><tr><td style="text-align:center">网卡</td><td style="text-align:center">板载Intel AC 9560</td></tr></tbody></table><h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>整个配置的过程需要用到以下的工具包，均可以从GitHub下载，注意工具对应的OC版本需要一致，否则极大概率会出错。</p><ul><li>OpenCore（版本0.6.8正式版），地址在<a href="https://github.com/acidanthera/OpenCorePkg" target="_blank" rel="noopener">这里</a></li><li>OC Gen-X（版本3.0.2），地址在<a href="https://github.com/Pavo-IM/OC-Gen-X" target="_blank" rel="noopener">这里</a></li><li>OpenCore Configurator（版本2.33.1.2），GitHub地址在<a href="https://github.com/notiflux/OpenCore-Configurator" target="_blank" rel="noopener">这里</a>，软件下载地址在<a href="https://www.macwk.com/soft/opencore-configurator" target="_blank" rel="noopener">这里</a></li></ul><p>将OpenCore解压，安装OC Gen-X，安装OpenCore Configurator。至此，工具的准备工作完成。</p><h1 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h1><p>首先我们需要准备一份适合本机配置的配置文件，如果使用OCC或ProperTree纯手动配置的话，需要手动填入很多参数，费时又容易出错。因此我们使用OC Gen-X直接生成一份简单的配置文件，然后再基于这份配置文件进行修改。</p><p>打开OC Gen-X，首先确认系统架构。因为我使用的是第八代酷睿，因此在System Type选择<code>Intel Consumer</code>的<code>Coffee Lake</code>。</p><p><img src="images/hackintosh/genxsystemtype.png" alt="系统架构"></p><p>接下来在Kext中进行如下列表的勾选，图比较多我就只放<code>Essential</code>中的一张了</p><ul><li>Essential，勾选：Lilu和VirtualSMC</li><li>VirtualSMC Plugins，勾选：SMCProcessor、SMCSuperIO和SMCLightSensor</li><li>Graphics，勾选：WhateverGreen（Boot Args留空），AGPMInjector（显卡节能用，选择你目前的仿冒型号和GPU，我的选择是<code>iMac18,2</code>和<code>GTX1060</code>）</li><li>Audio，勾选：AppleALC（Boot Args留空）</li><li>Ethernet，勾选：IntelMausi</li><li>USB，勾选：USBInjectALL</li><li>WI-FI and Bluetooth，无需勾选，稍后手动添加驱动</li><li>Extra’s，无需勾选，里面的驱动是给AMD CPU使用的</li></ul><p><img src="images/hackintosh/genxkext.png" alt="驱动选择"></p><p>接下来在Firmware Drivers中，在<code>UEFI</code>中勾选<code>OpenRuntime.efi</code>和<code>HfsPlus.efi</code>。</p><p><img src="images/hackintosh/genxfirmwaredrivers.png" alt="固件选择"></p><p>最后在SMBIOS中，OC Gen-X会自动填入当前系统的SMBIOS信息，不需要去修改了。在Additional BootArgs中也不需要填入任何参数，稍后用OCC手动填入即可。</p><p>点击下方<code>Generate EFI</code>，就会在你的桌面生成一个EFI文件夹，此时可以关闭OC Gen-X了，接下来的操作就是修改这个EFI的配置。</p><p><img src="images/hackintosh/genxsuccess.png" alt="生成配置"></p><h1 id="添加固件、驱动、主题"><a href="#添加固件、驱动、主题" class="headerlink" title="添加固件、驱动、主题"></a>添加固件、驱动、主题</h1><p>OC Gen-X生成的EFI文件并不是立即就能使用的，还需要根据自己的需要进行修改，以下是我的修改过程。</p><p>首先打开<code>EFI/OC/Drivers</code>，可以看到里面只有刚刚勾选添加的2个固件，缺少了其他固件，OC是启动不起来的，因此需要添加OpenCore官方包中的固件。打开<code>OpenCore</code>官方EFI（准备阶段中下载解压的）中的<code>OpenCore-0.6.8-RELEASE/X64/EFI/OC/Drivers</code>，可以看到里面有很多OC的启动固件，把这些固件全部复制到Gen-X生成的EFI中。</p><p><img src="images/hackintosh/genxdriverscopy.png" alt="复制固件"></p><p>接下来打开<code>EFI/OC/Kexts</code>，可以看到文件夹中已经添加了我们刚刚在Gen-X中勾选的驱动。但每个人的配置都不同，还需要根据自己的配置添加对应的驱动。对于我的配置来说，我还需要添加的驱动和作用在以下列表中。</p><ul><li>AirportItlwm.kext，Intel AC 9560网卡驱动，这个Airport版本支持原生Airdrop</li><li>CPUFriend.kext，CPU变频补丁驱动，添加后有低频档位</li><li>HibernationFixup.kext，睡眠修复补丁，目前发现添加与否并不影响睡眠，先加了再说</li><li>IntelBluetoothFirmware.kext，Intel AC 9560蓝牙驱动</li><li>IntelBluetoothInjector.kext，修复系统蓝牙开关为灰色的补丁</li><li>NVMeFix.kext，NVME固态硬盘兼容性提升驱动</li></ul><p>添加完驱动后的Kexts文件夹如下图所示。</p><p><img src="images/hackintosh/genxkextscopy.png" alt="添加驱动"></p><p>（可选）最后可以根据需要添加Bootloader的主题，如果没有主题，OpenCore的启动界面是纯文字的，也不是不能用。但是为了好看，我还是弄了一套官方的主题。</p><p>从GitHub拉取<code>OcBinaryData</code>仓库，地址在<a href="https://github.com/acidanthera/OcBinaryData" target="_blank" rel="noopener">这里</a>。因为我不需要开机声音，所以我把拉取后把仓库中的<code>Resources/Audio</code>下的音频文件全部删除了。</p><p>最后，把整个Resources文件夹替换掉<code>EFI/OC/</code>中的Resources文件夹即可。</p><p>至此，EFI中的固件、驱动、主题文件准备完毕，接下来就是对配置文件进行修改。</p><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>在修改配置文件之前，我们需要准备一个有EFI分区的U盘，最好是以前配置Clover时留下来的一个备份。挂载这个U盘的EFI分区，将里面的EFI文件替换，然后就可以开始配置文件的修改了。</p><p>使用OpenCore Configurator打开U盘<code>EFI/OC</code>中的<code>config.plist</code>，开始配置文件的修改。</p><p>首先是<code>ACPI-ACPI设置</code>，这里需要根据机型的不同添加对应的SSDT文件，在右侧列表框的下方点击<code>下载/更新Acpi文件</code>，对于我的配置，我需要下载以下SSDT文件：</p><ul><li>SSDT-AWAC</li><li>SSDT-EC-USBX-DESKTOP</li><li>SSDT-PLUG-DRTNIA</li><li>SSDT-PMC</li></ul><p><img src="images/hackintosh/occacpidownload.png" alt="下载SSDT"></p><p>点击下载后，就可以关闭ACPI补丁下载器了，然后点击<code>快照添加</code>，刚刚下载的SSDT配置文件就会自动添加并启用，配置完成后的ACPI设置界面如下。</p><p><img src="images/hackintosh/occacpi.png" alt="ACPI设置"></p><p>接下来的<code>Booter-启动设置</code>，不需要修改里面的任何选项，直接跳过。</p><p>接下来的<code>DeviceProperties-设备属性设置</code>，如果想开启核显加速，就需要在里面添加核显设备。点击左侧设备列表的加号，在新添加的空白栏中填入<code>PciRoot(0x0)/Pci(0x2,0x0)</code>，然后点击右侧表格下方的加号，在新添加的空白栏中的键填入<code>AAPL,ig-platform-id</code>，在值中填入<code>0300983E</code>，不同CPU，不同核显和不同的加速效果有着不同的值，这个值需要在网上查询自己核显的<code>ig-platform-id</code>，添加后的效果如下。</p><p><img src="images/hackintosh/occdeviceproperties.png" alt="设备属性设置"></p><p>接下来的<code>Kernel-内核设置</code>，需要在<code>添加</code>页面加入自己需要启用的驱动，打开<code>EFI/OC/Kexts</code>，拖动自己添加的驱动到列表中，启用即可。这里需要注意调整启动顺序，自己添加驱动启动顺序最好放在最后面。添加后的效果如下。</p><p><img src="images/hackintosh/occkerneladd.png" alt="驱动页设置"></p><p>在<code>Kernel-内核设置</code>中，还需要添加的是RTC修复的补丁，否则每次重启开机BIOS都会进入安全模式，具体原因在xjn的博客中有详细描述，想了解更多的点<a href="https://blog.xjn819.com/post/rtc-issues-related-to-oc.html" target="_blank" rel="noopener">这里</a>。点击<code>补丁</code>，在表格右下角点2次加号，添加两个补丁条目。在两个条目中，标识符均填入<code>com.apple.driver.AppleRTC</code>，替换次数均填入<code>1</code>，均勾选启用。在第一个条目中的查找中填入<code>752E0FB6</code>，在第一个条目中的替换中填入<code>EB2E0FB6</code>。在第二个条目中的查找中填入<code>75330FB7</code>，在第二个条目中的替换中填入<code>EB330FB7</code>，最小内核和最大内核填入<code>18.5.0</code>（网上也有解决方法是不需要填入内核参数的，但我并没有进行测试，有兴趣的朋友可以测试一下）。填完后的效果如下。</p><p><img src="images/hackintosh/occkernelpatch.png" alt="补丁页设置"></p><p>接下来是<code>Misc-其他设置</code>，如果在上一节中添加了主题文件并且想启用，在<code>Boot</code>页的设置中需要把<code>Picker Mode启动界面模式修改为External</code>，如果想隐藏多余的启动项（例如：恢复分区、Reset NVRAM等），可以勾选<code>HideAuxiliary</code>，修改后的效果如下。</p><p><img src="images/hackintosh/occmiscboot.png" alt="Boot页设置"></p><p>在<code>Misc-其他设置</code>中，还需要修改启动的安全选项，在<code>Security</code>页中，将<code>Vault</code>参数改为<code>Optional</code>，如果使用<code>AirportItlwn</code>驱动，还需要将<code>SecureBootMode</code>参数修改为<code>Default</code>，这个参数会导致开机速度变慢，但为了使用Intel原生Wi-Fi驱动，也是没办法的事情，修改后的效果如下。</p><p><img src="images/hackintosh/occmiscsecurity.png" alt="Security页设置"></p><p>接下来是<code>NVRAM-随机访问储存器设置</code>，我们需要修改启动参数，不同配置的机型启动参数可能不同。点击左侧UUID表中的<code>7C436110-AB2A-4BBB-A880-FE41995C9F82</code>，在右侧<code>boot-args</code>中把默认的值删掉，填入<code>-v debug=0x100 keepsyms=1 nvda_drv=1 alcid=7</code>，下面是参数含义解释。</p><ul><li>-v，开启debug模式，测试无问题后可删去</li><li>debug=0x100，在启动遇到问题后不自动关机，而是停止操作，方便观察debug log</li><li>keepsyms=1，输出更多的debug信息，方便调试</li><li>nvda_drv=1，启用NVIDIA驱动，N卡独显需要使用</li><li>alcid=7，声卡ID注入，我的板载声卡注入ID为7</li></ul><p>配置完成后的效果如下。</p><p><img src="images/hackintosh/occnvram.png" alt="NVRAM配置"></p><p>接下来是<code>PlatformInfo-机型平台设置</code>，由于Gen-x在生成配置文件时已经自动填入机型信息，这一页不需要再手动配置了。</p><p>最后是<code>UEFI-UEFI设置</code>，如果要开启OC的主题，还需要添加UEFI驱动。点击<code>UEFI驱动</code>页面，点击<code>浏览</code>，将<code>EFI/OC/Drivers</code>中的<code>OpenCanopy.efi</code>添加到表格中，添加后效果如下。</p><p><img src="images/hackintosh/occuefi.png" alt="UEFI设置"></p><p>至此，OC的启动配置文件修改完成，按<code>command + s</code>保存配置，就可以开始重启，使用OC尝试引导系统了。</p><h1 id="清除Clover残余"><a href="#清除Clover残余" class="headerlink" title="清除Clover残余"></a>清除Clover残余</h1><p>如果使用OC能够成功引导系统，并且使用一段时间后没有任何问题，就可以将硬盘上的Clover EFI替换为OpenCore EFI了。替换的操作也是一样的，将整个EFI文件夹替换即可，最后在Terminal中执行以下代码，清除Clover残留文件即可完成迁移。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Clover 位于系统偏好设置中的面板</span></span><br><span class="line">sudo rm -rf <span class="string">"/Library/PreferencePanes/Clover.prefPane"</span></span><br><span class="line"><span class="comment"># 删除 Clover 的自动脚本</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.clover.lib"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/10.save_and_rotate_boot_log.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/20.mount_ESP.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/80.save_nvram_plist.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.shutdown.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.shutdown.d"</span></span><br><span class="line"><span class="comment"># 删除 Clover 的守护进程</span></span><br><span class="line">launchctl unload <span class="string">'/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'</span></span><br><span class="line">rm -rf <span class="string">'/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverDaemonNew'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverLogOut'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverWrapper.sh'</span></span><br></pre></td></tr></table></figure><p>在迁移到OC后，最好再重置一次NVRAM，重置完后系统就完全是由OC来引导启动了，接下来就开启愉快的OC之旅了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前，OpenCore Bootloader已经开发了相当一段时间，已经趋近于稳定。OpenCore的启动方式更接近于原生macOS电脑，对系统的注入更少，越来越多的驱动都基于OpenCore适配开发。因此，将Bootloader从Clover迁移到OpenCore也是时候提上日程了。以下博客记录了我的迁移过程，并向大家分享一下我的迁移方法。不同于网上的纯ProperTree手动配置、纯OpenCore Configurator图形配置或OC Gen-X直接生成，我同时用到了以上三种工具，节省了迁移成本的同时，也避免遇到了很多错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://fisher.lazybone.xyz/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>获取米家MIIO设备Token</title>
    <link href="http://fisher.lazybone.xyz/%E8%8E%B7%E5%8F%96%E7%B1%B3%E5%AE%B6miio%E8%AE%BE%E5%A4%87token.html"/>
    <id>http://fisher.lazybone.xyz/获取米家miio设备token.html</id>
    <published>2021-02-28T12:52:04.000Z</published>
    <updated>2021-03-27T08:29:23.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因毕设选题是和物联网相关的主题，要做一个能够控制智能家居设备的微信小程序。所以就有了自由控制米家智能家居设备的需求，想要控制米家MIIO设备，就需要获取智能设备的token。但小米对获取token的方法不断进行封堵，截止这篇博客发布时，通过Android手机Root，读取旧版米家中存有token的sqlite文件已经不可行了（旧版米家APP直接闪退）；通过抓包的方式读取device_list包中的token也不行了（数据包的body已经被加密）；python-miio中discover方法也早已不行了（返回的是无效的token）。我所知道的方法中，使用<a href="https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor" target="_blank" rel="noopener">tokens-extractor</a>和读取IOS设备备份文件数据的方法还可以使用，但何时失效就不好说了</p><a id="more"></a><h1 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h1><p>最简单的方法当然是使用<a href="https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor" target="_blank" rel="noopener">Xiaomi Cloud Tokens Extractor</a>了，该脚本模拟Android米家APP的登录，以直接获取到自己账号下的智能设备信息，就能直接拿到token了。操作的流程也很简单，下载脚本运行即可，脚本需要依赖python的requests库，以下是简单的shell代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests</span><br><span class="line">wget https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor/raw/master/token_extractor.py</span><br><span class="line">python3 token_extractor.py</span><br></pre></td></tr></table></figure><p>按照脚本中的提示输入账号密码，选择地区（一般是cn），然后看输出即可，如下图所示：</p><p><img src="./images/miio/token_success.png" alt="成功获取token"></p><p>但是，这个脚本不是一直都成功的，以上图片是我在2021年2月初时获取成功后截图的。如果出现脚本不能用的情况，就要等待作者更新脚本了，在这里先对作者说声辛苦了，非常感谢！</p><h1 id="读取IOS设备备份文件数据"><a href="#读取IOS设备备份文件数据" class="headerlink" title="读取IOS设备备份文件数据"></a>读取IOS设备备份文件数据</h1><p>这个方法相对来说比较麻烦，尤其是对于我这种手机文件多的，备份一次要好久…但是没办法，活还是得干嘛，至于小米何时再给数据文件来个加密，那就真的是麻烦了</p><h2 id="将设备备份"><a href="#将设备备份" class="headerlink" title="将设备备份"></a>将设备备份</h2><p>首先要修改一下备份的选项，在手机摘要页面的备份中，将<code>给iPhone备份加密</code>选项关掉，如下图所示，然后再点击立即备份，等待备份完成即可</p><p><img src="./images/miio/backup.png" alt="备份选项"></p><h2 id="iBackup-Viewer导出数据"><a href="#iBackup-Viewer导出数据" class="headerlink" title="iBackup Viewer导出数据"></a>iBackup Viewer导出数据</h2><p>点击<a href="https://www.imactools.com/iphonebackupviewer/" target="_blank" rel="noopener">这里</a>可以下载iBackup Viewer，下载完后安装即可，如果这个网站打不开，也可以下载我的服务器<a href="https://fisher.lazybone.xyz/downloads/software/iBackupViewer.dmg">提供</a>的4.1760版本，安装完之后打开软件，点击自己刚刚备份的那个设备（那个壁纸可以点的），载入备份后点最后一个像分支一样的图标（Raw Files）。</p><p>在<code>AppDomain</code>中找到<code>com.xiaomi.mihome</code>并点击，此时右侧就显示米家APP备份的数据，在右侧点击<code>Name</code>以按照文件名排序，看到一个名为<code>xxx_mihome.sqlite</code>的文件后（xxx是你的小米账号ID），选择这个文件并点击右上角<code>Export</code>，点击<code>Selected...</code>，选择一个位置将这个文件导出即可，以下是操作流程图：</p><p><img src="./images/miio/export.png" alt="导出sqlite文件"></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取数据需要用到<code>python-miio</code>包，安装一下即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-miio</span><br></pre></td></tr></table></figure><p>接着使用<code>miio-extract-tokens</code>读取数据就可以获得token了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miio-extract-tokens --dump-all xxx_mihome.sqlite</span><br></pre></td></tr></table></figure><p><img src="./images/miio/extract.png" alt="读取数据"></p><p>拿到token后，就能够做自己想做的事情了^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因毕设选题是和物联网相关的主题，要做一个能够控制智能家居设备的微信小程序。所以就有了自由控制米家智能家居设备的需求，想要控制米家MIIO设备，就需要获取智能设备的token。但小米对获取token的方法不断进行封堵，截止这篇博客发布时，通过Android手机Root，读取旧版米家中存有token的sqlite文件已经不可行了（旧版米家APP直接闪退）；通过抓包的方式读取device_list包中的token也不行了（数据包的body已经被加密）；python-miio中discover方法也早已不行了（返回的是无效的token）。我所知道的方法中，使用&lt;a href=&quot;https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tokens-extractor&lt;/a&gt;和读取IOS设备备份文件数据的方法还可以使用，但何时失效就不好说了&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://fisher.lazybone.xyz/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="毕设" scheme="http://fisher.lazybone.xyz/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码编译</title>
    <link href="http://fisher.lazybone.xyz/jdk%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.html"/>
    <id>http://fisher.lazybone.xyz/jdk源码编译.html</id>
    <published>2021-02-13T02:19:37.000Z</published>
    <updated>2021-02-14T01:54:17.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>考完研之后，接下来要准备的就是实习了。我也想尝试一下去春招，做好两手准备，所以需要开始学习面试要用到的知识了。我做过的比较好的项目主要使用的是Java，但之前都仅限于使用Java语言，并没有去看过Java的源码。为了深入理解Java这门语言（其实是为了准备面试），我将尝试去看Java的源码，注释写上自己的理解，并将这份源码编译，然后作为自己编译的第一个JDK使用。</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>前期的准备包括以下内容：</p><ul><li>源码和BootJDK的下载</li><li>检查和安装编译需要用到的Toolchain</li></ul><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>源码下载很简单，去GitHub的<a href="https://github.com/openjdk" target="_blank" rel="noopener">OpenJDK</a>项目组里面找到需要编译的JDK版本对应的仓库，Clone下来即可</p><p>这里我编译的是JDK15，仓库地址在<a href="https://github.com/openjdk/jdk15" target="_blank" rel="noopener">这里</a>，这里我把源码Clone到Document中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Document</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openjdk/jdk15.git</span><br></pre></td></tr></table></figure><h2 id="BootJDK下载"><a href="#BootJDK下载" class="headerlink" title="BootJDK下载"></a>BootJDK下载</h2><p>编译需要一个BootJDK，用这个BootJDK去编译一个新的JDK出来，这个就有点像鸡生蛋，蛋生鸡的问题了hh</p><p>可以用本机已有的JDK，但是如果版本太老的话也有可能出现编译失败的问题，为了保证编译能够成功，我这里下载了JDK15作为BootJDK</p><p>下载JDK的网址在<a href="https://jdk.java.net/" target="_blank" rel="noopener">这里</a>，找到对应的系统版本点下载就好了，下载完之后解压到自己记得的地方</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openjdk-15.0.2_osx-x64_bin.tar.gz -C /Users/fisher/Document</span><br></pre></td></tr></table></figure><h2 id="检查和安装ToolChain"><a href="#检查和安装ToolChain" class="headerlink" title="检查和安装ToolChain"></a>检查和安装ToolChain</h2><p>macOS首先需要检查安装Xcode command line tool，可以选择在App Store中直接安装Xcode，也可以在终端中使用以下命令仅安装Command line tool</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>接着检查clang，clang++，autoconf，make和freetype</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang --version</span><br><span class="line">clang++ --version</span><br><span class="line">autoconf --version</span><br><span class="line">make --version</span><br><span class="line">freetype-config --ftversion</span><br></pre></td></tr></table></figure><p>如果没有安装的话，使用homebrew安装即可，这里以freetype为例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install freetype</span><br></pre></td></tr></table></figure><p>其他系统的ToolChain检查安装，可以参考<a href="https://github.com/openjdk/jdk/blob/master/doc/building.md#native-compiler-toolchain-requirements" target="_blank" rel="noopener">这份</a>文档</p><h1 id="配置与编译"><a href="#配置与编译" class="headerlink" title="配置与编译"></a>配置与编译</h1><p>前期准备工作完成后，就可以开始配置和编译了</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>切换到源码的目录下，使用<code>bash configure</code>命令配置，这里我使用2个参数，分别是：目标系统位数，BootJDK位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> jdk15source</span><br><span class="line">bash configure --with-target-bits=64 --with-boot-jdk=/Users/fisher/Documents/jdk15/Contents/Home</span><br></pre></td></tr></table></figure><p>接着就开始滚屏了，如果中途出现缺少依赖等提示，安装提示安装对应的依赖即可。当看到以下界面的时候，就说明编译前的配置成功了，可以正式开始编译了</p><p><img src="images/jdk/configure.png" alt="编译配置成功"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在源码跟目录下使用<code>make images</code>命令编译，等待一段时间就可以编译完了</p><p>Linux建议系统内存要8G以上，我的虚拟机6G内存在编译到JavaDoc的时候出现了内存不足编译失败的情况</p><p><img src="images/jdk/compile.png" alt="编译完成"></p><p>看到以上图片，就表示编译已经完成</p><h1 id="验证编译结果"><a href="#验证编译结果" class="headerlink" title="验证编译结果"></a>验证编译结果</h1><p>切换目录到<code>./build/macosx-x86_64-server-release/jdk</code>下，用<code>./bin/java --version</code>就能看到自己编译的成果了</p><p><img src="images/jdk/verification.png" alt="验证编译成果"></p><p>接下来在IDEA中添加自己刚刚编译的JDK，将<code>source</code>定位到编译JDK使用的源码，在写代码和debug的时候就能够边看自己写的注释边工作了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;考完研之后，接下来要准备的就是实习了。我也想尝试一下去春招，做好两手准备，所以需要开始学习面试要用到的知识了。我做过的比较好的项目主要使用的是Java，但之前都仅限于使用Java语言，并没有去看过Java的源码。为了深入理解Java这门语言（其实是为了准备面试），我将尝试去看Java的源码，注释写上自己的理解，并将这份源码编译，然后作为自己编译的第一个JDK使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://fisher.lazybone.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器更换国内软件源</title>
    <link href="http://fisher.lazybone.xyz/docker%E5%AE%B9%E5%99%A8%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E8%BD%AF%E4%BB%B6%E6%BA%90.html"/>
    <id>http://fisher.lazybone.xyz/docker容器更换国内软件源.html</id>
    <published>2020-07-19T07:54:04.000Z</published>
    <updated>2020-07-19T08:04:02.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Docker容器使用apt作为软件包管理器，并且默认软件源是国外服务器，更新源和下载软件的速度都非常慢，因此需要更换为国内的软件源。但由于容器十分纯净，甚至连vi和vim都没有，不能通过编辑器打开修改软件源配置文件，关于这个问题的解决方法，我们可以使用shell的管道直接修改软件源配置文件。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><a id="more"></a><p>我们可以通过管道来将国内软件源地址写入到配置文件中，具体操作如下：</p><ol><li><p>进入容器，备份yum源配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it container bash</span><br><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure></li><li><p>写入国内软件源地址，此处用的是网易的软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt; EOF</span><br><span class="line">deb http://mirrors.163.com/debian/ buster main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian/ buster-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-updates main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian/ buster-backports main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-backports main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian-security buster/updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian-security buster/updates main contrib non-free</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><img src="images/docker/writeconf.png" alt="写入配置"></p></li><li><p>更新apt软件包索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p><img src="images/docker/updateapt.png" alt="更新包索引"></p></li><li><p>安装所需要的软件包，完成！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim -y</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;Docker容器使用apt作为软件包管理器，并且默认软件源是国外服务器，更新源和下载软件的速度都非常慢，因此需要更换为国内的软件源。但由于容器十分纯净，甚至连vi和vim都没有，不能通过编辑器打开修改软件源配置文件，关于这个问题的解决方法，我们可以使用shell的管道直接修改软件源配置文件。&lt;/p&gt;&lt;h1 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="服务器配置" scheme="http://fisher.lazybone.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker" scheme="http://fisher.lazybone.xyz/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker的Redis集群搭建</title>
    <link href="http://fisher.lazybone.xyz/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html"/>
    <id>http://fisher.lazybone.xyz/基于docker的redis集群搭建.html</id>
    <published>2020-07-19T07:53:09.000Z</published>
    <updated>2020-07-19T08:06:14.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h1><ul><li>操作系统：CentOS8，由Vmware虚拟机创建，网络使用桥接模式</li><li>Docker版本：19.03.12</li><li>Redis版本：5.0.3</li></ul><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>安装并启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker -y</span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure><p>获取Redis镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="创建集群配置文件模板"><a href="#创建集群配置文件模板" class="headerlink" title="创建集群配置文件模板"></a>创建集群配置文件模板</h1><p>首先创建一个文件夹，用于存放配置文件模板，稍后也用于存放Redis集群数据文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/redis_cluster</span><br><span class="line"><span class="built_in">cd</span> ~/redis_cluster</span><br></pre></td></tr></table></figure><p>新建模板文件<code>vim redis_cluster.tmpl</code>，并写入以下配置（注意此处的Cluster IP，需要根据自己的宿主机IP地址来填写）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Redis Port</span><br><span class="line">port $&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"># Protected mode off</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># Cluster enable</span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># Cluster node conf</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"></span><br><span class="line"># Timeout</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line"># Cluster IP</span><br><span class="line">cluster-announce-ip 192.168.1.103</span><br><span class="line"></span><br><span class="line"># Cluster Port-range: 8090-8095</span><br><span class="line">cluster-announce-port $&#123;PORT&#125;</span><br><span class="line">cluster-announce-bus-port 1$&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"># Enable append only back up mode</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># Back up frequency</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># Disable aof comprass sync</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># Aof rewrite percentage</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># Aof rewrite size</span><br><span class="line">auto-aof-rewrite-min-size 512mb</span><br><span class="line"></span><br><span class="line"># Disable back up</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><h1 id="新建批量生成单个Redis配置的脚本"><a href="#新建批量生成单个Redis配置的脚本" class="headerlink" title="新建批量生成单个Redis配置的脚本"></a>新建批量生成单个Redis配置的脚本</h1><p><code>vim mkconf.sh</code>，随后填入以下内容，此处我的Redis集群端口从8090开始到8095，可根据需要自行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> `seq 8090 8095`; <span class="keyword">do</span> \</span><br><span class="line">    mkdir -p ./<span class="variable">$&#123;port&#125;</span>/conf \</span><br><span class="line">    &amp;&amp; PORT=<span class="variable">$&#123;port&#125;</span> envsubst &lt; ./redis_cluster.tmpl &gt; ./<span class="variable">$&#123;port&#125;</span>/conf/redis.conf \</span><br><span class="line">    &amp;&amp; mkdir -p ./<span class="variable">$&#123;port&#125;</span>/data; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后赋予可执行权限并运行该脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x mkconf.sh</span><br><span class="line">./mkconf.sh</span><br></pre></td></tr></table></figure><h1 id="新建批量生成Docker容器的脚本"><a href="#新建批量生成Docker容器的脚本" class="headerlink" title="新建批量生成Docker容器的脚本"></a>新建批量生成Docker容器的脚本</h1><p><code>vim mkcontainer.sh</code>，随后填入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> `seq 8090 8095`; <span class="keyword">do</span> \</span><br><span class="line">    docker run -d -it \</span><br><span class="line">        -v ~/redis_cluster/<span class="variable">$&#123;port&#125;</span>/conf/redis.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf \</span><br><span class="line">        -v ~/redis_cluster/<span class="variable">$&#123;port&#125;</span>/data:/data \</span><br><span class="line">        --restart always --name redis-<span class="variable">$&#123;port&#125;</span> --net host \</span><br><span class="line">        --sysctl net.core.somaxconn=1024 redis redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="建立Redis集群"><a href="#建立Redis集群" class="headerlink" title="建立Redis集群"></a>建立Redis集群</h1><p>如果宿主机已经安装了<code>redis-cli</code>，就不用进入到容器内部了，可以直接在宿主机上操作</p><p>如果宿主机没有安装<code>redis-cli</code>，则执行以下命令随便进入一个容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-8090 bash</span><br></pre></td></tr></table></figure><p>执行以下命令创建集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.1.103:8090 192.168.1.103:8091 192.168.1.103:8092 192.168.1.103:8093 192.168.1.103:8094 192.168.1.103:8095 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p><img src="images/docker/createcluster.png" alt="创建集群"></p><p>出现以上图中的询问，输入yes回车即可，自此Redis集群就创建成功了</p><h1 id="验证集群可用性"><a href="#验证集群可用性" class="headerlink" title="验证集群可用性"></a>验证集群可用性</h1><p>登录其中的一个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.1.18 -p 8090</span><br></pre></td></tr></table></figure><p>查看集群节点信息，同时也可以试着写入数据，能查看到节点信息，能写入、读取数据，表示集群搭建成功</p><p><img src="images/docker/clusternodes.png" alt="集群节点信息"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本机环境&quot;&gt;&lt;a href=&quot;#本机环境&quot; class=&quot;headerlink&quot; title=&quot;本机环境&quot;&gt;&lt;/a&gt;本机环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统：CentOS8，由Vmware虚拟机创建，网络使用桥接模式&lt;/li&gt;
&lt;li&gt;Docker版本：19.03.12&lt;/li&gt;
&lt;li&gt;Redis版本：5.0.3&lt;/li&gt;
&lt;/ul&gt;&lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;p&gt;安装并启动Docker&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install docker -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo service docker start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;获取Redis镜像&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull redis&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="服务器配置" scheme="http://fisher.lazybone.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker" scheme="http://fisher.lazybone.xyz/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Mumble搭建语音服务器</title>
    <link href="http://fisher.lazybone.xyz/%E4%BD%BF%E7%94%A8mumble%E6%90%AD%E5%BB%BA%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>http://fisher.lazybone.xyz/使用mumble搭建语音服务器.html</id>
    <published>2020-03-19T03:14:14.000Z</published>
    <updated>2020-03-19T09:17:35.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前与朋友一起在CSGO开黑时一直用的是微信语音，没有按键发言用的很不顺手。YY语音的广告太多不忍直视，Discord又被墙了。正好自己有个阿里云的服务器，就想着自己搭建一个语音服务器，也方便上网课的时候建立讨论组。于是乎上网查找了一番，找到了一个叫Mumble的语音软件，它的语音客户端全平台支持，官方的搭建文档介绍详细，简直就是开黑神器。话不多说，接下来就是我的搭建过程</p><a id="more"></a><h1 id="下载Mumble服务器安装包"><a href="#下载Mumble服务器安装包" class="headerlink" title="下载Mumble服务器安装包"></a>下载Mumble服务器安装包</h1><p>Mumble官方下载页面在<a href="https://www.mumble.info/downloads/" target="_blank" rel="noopener">这里</a>，选择下载<code>Static Linux Server</code>，然后从浏览器的下载管理中把下载链接复制出来，在服务器上使用<code>wget DOWNLOAD_ADDERSS</code>下载（DOWNLOAD_ADDRESS为刚刚复制的下载链接）</p><p>如果官方链接太慢的话，我的服务器上也提供了Mumble V1.3.0的服务器安装包、Windows安装包、macOS安装包，需要的可以从<a href="http://fisher.lazybone.xyz/downloads/software/">这个</a>页面找到并下载。使用我的服务器提供的下载地址下载Mumble Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://fisher.lazybone.xyz/downloads/software/murmur-static_x86-1.3.0.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="解压安装包、添加用户和用户组"><a href="#解压安装包、添加用户和用户组" class="headerlink" title="解压安装包、添加用户和用户组"></a>解压安装包、添加用户和用户组</h1><p>下载完安装包后，解压并移动到指定目录下。同时从安装包中复制一份配置文件到<code>/etc</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf ./murmur-static_x86-1.3.0.tar.bz2</span><br><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/murmur</span><br><span class="line">sudo cp -r ./murmur-static_x86-1.3.0/* /usr/<span class="built_in">local</span>/murmur/</span><br><span class="line">sudo cp ./murmur-static_x86-1.3.0/murmur.ini /etc/murmur.ini</span><br></pre></td></tr></table></figure><p>创建用户、用户组、数据文件夹和日志文件夹。同时修改创建的文件和文件夹的权限、拥有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd -r murmur</span><br><span class="line">sudo useradd -r -g murmur -m -d /var/lib/murmur -s /sbin/nologin murmur</span><br><span class="line">sudo mkdir /var/<span class="built_in">log</span>/murmur</span><br><span class="line">sudo chown murmur:murmur /var/<span class="built_in">log</span>/murmur</span><br><span class="line">sudo chmod 0770 /var/<span class="built_in">log</span>/murmur</span><br></pre></td></tr></table></figure><h1 id="配置服务器参数"><a href="#配置服务器参数" class="headerlink" title="配置服务器参数"></a>配置服务器参数</h1><p>使用vim编辑<code>murmur.ini</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/murmur.ini</span><br></pre></td></tr></table></figure><p>指定以下3个参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database=/var/lib/murmur/murmur.sqlite</span><br><span class="line">logfile=/var/<span class="built_in">log</span>/murmur/murmur.log</span><br><span class="line">pidfile=/var/run/murmur/murmur.pid</span><br></pre></td></tr></table></figure><p>以下参数可根据自己需要修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 欢迎进入服务器信息，可以修改成自己喜欢的</span></span><br><span class="line">welcometext=<span class="string">"Welcome to Fisher's mumble server!"</span></span><br><span class="line"><span class="comment"># 语音服务器端口，待会对应防火墙端口需要打开</span></span><br><span class="line">port=64738</span><br><span class="line"><span class="comment"># 服务器密码，进入服务器时会询问输入</span></span><br><span class="line">serverpassword=12345678</span><br><span class="line"><span class="comment"># 最大语音带宽，我改成了128kbit/s，可根据自己需要修改</span></span><br><span class="line">bandwidth=128000</span><br><span class="line"><span class="comment"># 最多允许多少名用户进入服务器</span></span><br><span class="line">users=10</span><br></pre></td></tr></table></figure><h1 id="添加系统服务模块"><a href="#添加系统服务模块" class="headerlink" title="添加系统服务模块"></a>添加系统服务模块</h1><p>添加系统服务单元，以允许Mumble在后台运行</p><p>使用<code>root</code>权限创建<code>murmur.service</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/murmur.serivce</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur.service</code>中，然后保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Mumble Server (Murmur)</span><br><span class="line">Requires=network-online.target</span><br><span class="line">After=network-online.target mariadb.service time-sync.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=murmur</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/murmur/murmur.x86 -ini /etc/murmur.ini</span><br><span class="line">PIDFile=/var/run/murmur/murmur.pid</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>由于现在的操作系统会在重启时放弃<code>var/run</code>中的更改，为了重新创建Mumble的PID文件夹，我们需要创建<code>murmur.conf</code>文件</p><p>使用<code>root</code>权限创建<code>murmur.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/tmpfiles.d/murmur.conf</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur.conf</code>中，然后保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d /var/run/murmur 775 murmur murmur</span><br></pre></td></tr></table></figure><h1 id="配置日志文件"><a href="#配置日志文件" class="headerlink" title="配置日志文件"></a>配置日志文件</h1><p>使用<code>root</code>权限创建<code>murmur</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/logrotate.d/murmur</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/murmur/*<span class="built_in">log</span> &#123;</span><br><span class="line">    su murmur murmur</span><br><span class="line">    dateext</span><br><span class="line">    rotate 4</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    sharedscripts</span><br><span class="line">    delaycompress</span><br><span class="line">    postrotate</span><br><span class="line">        /bin/systemctl reload murmur.service &gt; /dev/null 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h1><p>不同的云服务器商设置防火墙的方式不同。对于阿里云的轻量服务器，服务器的管理界面中点击防火墙，添加TCP和UDP的64738端口（端口根据上面配置文件改变而改变）</p><p><img src="images/mumble/firewall.png" alt="防火墙配置"></p><h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><p>刷新系统服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemd-tmpfiles --create /etc/tmpfiles.d/murmur.conf</span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>允许开机自动启动Mumble服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> murmur.service</span><br></pre></td></tr></table></figure><p>正式启动Mumble服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start murmur.service</span><br></pre></td></tr></table></figure><p>当看到<code>active(running)</code>时，表示Mumble服务器启动成功</p><p><img src="images/mumble/start.png" alt="启动服务器"></p><h1 id="连接服务器，完成！"><a href="#连接服务器，完成！" class="headerlink" title="连接服务器，完成！"></a>连接服务器，完成！</h1><p>打开自己电脑上的Mumble，点击左上角小地球，点击添加，填入自己的服务器地址，用户名自己起一个喜欢的（不能是<code>SpuerUser</code>，这是Mumble管理员账号）。点击OK后连接，输入密码，大功告成！</p><p><img src="images/mumble/add.png" alt="添加服务器"></p><h1 id="进阶操作：添加、修改频道"><a href="#进阶操作：添加、修改频道" class="headerlink" title="进阶操作：添加、修改频道"></a>进阶操作：添加、修改频道</h1><p>如果使用的小伙伴太多了，需要分开不同的频道使用的时候，就需要使用<code>SuperUser</code>用户连接服务器并对<code>root</code>频道进行修改了。要使用<code>SuperUser</code>很简单，可以使用首次启动时系统随机分配的密码，也可以自己设置一个密码</p><h3 id="对于系统随机分配的密码，使用以下命令："><a href="#对于系统随机分配的密码，使用以下命令：" class="headerlink" title="对于系统随机分配的密码，使用以下命令："></a>对于系统随机分配的密码，使用以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/murmur/murmur.log</span><br></pre></td></tr></table></figure><p>查找<code>&lt;W&gt;year-month-day hour:min:sec 1 =&gt; Password for &#39;SuperUser&#39; set to &#39;supersecretpassword&#39;</code>这条日志，密码就是那一串<code>supersecretpassword</code>。由于我的服务器用了好久了，那一串日志被覆盖掉了，这里就没有截图了（逃</p><h3 id="对于自己设置一个密码，使用以下命令即可："><a href="#对于自己设置一个密码，使用以下命令即可：" class="headerlink" title="对于自己设置一个密码，使用以下命令即可："></a>对于自己设置一个密码，使用以下命令即可：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/murmur</span><br><span class="line">./murmur.x86 -ini /etc/murmur.ini -supw PASSWORD</span><br></pre></td></tr></table></figure><p>其中<code>PASSWORD</code>改成自己想要设定的密码。接下来在Mumble软件中添加自己的服务器，用户名使用<code>SuperUser</code>，密码填自己刚刚设置的密码</p><p><img src="images/mumble/super.png" alt="SuperUser"></p><p>连接到服务器后，对着<code>root</code>频道右键，就可以进行频道添加、修改、删除的操作了。最后配置一下自己的音频输入输出，就可以愉快地与朋友开黑了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前与朋友一起在CSGO开黑时一直用的是微信语音，没有按键发言用的很不顺手。YY语音的广告太多不忍直视，Discord又被墙了。正好自己有个阿里云的服务器，就想着自己搭建一个语音服务器，也方便上网课的时候建立讨论组。于是乎上网查找了一番，找到了一个叫Mumble的语音软件，它的语音客户端全平台支持，官方的搭建文档介绍详细，简直就是开黑神器。话不多说，接下来就是我的搭建过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://fisher.lazybone.xyz/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="服务器配置" scheme="http://fisher.lazybone.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题三</title>
    <link href="http://fisher.lazybone.xyz/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%B8%89.html"/>
    <id>http://fisher.lazybone.xyz/操作系统习题三.html</id>
    <published>2020-01-05T11:45:23.000Z</published>
    <updated>2020-01-05T11:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一、试说明I/O系统的基本功能。</p><ul><li>隐藏物理设备的细节</li><li>与设备的无关性</li><li>提高处理机和I/O设备的利用率</li><li>对I/O设备进行控制</li><li>确保对设备的正确共享</li><li>错误处理</li></ul><p>二、简要说明I/O软件的四个层次的基本功能。</p><ul><li>用户层I/O软件：实现与用户交互的接口，用户可直接调用提供的库函数对I/O设备进行操作</li><li>设备独立性软件：实现用户程序与设备驱动器的统一接口</li><li>设备驱动程序：具体实现系统对设备发出的操作指令，驱动I/O设备工作</li><li>中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序</li></ul><a id="more"></a><p>三、与设备无关性的基本含义是什么？为什么要设置该层？</p><p>其基本含义是：I/O软件独立于具体使用的物理设备，隐藏了物理设备的细节。设置该层提高了I/O系统的可适应性和可扩展性，用户使用设备时可以使用逻辑设备，而不必指定物理设备，在增加新设备或替换老设备时，不需要对I/O软件进行修改，方便了系统的更新和扩展</p><p>四、为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？</p><ul><li>接收和识别命令：设备控制器能够接受并识别处理机发来的各种命令</li><li>数据交换：控制器与CPU之间、控制器之间、控制器与物理设备之间的数据交换</li><li>标识和报告设备的状态：记录设备的状态，提供给CPU</li><li>地址识别：识别所控制的每个设备的地址</li><li>数据缓冲区：暂存由高速主机、设备传来的数据</li><li>差错控制：保证数据输入输出的正确性</li></ul><p>五、什么是内存映像I/O？它是如何实现的？</p><p>内存映像I/O在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用统一的地址。地址的一部分范围认为是内存地址，另一部分则认为是某个控制器的寄存器地址</p><p>六、为什么说中断是OS赖以生存的基础？</p><p>因为进程之间的切换是通过中断来完成的，如果没有了中断，就不能实现多道程序，OS也就不复存在了</p><p>七、对多中断源的两种处理方式分别用于何种场合？</p><p>屏蔽中断：对实时性要求较低的中断请求，并且被屏蔽的中断重要性不高，不影响系统的运行</p><p>嵌套中断：对实时性要求较高的中断请求，并且中断处理能够以较快的速度完成</p><p>八、简要说明中断处理程序对中断进行处理的几个步骤。</p><p>测定是否有未响应的中断信号，保护被中断进程的CPU环境，转入到相应的设备处理程序，恢复CPU现场并退出中断</p><p>九、有哪几种I/O控制方式？各适用于何种场合？</p><p>使用轮询的可编程I/O方式：适用于结构简单，只需要少量硬件的电路中</p><p>使用中断的可编程I/O方式：适用于现在操作系统中，对I/O设备效率要求高的计算机中</p><p>十、试说明DMA的工作流程。</p><p>首先设置MAR和DC的初值，然后启动DMA传送命令，接着挪用储存器周期传送数据，每次传送中储存器地址+1、DC-1，如果DC=0，表示本次传送完成，DMA可以发送中断请求，如果DC不等于0，则表示数据未传送完成</p><p>十一、为何要引入与设备的无关性？如何实现设备的独立性？</p><p>在没有设备无关性的情况下，应用程序在使用I/O设备的时候需要指定设备的物理名称，如果该设备已经分配给其他进程并且是独占设备，那么会引起应用程序的阻塞，并且更换设备时，应用程序也需要更新物理设备名称，给用户带来了许多麻烦。现代操作系统通过引入逻辑设备，将逻辑设备映射到物理设备上实现了设备的独立性，并且实现了I/O重定向</p><p>十二、在考虑到设备的独立性时，应如何分配独占设备？</p><p>OS接到对设备的请求后，先对进程所请求的独占设备进行检查，看该设备是否空闲。若空闲才把设备分配给请求进程，否则进程阻塞，放入到该设备的请求队列中等待。等到其他进程释放该设备时，再将队列中的第一个进程唤醒，该进程的到设备后继续运行</p><p>十三、何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？</p><p>设备虚拟可以将一个物理设备模拟成多个逻辑上的不同的设备，从而允许多个用户共享使用一个设备。实现设备虚拟需要系统配置一张逻辑设备表，以记录物理设备到虚拟设备的映射，还需要系统对虚拟设备资源分配与回收的支持</p><p>十四、在实现后台打印时，SPOOLIng系统应为请求I/O的进程提供哪些服务？</p><p>输入井和输出井：用于收容I/O设备输入和输出的数据，将数据暂存在磁盘上</p><p>输入缓冲区和输出缓冲区：缓冲区位于内存中，用于缓和CPU和磁盘之间速度不匹配的矛盾</p><p>输入进程和输出进程：用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区</p><p>井管理程序：控制作业与磁盘井之间信息的交换</p><p>十五、假脱机系统向用户提供共享打印机的基本思想是什么？</p><p>将打印的队列和数据存放在磁盘缓冲区中，用户看见的是打印已经成功完成，而打印机从队列中取出要打印的数据进行打印</p><p>十六、引入缓冲的主要原因是什么？</p><p>缓和CPU与I/O设备之间速度不匹配的矛盾，减少对CPU的中断频率，放宽对CPU中断相应时间的限制，解决数据粒度不匹配的问题，提高CPU与I/O设备之间的并行性</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>一、何谓数据项、记录和文件？</p><p>数据项：最低级的数据组织形式 ，可以分为基本数据项和组合数据项。基本数据项用于描述一个对象的某种属性的字符集。组合数据项是由若干个基本数据项组成的，简称组项</p><p>记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性</p><p>文件：指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种</p><p>二、文件系统的模型可分为三层，试说明其每一层所包含的基本内容。</p><p>对象及其属性：管理了以下的对象：文件，文件系统中各种类型的文件都作为文件管理的直接对象。目录，是为了方便用户对文件的存取和检索，也提高了对文件的存取速度。磁盘储存空间，对存储空间的有效管理不仅能提高外存的利用率，还能提高对文件的存取速度</p><p>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分，文件系统的功能大多是在这一层实现的，其中包括有：对文件存储空间的管理；对文件目录的管理；用于将文件的逻辑地址转换为物理地址的机制；对文件读写的管理；对文件的共享与保护等功能</p><p>文件系统接口：提供了一组对文件和记录操作的方法和手段，通常是命令接口和程序接口</p><p>三、与文件系统有关的软件可分为哪几个层次？</p><p>I/O控制层，基本文件系统层，基本I/O管理程序，逻辑文件系统</p><p>四、试说明用户可以对文件施加的主要操作有哪些。</p><p>创建文件，删除文件，读文件，写文件，设置文件的读写位置，打开文件，关闭文件，改变文件名，改变文件的拥有者，改变对文件的访问权，查询文件的状态</p><p>五、何谓文件的逻辑结构？何谓文件的物理结构？</p><p>文件的逻辑结构：即用户所看到的文件，它是由一系列的逻辑记录组成的，是能够被存取的基本单位，是用户可以直接处理的数据及其结构</p><p>文件的物理结构：又称为文件储存结构，指系统将文件储存在外存上所形成的一种储存组织形式，是用户不能看见的</p><p>六、按文件的组织方式可将文件分为哪几种类型？</p><p>普通文件，包括源程序文件、数据文件以及操作系统自身代码文件等</p><p>目录文件，由文件目录组成的文件，通过目录文件可以对齐下属文件的信息进行检索</p><p>特殊文件，指系统中的各类I/O设备，对这些文件的操作将由设备驱动程序来完成</p><p>七、如何提高对变长记录顺序文件的检索速度？</p><p>按照关键字建立索引，为主文件中的每个记录在索引表中分别设置一个表项，记录指向储存地址的指针，把对变长记录的检索转为对定长记录索引文件的随机检索，从而加快对记录检索的速度，实现直接存取</p><p>八、通过哪两种方式来对固定长记录实现随机访问？</p><p>直接文件：利用给定的记录简直，对线性表或链表进行检索，找到指定记录的物理地址</p><p>哈希文件：利用散列函数将关键字转换为某一目录表相应表项的指针，该表项的内容指向对应记录的物理地址</p><p>九、可以采取什么方法来实现对变长记录文件进行随机检索？</p><p>可采取索引顺序文件和哈希文件的方法实现</p><p>十、试说明索引顺序文件的几个主要特征。</p><p>记录是按关键字的顺序组织起来的。引入了文件索引表，通过对该表可以实现对索引顺序文件的随机访问。增加了溢出文件，用来记录新增加、删除、修改的记录</p><p>十一、试说明对索引文件和索引顺序文件的检索方法。</p><p>利用提供的关键字，在索引表中利用多种不同的搜索方法查找对应的表项，再利用表项给出的指向记录的指针值去访问所需要的记录</p><p>十二、试从检索速度和储存费用两方面来比较两级索引文件和索引顺序文件。</p><p>对于一个非常大的文件来说，索引顺序文件的检索速度还是比较慢，两级索引文件能够在大文件的检索中进一步提高检索速度。储存费用来说，两级索引文件的储存费用要比索引顺序文件要低</p><p>十三、对目录管理的主要要求是什么？</p><p>实现“按名存取”，用户只须项系统提供所需访问文件的名字，便能快速准确地找到指定文件在外存上的储存位置</p><p>提高对目录的检索速度，从而提高对文件的存取速度</p><p>实现文件共享，允许多个用户共享一个文件，节省大量的储存空间，方便用户和提高文件的利用率</p><p>允许文件重名，便于用户按照自己的习惯给文件命名和使用文件</p><p>十四、何谓路径名和当前目录？</p><p>路径名：在树形结构目录中，从根目录到任何数据文件的唯一通路</p><p>当前目录，某个进程运行时所在的路径地址</p><p>十五、Hash检索法有何优点？又有何局限性？</p><p>Hash检索法能够快速地检索到所需要的文件、记录的地址。但Hash检索法不能检索使用了通配符查找的文件和记录，既提供给Hash查找的文件、记录必须是明确的</p><p>十六、在Hash检索法中，如何解决“冲突”问题？</p><p>发生了“冲突”，表示某个路径通过Hash计算后与当前存在的表项重复了，则需要在Hash计算后再加上一个常数，直到形成新的，无冲突的索引值为止</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章&quot;&gt;&lt;a href=&quot;#第六章&quot; class=&quot;headerlink&quot; title=&quot;第六章&quot;&gt;&lt;/a&gt;第六章&lt;/h1&gt;&lt;p&gt;一、试说明I/O系统的基本功能。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;隐藏物理设备的细节&lt;/li&gt;
&lt;li&gt;与设备的无关性&lt;/li&gt;
&lt;li&gt;提高处理机和I/O设备的利用率&lt;/li&gt;
&lt;li&gt;对I/O设备进行控制&lt;/li&gt;
&lt;li&gt;确保对设备的正确共享&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二、简要说明I/O软件的四个层次的基本功能。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;用户层I/O软件：实现与用户交互的接口，用户可直接调用提供的库函数对I/O设备进行操作&lt;/li&gt;
&lt;li&gt;设备独立性软件：实现用户程序与设备驱动器的统一接口&lt;/li&gt;
&lt;li&gt;设备驱动程序：具体实现系统对设备发出的操作指令，驱动I/O设备工作&lt;/li&gt;
&lt;li&gt;中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://fisher.lazybone.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验六：连续动态内存管理</title>
    <link href="http://fisher.lazybone.xyz/%E8%BF%9E%E7%BB%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>http://fisher.lazybone.xyz/连续动态内存管理.html</id>
    <published>2019-12-21T08:02:37.000Z</published>
    <updated>2019-12-21T09:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统系列博客的所有实验源自于课程<code>&quot;操作系统原理与实践检验&quot;</code>，代码是参考老师给的<code>&quot;软件工程专业操作系统实验指导书&quot;</code>文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法</p><a id="more"></a><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>理解内存管理相关理论</li><li>掌握连续内存管理理论</li><li>掌握动态连续内存管理理论</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>本实验主要针对操作系统中内存管理相关理论进行实验，要求实验者编写一个程序，该程序管理一块虚拟内存，实现内存分配和回收功能</p><ul><li>模拟管理64M的内存块</li><li>设计内存分配函数</li><li>设计内存回收函数</li><li>实现动态分配和回收操作</li><li>可动态显示每个内存块信息</li></ul><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>数据结构，本次实验使用了三种数据结构，构成了2张表，1个双向链表，其定义如下：</p><ul><li>空闲分区表：起始地址（startAddr）、大小（size）、使用情况（status）</li><li>已使用内存表：起始地址（startAddr）、大小（size）</li><li>空闲分区双向链表：空闲分区表项（table）、上一节点（previous）、下一节点（next）</li></ul><p>内存分配算法：本次实验中使用了首次适应算法，该算法总是从内存的低地址出发，寻找第一个满足申请空间要求的空闲分区，然后将其分配给申请的进程。该算法思路简单，实现也比较简单，但是由于申请释放总是从低地址开始，因此低地址的内存碎片化会越来越严重，而高地址的内存使用次数却过少，在商业操作系统中，一般会将几种分配算法综合在一起使用。该算法的实现在下面代码汇总中的<code>allocate</code>函数</p><p>内存回收算法：在回收内存空间时，需要考虑以下四种情况，以达到合并连续空闲内存空间的目的</p><ul><li>回收区与插入点的前一个空闲分区相邻：回收区与前一个空闲分区合并，此时只需要修改前一个空闲分区的大小（size）即可</li><li>回收区与插入点的后一个空闲分区相邻：回收区与后一个空闲分区合并，此时需要修改后一个空闲分区的起始地址（startAddr）和大小（size）</li><li>回收区与插入点的前后空闲分区都相邻：此时需要把前后空闲分区和回收区一起合并，合并到前一空闲分区中，需要修改前一空闲分区的大小（size），同时删除后一空闲分区表项</li><li>回收区不与任何空闲分区相邻：为回收区新建一个空闲分区表项，插入到空闲分区表的对应位置中</li></ul><h1 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// 内存容量，单位为kb</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RAM_SIZE 65536</span></span><br><span class="line"><span class="comment">// 不可再分割的内存大小</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ALLOC_MIN_SIZE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲分区表-数据结构(Free Partition table)</span></span><br><span class="line"><span class="comment"> * 起始地址(内存地址-kb) | 大小(kb) | 使用情况(0:未使用 1:使用中)</span></span><br><span class="line"><span class="comment"> * startAddr | size | status</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> startAddr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲分区链-数据结构(Free Partition chain)</span></span><br><span class="line"><span class="comment"> * table: 指向对应的空闲分区表地址</span></span><br><span class="line"><span class="comment"> * previous: 双向链表的上一项</span></span><br><span class="line"><span class="comment"> * next: 双向链表的下一项</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpChain</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    fpTable *table;</span><br><span class="line">    fpChain *previous;</span><br><span class="line">    fpChain *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已使用的内存</span></span><br><span class="line"><span class="comment"> * 起始地址(内存地址-kb) | 大小(kb)</span></span><br><span class="line"><span class="comment"> * startAddr | size</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">used</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> startAddr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲分区表</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fpTable *&gt; ramTable;</span><br><span class="line"><span class="comment">// 已使用分区表</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;used *&gt; usedTable;</span><br><span class="line"><span class="comment">// 空闲分区链</span></span><br><span class="line">fpChain *ramChain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化空闲分区表</span></span><br><span class="line">    fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">    tableNode-&gt;startAddr = <span class="number">0</span>;</span><br><span class="line">    tableNode-&gt;size = RAM_SIZE;</span><br><span class="line">    tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">    ramTable.push_back(tableNode);</span><br><span class="line">    <span class="comment">// 初始化空闲分区链</span></span><br><span class="line">    fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">    chainNode-&gt;table = tableNode;</span><br><span class="line">    chainNode-&gt;previous = chainNode;</span><br><span class="line">    chainNode-&gt;next = chainNode;</span><br><span class="line">    ramChain = chainNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看内存使用情况</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n=====空闲分区表================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"起始地址 | 大小(kb) | 使用情况\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%8d | %8d | %5d\n"</span>, ramTable[i]-&gt;startAddr, ramTable[i]-&gt;size, ramTable[i]-&gt;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===============================\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=====已使用的分区表==========\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程号 | 起始地址 | 大小(kb)\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; usedTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d | %8d | %8d\n"</span>, i, usedTable[i]-&gt;startAddr, usedTable[i]-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=============================\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请内存分配</span></span><br><span class="line"><span class="comment"> * s: 申请的内存大小</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || s &gt; RAM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 参数错误！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有空闲内存了</span></span><br><span class="line">    <span class="keyword">if</span> (ramTable.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 内存已分配完毕，申请失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找满足要求的空闲内存块</span></span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    fpChain *chainPointer = ramChain;</span><br><span class="line">    fpTable *tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tablePointer-&gt;size - s) &gt;= ALLOC_MIN_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chainPointer = chainPointer-&gt;next;</span><br><span class="line">            tablePointer = chainPointer-&gt;table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="comment">// 内存空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (!find)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 内存空间不足，申请失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配空间，添加到已使用分区表，修改空闲分区表、空闲分区链</span></span><br><span class="line">    used *usedPointer = <span class="keyword">new</span> used;</span><br><span class="line">    usedPointer-&gt;startAddr = tablePointer-&gt;startAddr;</span><br><span class="line">    usedPointer-&gt;size = s;</span><br><span class="line">    usedTable.push_back(usedPointer);</span><br><span class="line">    <span class="comment">// 寻找要修改的表项位置</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ramTable[i]-&gt;startAddr == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空间刚好分配完，删除分区表和分区链中对应表项</span></span><br><span class="line">    <span class="keyword">if</span> (tablePointer-&gt;size == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"INFO: 该块内存分配完毕，删除空闲分区表和分区链中对应项\n"</span>);</span><br><span class="line">        <span class="comment">// 删除表项</span></span><br><span class="line">        ramTable.erase(ramTable.begin() + pos);</span><br><span class="line">        <span class="comment">// 摘链</span></span><br><span class="line">        <span class="keyword">if</span> (ramTable.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 已无空闲分区，将空闲链表置为NULL\n"</span>);</span><br><span class="line">            ramChain = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果刚好是双向链表的头部，则使用下一节点作为链表头部</span></span><br><span class="line">            <span class="keyword">if</span> (chainPointer == ramChain)</span><br><span class="line">            &#123;</span><br><span class="line">                ramChain = chainPointer-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            chainPointer-&gt;next-&gt;previous = chainPointer-&gt;previous;</span><br><span class="line">            chainPointer-&gt;previous-&gt;next = chainPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> chainPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 分配之后仍有剩余空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"INFO: 该块内存仍有剩余空间，修改空闲分区表大小\n"</span>);</span><br><span class="line">        tablePointer-&gt;size -= s;</span><br><span class="line">        tablePointer-&gt;startAddr += s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放内存</span></span><br><span class="line"><span class="comment"> * index: 要释放内存的进程号</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= usedTable.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 参数错误！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取要释放的内存块</span></span><br><span class="line">    used *usedPointer = usedTable[index];</span><br><span class="line">    <span class="comment">// 空链情况，直接新建空闲分区并插入</span></span><br><span class="line">    <span class="keyword">if</span> (ramChain == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">        tableNode-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">        tableNode-&gt;size = usedPointer-&gt;size;</span><br><span class="line">        tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">        ramTable.push_back(tableNode);</span><br><span class="line">        fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">        chainNode-&gt;table = tableNode;</span><br><span class="line">        chainNode-&gt;previous = chainNode;</span><br><span class="line">        chainNode-&gt;next = chainNode;</span><br><span class="line">        ramChain = chainNode;</span><br><span class="line">        usedTable.erase(usedTable.begin() + index);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非空链情况，寻求与前后空闲分区合并</span></span><br><span class="line">    fpChain *chainPointer = ramChain;</span><br><span class="line">    fpTable *tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 与前后空闲分区都相邻，合并前后空闲分区</span></span><br><span class="line">        <span class="keyword">if</span> ((tablePointer-&gt;startAddr + tablePointer-&gt;size == usedPointer-&gt;startAddr) &amp;&amp;</span><br><span class="line">            (usedPointer-&gt;startAddr + usedPointer-&gt;size == chainPointer-&gt;next-&gt;table-&gt;startAddr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与前后空闲分区都相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;size = tablePointer-&gt;size + usedPointer-&gt;size + chainPointer-&gt;next-&gt;table-&gt;size;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (chainPointer-&gt;next-&gt;table-&gt;startAddr == ramTable[i]-&gt;startAddr)</span><br><span class="line">                &#123;</span><br><span class="line">                    ramTable.erase(ramTable.begin() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chainPointer-&gt;next-&gt;next-&gt;previous = chainPointer-&gt;next-&gt;previous;</span><br><span class="line">            chainPointer-&gt;next = chainPointer-&gt;next-&gt;next;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与前面空闲分区相邻，前面空闲分区空间增大</span></span><br><span class="line">        <span class="keyword">if</span> (tablePointer-&gt;startAddr + tablePointer-&gt;size == usedPointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与前面空闲分区相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;size += usedPointer-&gt;size;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与后面空闲分区相邻，后面空闲分区内存起址前移，扩大分区空间</span></span><br><span class="line">        <span class="keyword">if</span> (usedPointer-&gt;startAddr + usedPointer-&gt;size == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与后面空闲分区相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">            tablePointer-&gt;size += usedPointer-&gt;size;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chainPointer = chainPointer-&gt;next;</span><br><span class="line">        tablePointer = chainPointer-&gt;table;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="comment">// 非空链情况，新建独立空闲分区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INFO: 非空链情况，新建独立空闲分区\n"</span>);</span><br><span class="line">    <span class="comment">// 寻找插入点</span></span><br><span class="line">    chainPointer = ramChain;</span><br><span class="line">    tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tablePointer-&gt;startAddr &gt; usedPointer-&gt;startAddr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chainPointer = chainPointer-&gt;next;</span><br><span class="line">            tablePointer = chainPointer-&gt;table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INFO: 插入点位于 %d\n"</span>, tablePointer-&gt;startAddr);</span><br><span class="line">    <span class="comment">// 新建分区并插入</span></span><br><span class="line">    fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">    tableNode-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">    tableNode-&gt;size = usedPointer-&gt;size;</span><br><span class="line">    tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ramTable[i]-&gt;startAddr == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 找到插入点 %d\n"</span>, i);</span><br><span class="line">            ramTable.insert(ramTable.begin() + i, tableNode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入到双向链表中</span></span><br><span class="line">    fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">    chainNode-&gt;table = tableNode;</span><br><span class="line">    chainNode-&gt;next = chainPointer;</span><br><span class="line">    chainNode-&gt;previous = chainPointer-&gt;previous;</span><br><span class="line">    chainPointer-&gt;previous-&gt;next = chainNode;</span><br><span class="line">    chainPointer-&gt;previous = chainNode;</span><br><span class="line">    <span class="comment">// 修改链表头部</span></span><br><span class="line">    <span class="keyword">if</span> (chainPointer == ramChain)</span><br><span class="line">    &#123;</span><br><span class="line">        ramChain = chainNode;</span><br><span class="line">    &#125;</span><br><span class="line">    usedTable.erase(usedTable.begin() + index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdstr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> input;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmdstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"exit"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"help"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"申请内存: allocate\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"释放内存: release\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查看当前空余内存: ps\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"获取帮助: help\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出: exit\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"ps"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ps();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"allocate"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请的内存大小(kb): "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">            allocate(input);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"release"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要释放内存的进程号: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">            release(input);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: 未知的命令！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ps();</span><br><span class="line">    terminal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h1><ol><li><p>编译运行程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ memory.cpp -o memory</span><br><span class="line">./memory</span><br></pre></td></tr></table></figure></li><li><p>使用<code>help</code>命令查看帮助信息</p><p><img src="images/os/memoryhelp.png" alt="help命令"></p></li><li><p>使用<code>ps</code>命令查看当前内存使用信息</p><p><img src="images/os/memoryps.png" alt="ps命令"></p></li><li><p>使用<code>allocate</code>命令申请内存资源，指导书上要求至少进行10次内存申请</p><p><img src="images/os/memoryallocate.png" alt="allocate命令"></p></li><li><p>使用<code>release</code>命令释放内存资源，可以看到在释放资源时，系统会判断并合并连续可用的内存空间</p><p><img src="images/os/memoryrelease.png" alt="release命令"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验中，我们通过使用首次适应算法（First Fit）实现了动态的内存分配回收，实现了该模块之后，编写程序时不需要再考虑申请内存的大小，只需要在运行时动态地申请和释放内存空间即可，这增强了程序的灵活性，再辅助上交换内存之后，我们就可以使用比较小的内存去运行比内存容量大的多的程序。在现代的操作系统中，内存的分配回收使用了段页式管理的方法，在保证了内存的灵活使用同时，尽量减少了内存碎片的产生，提高了系统的吞吐量，同时也提高了程序的灵活性、可移植性和兼容性</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li><p>连续内存分配和离散内存分配相比有何优缺点？</p><p>连续内存分配提高了内存的利用率，同时便于程序在运行过程中动态地申请和释放内存，在程序的眼中，内存空间就像是无限大，编写程序时不必考虑内存容量的限制。连续内存分配也便于程序之间的信息共享，适用于多道程序系统</p></li><li><p>动态连续内存分配的难点是什么？</p><p>内存的动态分配策略和回收策略，如果系统没有选择一个好的分配回收算法，随着系统运行时间的加长，内存的碎片化会越来越严重，系统花费在维护内存分配表上的时间越来越多，导致系统吞吐量降低，甚至出现死机等问题</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;操作系统系列博客的所有实验源自于课程&lt;code&gt;&amp;quot;操作系统原理与实践检验&amp;quot;&lt;/code&gt;，代码是参考老师给的&lt;code&gt;&amp;quot;软件工程专业操作系统实验指导书&amp;quot;&lt;/code&gt;文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题二</title>
    <link href="http://fisher.lazybone.xyz/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%BA%8C.html"/>
    <id>http://fisher.lazybone.xyz/操作系统习题二.html</id>
    <published>2019-12-18T11:23:49.000Z</published>
    <updated>2019-12-18T11:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>一、为什么要配置层次式储存器？</p><p>为了使存储器跟上处理机的运行速度，提高处理机的使用率，同时尽量降低存储器的成本，采用多层结构的存储器系统是性价比最高的方案</p><p>二、可采用哪几种方式将程序装入内存？它们分别适合用于何种场合？</p><p>绝对装入方式：将目标模块装入到内存中事先指定的位置，计算机系统很小时，完全有可能知道程序将驻留在内存的什么位置。因此可采用绝对装入的方式将程序装入内存指定位置中</p><a id="more"></a><p>可重定位装入方式：可以根据内存使用的具体情况将装入模块装入到内存的适当位置，但不允许程序运行时在内存中移动位置，这种方式适用于在多道程序环境下</p><p>动态运行时的装入方式：程序在运行过程中，内存的位置因为页面的置换而经常发生改变，这种方式适用于拥有段页式储存管理的操作系统中</p><p>三、何谓静态链接？静态链接时需要解决两个什么问题？</p><p>在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。静态链接时需要解决对相对地址进行修改和变换外部调用符号这两个问题</p><p>对相对地址进行修改：编译产生的模块中，内存地址都是从0开始，在装入内存时需要进行内存偏移操作，即加上相对地址L</p><p>变换外部调用符号：将每个模块中所用的外部调用符号变换为相对地址</p><p>四、何谓装入时动态链接？装入时动态链接方式有何优点？</p><p>用户将源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的方式。该方式便于修改和更新库函数，便于实现对库函数模块的共享</p><p>五、何谓运行时动态链接？运行时动态链接方式有何优点？</p><p>对某些模块和链接推迟到程序执行时才进行，这种方式不仅能加快程序的装入过程，还能节省大量的内存空间</p><p>六、在动态分区分配方式中，应如何将各空闲分区连接成空闲分区链？</p><p>使用空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况</p><p>使用空闲分区链：对每一个分区设置一个前向指针和后向指针，用于链接前一个空闲分区和后一个空闲分区</p><p>七、为什么要引入动态重定位？如何实现？</p><p>为了充分利用内存空间中的碎片空间，并且降低计算机整理内存的频次，由此引入了动态重定位。动态重定位使用了一个重定位寄存器，用于记录偏移的地址量，在每次取址时用程序的逻辑地址加上重定位寄存器中的地址，得到内存中的物理地址，在进行内存碎片整理之后，只需要修改重定位寄存器中的地址即可</p><p>八、什么是基于顺序搜索的动态分区分配算法？它可以分为哪几种？</p><p>在内存空闲链中，依次搜索空闲分区上的空闲分区，寻找一个大小能满足要求的分区，它可以分为以下4种算法：</p><ul><li>首次适应（first     fit, FF）算法：该算法要求空闲分区链以地址递增的次序链接，在分配内存时从链的头部开始寻找，直至找到一个大小能满足要求的空闲分区</li><li>循环首次适应算法（next     fit, NF）：为避免低地址部分留下许多很小的空闲分区，该算法从上次找到的空闲分区开始向后寻找，直至找到一个能满足要求的空闲分区</li><li>最佳适应（best     fit, BF）算法：该算法要求将所有的空闲分区按照容量从小到大的顺序形成空闲分区链。总是把能满足要求的、又是最小的空闲分区分配给作业</li><li>最坏适应（worst     fir, WF）算法：与最佳适应算法相反，总是把最大的空闲区分割一部分存储空间给作业使用</li></ul><p>九、在采用首次适应算法回收内存时，可能出现哪几种情况？应该怎样处理这种情况？</p><p>回收区与插入点的前一个空闲分区相邻接：此时应该将回收区与插入点的前一分区合并</p><p>回收区与插入点的后一个空闲分区相邻接：此时应该将两个分区合并，回收区的首地址作为新空闲区的地址，更新空闲分区链表信息</p><p>回收区同时与插入点的前、后两个空闲分区邻接：此时将三个分区合并，使用前分区的地址作为新空闲区的地址，更新空闲分区链表信息</p><p>回收区与前后空闲分区不邻接：此时应单独为回收区新建一个表项，并插入到空闲分区链表中的适当位置</p><p>十、什么是基于索引搜索的动态分区分配算法？它可分为哪几种？</p><p>利用空闲分区索引快速搜索空闲分区，分配空闲分区的算法，它可以分为以下三种算法：</p><ul><li>快速适应（quick fit）算法：又称为分类搜索法，对于每一类具有相同容量的所有空闲分区，单独设立一张管理索引表。首先根据进程长度，从索引表中找到能够容纳它的最小空闲区链表，再从链表中取下第一块进行分配。该算法的优点是分配速度快，但缺点是内存回收整理时算法十分复杂</li><li>伙伴系统（buddy system）：将所有分区划分为大小均为2的k次幂的空间，将相同大小空间的分区使用双向链表建立索引。在伙伴系统中，空间的分配和回收性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。该算法比快速适应算法好，比顺序搜索算法略差</li><li>哈希算法：利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造哈希表。当空闲分区进行分配时，根据所需空闲分区大小，通过哈希函数计算，获得分区在哈希表中的位置，从而得到相应的空闲分区链表，实现最佳分配策略</li></ul><p>十一、分区储存管理中常用哪些分配策略？比较它们的优缺点。</p><p>常用的分配策略：首次适应算法，循环首次适应算法，最佳适应算法，最坏适应算法</p><ul><li>首次适应算法：保留了高位地址部分较大的储存空间，有利于后来的大型作业分配，但同时低位地址不断被划分，碎片化更加严重</li><li>循环首次适应算法：内存空间分配均匀，减少了系统查找的开销，但缺乏大空间内存区域，导致不能装入大型作业</li><li>最佳适应算法：每次给进程分配的空间区域都最适合该进程，在内存中留下难以利用的空间</li><li>最坏适应算法：剩下的空间都不太小，产生碎片的几率小，对中小型作业的分配有利，但不利于大型作业的分配</li></ul><p>十二、为什么要引入对换？对换可分为哪几种类型？</p><p>一方面由于内存中的某些进程由于某事件尚未发生而被阻塞运行，却占用了大量的内存空间，导致内存空间不足，使系统的吞吐量下降，为了解决这个问题而引入了对换功能。对换可以分为：整体对换，页面对换</p><p>十三、对文件区管理的目标和对对换空间管理的目标有何不同？</p><p>对文件区的管理目标：首先是提高文件储存空间的利用率，然后才是提高对文件的访问速度</p><p>对对换空间的管理目标：提高进程换入和换出的速度，然后才是提高文件储存空间的利用率</p><p>十四、为实现对换，系统应具备哪几方面的功能？</p><p>系统应具备的功能：进程的换出，进程的换入，对换空间管理</p><p>十五、在以进程为单位进行对换时，每次是否将整个进程换出？为什么？</p><p>不一定将整个进程换出，因为进程中包含了进程信息，程序代码和数据。其中的数据可能由几个进程共享使用，因此不一定将整个进程换出</p><p>十六、基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？</p><p>可分为：分页储存管理，分段储存管理，段页式储存管理</p><p>十七、什么是页面？什么是物理块？页面的大小应如何确定？</p><p>页面是进程逻辑地址空间的划分，一个进程可以划分为若干个页面</p><p>物理块是内存物理地址空间的划分，并对每个块加以编号</p><p>页面太小会导致页表过长，占用内存且降低效率，页面太长会导致内存空间的浪费，降低换进换出的效率。因此页面一般划分为1KB～8KB</p><p>十八、什么是页表？页表的作用是什么？</p><p>页表中记录了每个页面所对应的物理块，实现了从页号到物理块号的地址映射</p><p>十九、为实现分页存储管理，需要哪些硬件支持？</p><p>动态重定位技术，虚拟储存技术，多道程序设计技术</p><p>二十、在分页系统中是如何实现地址变换的？</p><p>首先通过页表去寻找该进程的内存基址，然后检查该地址是否合法，最后通过内存偏移计算，得出逻辑地址</p><p>二十一、具有快表时是如何实现地址变换的？</p><p>在CPU给出有效地址之后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的也好，便表示所要访问的页表在快表中，则可以直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在快表中未找到对应的页表项，则需要访问内存中的页表，找到之后把页表读出的物理块号送往地址寄存器，同时更新快表项</p><p>二十二、在具有快表的段页式存储管理方式中，如何实现地址变换？</p><p>首先通过快表直接查找目标块号，若越界则执行中断操作，如果找到则直接送往地址寄存器，未找到则在内存页表中查找，找到之后送往地址寄存器</p><p>二十三、为什么说分段系统比分页系统更易于实现信息的共享和保护？</p><p>分页系统中的“页”只是单纯地存放物理信息，并没有完整的数据逻辑意义，而段是信息的逻辑单位，因此更容易实现信息的共享和保护</p><p>二十四、分页和分段存储管理有何区别？</p><p>页是信息的物理单位，分页是为了实现离散的分配方式，而段是信息的逻辑单位，其包含了有意义的、完整的信息。页的大小由系统决定，而段的大小是不确定的。分页的地址空间是一维的，只需要一个记忆符号就可以表示一个地址，段的地址空间是二位的，需要同时给出段名和段内地址</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>一、常规储存器管理方式具有哪两大特征？它对系统性能有何影响？</p><p>一次性：作业必须一次性地全部装入内存后才能开始运行</p><p>驻留性：作业被装入内存之后，整个作业需要一直驻留在内存中，直至作业运行结束</p><p>这两个特征占据了大量的内存空间，使得一些需要运行的作业因为内存不足而无法装入运行，降低了系统的吞吐量</p><p>二、什么是程序运行时的时间局限性和空间局限性？</p><p>时间局限性：如果程序中的某条指令被执行，则不久以后该指令可能再次执行。产生的原因是在程序中存在着大量的循环操作</p><p>空间局限性：一旦程序访问了某个储存单元，在不久之后，其附近的储存单元也将被访问，典型的情况便是程序的顺序执行</p><p>三、虚拟存储器有哪些特征？其中最本质的特征是什么？</p><p>多次性：作业不需要一次性地装入内存后运行，而是将当前要运行的一部分装入运行，通过多次的装入完成整个作业的运行</p><p>对换性：允许作业在运行过程中，在内存与外存之间换入换出</p><p>虚拟性：能够从逻辑上扩充内存容量，使小容量的内存能够运行比它容量更大的程序</p><p>其中多次性是最本质的特征，有了多次性的特征，作业能够在内存和外存之间交换</p><p>四、实现虚拟存储器需要哪些硬件支持？</p><p>请求分页的页表机制和请求分段的段表机制</p><p>缺页中断机构和缺段中断机构</p><p>地址变换机构</p><p>五、实现虚拟存储器需要哪几个关键技术？</p><p>请求调页的软件和实现页面置换的软件，请求调段的软件和实现段置换的软件</p><p>六、在请求分页系统中，页表应包括哪些数据项？每项的作用是什么？</p><p>页号：分页系统中的页面号码</p><p>物理块号：内存中的物理地址</p><p>状态位P：表示该页是否已调入内存，供程序访问时参考</p><p>访问字段A：记录本页在一段时间内被访问的次数</p><p>修改位M：标示该页在调入内存后是否被修改过</p><p>外存地址：指出该页在外存上的地址，通常是物理块号</p><p>七、在请求分页系统中，应从何处将所需页面调入内存？</p><p>分为以下三种情况：</p><ul><li>系统拥有足够的对换区空间：这时可以全部从对换区调入所需页面，以提高调页的速度</li><li>系统缺少足够的对换区空间：这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘，以后都直接调入。但对于那些可能被修改的部分，在将它们换出时便需要调到对换区，以后需要时再从对换区调入</li><li>UNIX方式：由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应该从文件区调入。而对于曾经运行过但又被换出的页面就放在对换区，在下次调入时从对换区调入</li></ul><p>八、试说明在请求分页系统中页面的调入过程。</p><p>首先向CPU发出缺页中断，中断处理程序保留当前运行环境，分析中断原因后转入缺页中断处理程序。该程序通过查找页表得到该页在外存的物理块后，如果此时内存能够容纳新页，则启动磁盘I/O，将所缺页面调入内存，然后修改页表。如果内存已满，则需要先按照某种置换算法，从内存中选出一页准备换出，如果该页面的修改位为1，则需要将其写入对换区中，如果修改位为0，则可以直接将要换入的页面写到该页面上，然后修改页表。最后程序将页表写入到快表中，同时形成所要访问数据的物理地址，再去访问内存数据</p><p>九、在请求分页系统中，常采用哪几种页面置换算法？</p><p>最佳置换（Optimal）算法：选择的被淘汰的页面将是以后永不使用的，或者是未来最长时间内不会被访问的页面。但由于程序运行无法预知，因此该算法无法实现</p><p>先进先出（FIFO）算法：总是淘汰最先进入内存的页面，即在内存驻留最久的页面将被淘汰</p><p>最近最久未使用（LRU）算法：选择最近一段时间内最久没有被访问的页面，然后将其淘汰</p><p>最少使用（LFU）算法：选择最少使用的页面予以淘汰</p><p>十、在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。</p><p>M为3时，总共发生了10次缺页，缺页率为83.4%</p><p>M为4时，总共发生了7次缺页，缺页率为58.4%</p><p>十一、试说明改进型Clock置换算法的基本原理。</p><p>在简单的Clock置换算法的基础上再添加一个“置换代价”因素，描述该因素的字段是修改位，也就是优先选择最近即未被访问、又未被修改的页面作为淘汰页面。整个算法的过程就是，在页表中检查表项，如果有未访问的页面，则将其选择为被淘汰页面，如果该页面已被防伪，则在检查下一项的同时将检查到的表项的访问位置0。这样子一轮下来，整个页表的访问位都会被重置为0，第二次寻找修改位为0的页面即可。如果仍然选不出淘汰页面，则在第三次寻找时选修改位为1的页面，此时一定可以选出淘汰页面</p><p>十二、在请求分页系统中，产生“抖动”的原因是什么？</p><p>同时在系统中运行的进程太多，分配给每一个进程的页面太少，致使每个进程在运行时频繁地发生缺页，系统频繁地进行页面换入换出，而因为磁盘I/O较慢的原因，每个进程把大量时间用于页面的置换，几乎不能有效地工作，导致处理机的利用率极具下降并趋近于0</p><p>十三、何谓工作集？它是基于什么原理确定的？</p><p>工作集是只某段时间间隔中，进程实际所要访问的页面的集合。它是基于程序访问页面的序列和窗口大小确定的</p><p>十四、当前可以利用哪几种方法来防止“抖动”？</p><p>采用局部置换策略，把工作集算法融入到处理机调度中，利用“L=S”准则调节缺页率，选择暂停的进程</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h1&gt;&lt;p&gt;一、为什么要配置层次式储存器？&lt;/p&gt;&lt;p&gt;为了使存储器跟上处理机的运行速度，提高处理机的使用率，同时尽量降低存储器的成本，采用多层结构的存储器系统是性价比最高的方案&lt;/p&gt;&lt;p&gt;二、可采用哪几种方式将程序装入内存？它们分别适合用于何种场合？&lt;/p&gt;&lt;p&gt;绝对装入方式：将目标模块装入到内存中事先指定的位置，计算机系统很小时，完全有可能知道程序将驻留在内存的什么位置。因此可采用绝对装入的方式将程序装入内存指定位置中&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://fisher.lazybone.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验五：银行家算法</title>
    <link href="http://fisher.lazybone.xyz/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.html"/>
    <id>http://fisher.lazybone.xyz/银行家算法.html</id>
    <published>2019-12-11T11:35:43.000Z</published>
    <updated>2019-12-13T11:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统系列博客的所有实验源自于课程<code>&quot;操作系统原理与实践检验&quot;</code>，代码是参考老师给的<code>&quot;软件工程专业操作系统实验指导书&quot;</code>文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法</p><a id="more"></a><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>进一步理解利用银行家算法避免死锁的问题</li><li>在了解和掌握银行家算法的基础上，编制银行家算法通用程序，将调试结果显示在计算机屏幕上，再检测和笔算的一致性</li><li>理解和掌握安全序列、安全性算法</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>了解和理解死锁</li><li>理解利用银行家算法避免死锁的原理</li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><ul><li><p>数据结构：</p><p>Available：一维数组，系统可用资源列表</p><p>Max：二维数组，进程运行完成所需要的资源总数</p><p>Need：二维数组，进程到达就绪状态还需要的资源数</p><p>Allocation：二维数组，进程已经获得的资源数</p></li><li><p>安全状态</p><p>首先要了解的是：什么是系统的安全状态？</p><p>安全状态是指：在当前情况下，系统能够按照某种执行顺序，为每个进程分配足够的资源，使它们能够顺利完成</p></li><li><p>银行家算法</p><p>顾名思义，银行家算法的就是把计算机系统比喻为银行，进程比喻为来贷款的人。要发放贷款最基本的要求是银行金库中还有钱，并且贷款的人有能力还款，这对应了计算机系统中的剩余资源和进程申请资源时不能超过进程需要的最大资源。核心的要求是银行在发放了贷款之后，能通过某种还款顺序保证不出现坏账，对应计算机系统中就是进程能够以某种安全序列完成任务</p><p>其中安全检查的步骤如下：</p><ol><li><p>如果<code>Request_i &lt;= Need_i</code>，则继续以下检查，否则显示需求申请超过该进程最大需求值的错误</p></li><li><p>如果<code>Request &lt;= Available</code>，则继续以下检查，否则显示系统无足够资源，该进程需要继续阻塞等待</p></li><li><p>系统试着把资源先分配给该进程，并修改相应的数据结构值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i是进程ID的索引，j是资源的索引</span></span><br><span class="line">Available[j] -= Request[j];</span><br><span class="line">Allocation[i][j] += Request[j];</span><br><span class="line">Need[i][j] -= Request[j];</span><br></pre></td></tr></table></figure></li><li><p>系统执行安全性算法，检查此次资源分配之后，系统是否处于安全状态。若系统找到了一个安全序列，则本次分配正式结束。若系统找不到安全序列，则本次分配作废，系统恢复到未分配之前的状态</p></li></ol></li><li><p>安全性算法</p><p>安全性算法就是判断系统能否找到一个安全序列的算法。在本次实验中，我们使用了两个数组变量：</p><ul><li>工作向量<code>Work</code>：它表示系统可用资源的数目，在安全算法刚开始时，<code>Work = Available</code></li><li>标记向量<code>Finish</code>：它表示系统能否有足够的资源分配给进程，使进程运行完成，同时也记录了安全序列</li></ul><p>从进程集合中找到一个能满足下述条件的进程，若找到则执行下一步</p><ul><li><code>Finish[i] = false</code></li><li><code>Need[i][j] &lt;= Work[j]</code></li></ul><p>当进程获得资源后，该进程可顺利运行至完成，并释放出分配给该进程的所有资源，此时可回收资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work[j] += Allocation[i][j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>重复执行上两个步骤，如果所有进程都完成了，则表示系统处于安全状态，否则系统处于不安全状态</p></li></ul><h1 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试模式</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEBUG true</span></span><br><span class="line"><span class="comment">// 系统资源的数量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RESOURCES 3</span></span><br><span class="line"><span class="comment">// 系统进程数量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PROCESS 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统可用资源列表</span></span><br><span class="line"><span class="keyword">int</span> Available[RESOURCES] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 进程运行所需要的总资源</span></span><br><span class="line"><span class="keyword">int</span> Max[PROCESS][RESOURCES] = &#123;&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 进程达到就绪状态还需要的资源</span></span><br><span class="line"><span class="keyword">int</span> Need[PROCESS][RESOURCES] = &#123;&#123;<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 已经分配给进程的资源</span></span><br><span class="line"><span class="keyword">int</span> Allocation[PROCESS][RESOURCES] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Debug模式，银行家账本使用书中的例子\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"非Debug模式，银行家账本随机生成\n"</span>);</span><br><span class="line">        <span class="comment">// 随机产生资源和使用情况</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; RESOURCES; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Available[j] = rand() % <span class="number">5</span> + <span class="number">15</span>;</span><br><span class="line">                Max[i][j] = rand() % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">                Allocation[i][j] = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                Need[i][j] = Max[i][j] - Allocation[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前账本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n====================银行家账本===================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nAvailable: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d "</span>, Available[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nProcess | Allocation | Need\n"</span>);</span><br><span class="line">    <span class="comment">// Process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%5d |"</span>, i);</span><br><span class="line">        <span class="comment">// Allocation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; RESOURCES; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, Allocation[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" | "</span>);</span><br><span class="line">        <span class="comment">// Need</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RESOURCES; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, Need[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行家算法</span></span><br><span class="line"><span class="comment"> * pid：当前要运行的进程</span></span><br><span class="line"><span class="comment"> * no：当前运行的进程顺序</span></span><br><span class="line"><span class="comment"> * work：当前系统可用资源</span></span><br><span class="line"><span class="comment"> * finish：记录进程完成状态和顺序</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bank</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> no, <span class="keyword">int</span> work[], <span class="keyword">int</span> finish[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新一轮运行尝试，尝试的pid: %d，no: %d\n"</span>, pid, no);</span><br><span class="line">    <span class="comment">// 判断当前系统资源能否满足当前进程运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不满足运行条件，终止本次尝试，向上回溯</span></span><br><span class="line">        <span class="keyword">if</span> (work[i] &lt; Need[pid][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"当前pid: %d, 可用的资源: %d, 需要的资源: %d。不满足运行条件！\n"</span>, pid, work[i], Need[pid][i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前资源满足了当前进程运行</span></span><br><span class="line">    <span class="comment">// 标记当前进程已完成</span></span><br><span class="line">    finish[pid] = no;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        work[i] += Allocation[pid][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前进程成功运行完成: %d, 是第 %d 个完成的进程。寻找下一个可运行的进程......\n"</span>, pid, no);</span><br><span class="line">    <span class="comment">// 判断系统是否运行完成</span></span><br><span class="line">    <span class="keyword">if</span> (no &gt;= PROCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配完毕，系统安全！安全序列："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= PROCESS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; PROCESS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (finish[j] == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"finish\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找下一个未完成的进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!finish[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = bank(i, no + <span class="number">1</span>, work, finish);</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有下一个可以运行的进程了，系统进入不安全状态，往上回溯</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        work[i] -= Allocation[pid][i];</span><br><span class="line">    &#125;</span><br><span class="line">    finish[pid] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"没有下一个可以运行的进程了，系统进入不安全状态，往上回溯。当前进程pid:%d,no:%d\n"</span>, pid, no);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请使用资源</span></span><br><span class="line"><span class="comment"> * pid：申请资源的进程ID</span></span><br><span class="line"><span class="comment"> * req_list：申请的资源列表</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> req_list[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pid校验</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt;= PROCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"进程ID非法！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// req_list校验</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (req_list[i] &gt; Need[pid][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请求了过多的资源，分配终止！\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (req_list[i] &gt; Available[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"系统可用资源不足，无法分配！\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用银行家算法判断系统是否安全</span></span><br><span class="line">    <span class="keyword">int</span> work[RESOURCES], finish[PROCESS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        finish[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试探性分配，然后检查是否安全</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Available[i] -= req_list[i];</span><br><span class="line">        Allocation[pid][i] += req_list[i];</span><br><span class="line">        Need[pid][i] -= req_list[i];</span><br><span class="line">        work[i] = Available[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否安全</span></span><br><span class="line">    <span class="keyword">bool</span> safe = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bank(i, <span class="number">1</span>, work, finish))</span><br><span class="line">        &#123;</span><br><span class="line">            safe = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果系统安全，则本次分配完成</span></span><br><span class="line">    <span class="keyword">if</span> (safe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"本次分配完成！\n"</span>);</span><br><span class="line">        ps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配不安全，本次分配作废</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Available[i] += req_list[i];</span><br><span class="line">            Allocation[pid][i] -= req_list[i];</span><br><span class="line">            Need[pid][i] += req_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有安全的分配方案，请求资源失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdstr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> cmd, req_id, req_list[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmdstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"exit"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"help"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请求资源: request\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查看当前银行家账本: ps\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"获取帮助: help\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出: exit\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"ps"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ps();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"request"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请资源的进程ID: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;req_id);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请的资源的数量: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;req_list[<span class="number">0</span>], &amp;req_list[<span class="number">1</span>], &amp;req_list[<span class="number">2</span>]);</span><br><span class="line">            request(req_id, req_list);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: 未知的命令！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ps();</span><br><span class="line">    terminal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h1><ol><li><p>编译运行程序，这里就不放截图了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ bank.cpp -o bank</span><br><span class="line">./bank</span><br></pre></td></tr></table></figure></li><li><p>使用<code>help</code>命令查看帮助信息</p><p><img src="images/os/bankhelp.png" alt="帮助信息"></p></li><li><p>使用<code>ps</code>命令查看当前账本</p><p><img src="images/os/bankps.png" alt="ps命令"></p></li><li><p>使用<code>request</code>申请资源，查看系统运行过程</p><p><img src="images/os/bankrequest.png" alt="申请资源"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验我们实现了银行家算法，了解了系统为了防止死锁发生所做的工作。在现代的商业系统中，可能有许多的进程，要防止死锁的代价是非常高的，所以这些系统都采取了消极的措施，就是不管死锁的发生，也不去处理，在真正出现问题的时候，重启还是一个比较快的方法。但在一些高可靠性的系统中，可能系统的进程数量比较少，而且因为业务的要求，系统必须采取措施来防止死锁的发生，这时候银行家算法就有用武之地了</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li><p>在编程中遇到了哪些问题？你是如何解决的？</p><p>一开始想要以非递归的方法实现安全性检测，但是发现代码十分混乱而且比较难理解，改用递归的方法之后就好很多了。有了思路之后，实现算法的速度还是挺快的</p></li><li><p>在安全性算法中，为什么不用变量<code>Available</code>，而又定义一个临时变量<code>Work</code>？</p><p>因为在递归调用安全性检测的算法过程中，一直需要对系统可用资源进行调整，直接用<code>Available</code>变量会导致算法在找到安全序列之后还要向上回溯，恢复<code>Available</code>的值，因此定义一个临时变量<code>Work</code>更为方便    </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;操作系统系列博客的所有实验源自于课程&lt;code&gt;&amp;quot;操作系统原理与实践检验&amp;quot;&lt;/code&gt;，代码是参考老师给的&lt;code&gt;&amp;quot;软件工程专业操作系统实验指导书&amp;quot;&lt;/code&gt;文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题一</title>
    <link href="http://fisher.lazybone.xyz/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%B8%80.html"/>
    <id>http://fisher.lazybone.xyz/操作系统习题一.html</id>
    <published>2019-12-09T13:43:39.000Z</published>
    <updated>2019-12-30T12:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>一、设计现代OS的主要目标是什么？<br>  现代OS的主要目标有4个：方便性、有效性、可扩充性、开放性<br>  方便性：系统将用户采用高级语言编写的程序翻译成机器码，或直接通过OS所提供的各种命令操纵计算机系统，方便了用户，使计算机变得易学易用<br>  有效性：提高了系统资源的利用率，提高系统的吞吐量，缩短程序运行周期<br>  可扩充性：能够方便地添加新功能和模块，以及对原有的功能和模块进行修改<br>  开放性：能够遵循国际标准开发硬件和软件，都能彼此兼容，方便地实现互联</p><a id="more"></a><p>二、为什么说操作系统实现了对计算机资源的抽象？<br>  操作系统在裸机上覆盖了一层设备管理软件，隐藏了物理接口的实现细节。用户无需关心或了解某些功能具体是如何实现的，但也能够很好地利用计算机的资源，操作系统在这里就是实现了对计算机资源的抽象</p><p>三、OS有哪几大特征，其最基本的特征是什么？<br>  OS有并发、共享、虚拟、异步，这4大特征<br>  并发：指两个或多个事件在同一时间间隔内发生，在微观上就是多个程序交替执行<br>  共享：系统中的资源可供内存中多个并发执行的进程共同使用<br>  虚拟：通过某种技术将一个物理实体变为若干个逻辑上的对应物<br>  异步：异步使得处理器不需要等待进程IO，继续执行下一个程序，在程序IO中断完成后通过回调函数继续执行</p><p>四、是什么原因使操作系统具有异步性特征？<br>  为了提高CPU资源的利用率，在程序IO阻塞的过程中，如果没有异步执行的概念，CPU将会一直等待进程IO完成，这浪费了大量的CPU资源</p><p>五、处理机管理有哪些主要功能？其主要任务是什么？<br>  进程控制：为作业创建进程、撤销已结束的进程，控制进程在运行过程中的转换<br>  进程同步：保证多个进程运行时的协调，确保系统资源的合理分配<br>  进程通信：实现相互合作的进程之间的信息互换<br>  调度：包括作业调度和进程调度。作业调度的基本任务是从后背队列中按照一定的算法选择出若干个作业，为他们分配运行时所需的资源。进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给该进程</p><p>六、内存管理有哪些主要功能？其主要任务是什么？<br>  内存分配：为每道程序动态或静态地分配内存空间，提高储存器的利用率<br>  内存保护：确保每道程序仅在自己的内存空间内运行，互不干扰。不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行<br>  地址映射：将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址<br>  内存扩充：借助虚拟储存技术，从逻辑上扩大内存，其中包括了请求调入功能和置换功能</p><p>七、设备管理有哪些主要功能？其主要任务是什么？<br>  缓冲管理：在IO设备和CPU之间引入缓冲，缓解了CPU和IO设备速度不匹配的矛盾<br>  设备分配：根据用户的请求、系统现有资源情况以及按照某种预设分配策略，为之分配所需的设备<br>  设备处理：实现CPU和设备控制器之间的通信，又称为驱动程序</p><p>八、文件管理有哪些主要功能？其主要任务是什么？<br>  文件储存空间的管理：对文件以及文件的储存空间进行统一的管理<br>  目录管理：为每个文件建立一个目录项，提高检索文件的速度<br>  文件的读/写保护：防止系统中的文件被非法盗取和破坏，对读/写中的文件提供保护</p><p>九、什么是微内核OS？<br>  微内核OS是将系统服务的实现与系统的基本操作规则区分开来，让服务之间互相独立，减少了系统的耦合度，系统也可以根据功能的需要添加或更换模块使系统功能更具有弹性</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>一、为什么程序并发执行会产生间断性特征？<br>  程序在并发执行时，由于他们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。这种相互制约的关系导致并发程序具有“执行——暂停——执行”这种间断性规律</p><p>二、程序并发执行时为什么会失去封闭性和可再现性？<br>  系统中的资源被多个程序共享使用时，其中任一程序改变资源的状态时，其他程序也会受到影响，因此而失去了封闭性。程序失去封闭性后，并发执行的过程中会发生许多意想不到的状态值修改，也就是失去了可再现性</p><p>三、PCB提供了进程管理和进程调度所需要的哪些信息？<br>  进程管理：通用寄存器、指令计数器、程序状态字、用户栈指针<br>  进程调度：进程状态、进程优先级、事件、其他信息</p><p>四、进程控制块的组织方式有哪几种？<br>  线性方式、链接方式、索引方式</p><p>五、何谓操作系统的内核？内核的主要功能是什么？<br>  操作系统内核是一些与硬件紧密相关的模块（中断处理程序）、各种常用设备的驱动程序以及运行频率较高的模块（时钟管理、进程调度和许多公用模块），它们都常驻内存，主要提供以下功能：<br>  支撑功能：中断处理、时钟管理、原语操作<br>  资源管理功能：进程管理、储存器管理、设备管理</p><p>六、试说明进程在三个基本状态之间转换的典型原因。<br>  就绪 -&gt; 执行：进程获得分配的CPU时间片，开始执行<br>  执行 -&gt; 阻塞：执行中的进程发生IO中断，因而无法继续执行，此时进程又执行状态变为阻塞状态<br>  阻塞 -&gt; 就绪：进程IO完成，但还未分配到CPU时间片，因此转为就绪状态</p><p>七、试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。<br>  调度性：进程的调度包括了上下文的切换，开销较大。而线程的调度仅需保存和设置少量寄存器内容，切换的代价小于进程。在同一进程中的线程切换不会引起上下文的切换，但不同进程中的线程切换会引起上下文的切换<br>  并发性：同一进程不能并发，而同一进程中的不同线程可以并发。不同进程之间可以并发，不同进程的不同线程可以并发<br>  拥有资源：进程可以拥有资源，而线程本身不拥有系统资源，仅有保证独立运行的资源。线程的资源可以共享该进程拥有的资源<br>  系统开销：线程的创建、切换和撤销的花销都比进程要小得多</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>一、高级调度与低级调度的主要任务是什么？为什么要引入中级调度？<br>  高级调度：调度对象是作业，根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为他们创建进程、分配必要的资源，并将他们放入就绪队列<br>  低级调度：调度对象是进程，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程<br>  引入中级调度的目的：提高内存的利用率和系统的吞吐量。将暂时不能运行的进程调至外存等待，当具备运行条件时重新调入内存</p><p>二、处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？</p><p>  处理机调度算法的共同目标：</p><ul><li>提高系统资源利用率</li><li>提高公平性，使进程都获得合理CPU时间</li><li>保持系统资源使用的平衡</li><li><p>制订的策略强制执行</p><p>批处理系统的调度目标：</p></li><li>缩短平均周转时间</li><li>提高系统的吞吐量</li><li>提高处理机利用率</li></ul><p>三、在作业调度中应如何确定接纳多少个作业和接纳哪些作业？<br>  接纳作业的数量根据系统规模、运行速度、作业大小、以及能否获得较好的系统性能等情况作出适当的抉择<br>  接纳哪些作业根据不同的调度算法来判断，最简单的是先来先服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法</p><p>四、试说明低级调度的主要功能。<br>  根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程</p><p>五、在选择调度方式和调度算法时，应遵循的准则是什么？<br>  应尽量保证公平，每个进程分得的CPU时间片应尽量平衡。保持系统资源使用的平衡性</p><p>六、试比较FCFS和SJF两种进程调度算法。<br>  先来先服务（FCFS）算法：每次从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行，该进程一直运行到完成或发生某时间而阻塞后，进程调度程序才将处理机分配给其他进程<br>  短作业优先（SJF）算法：按照作业的长短来计算优先级，作业越短，优先级越高<br>  与FCFS比，SJF需要预知作业的运行时间，而且对长作业非常不利，两种算法都不能实现人机交互，SJF没有考虑作业的紧迫程度，不能保证紧迫性作业能够得到及时的处理</p><p>七、在时间片轮转法中，应如何确定时间片的大小？<br>  一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，时间片过长会导致算法退化为FCFS，过短会增加系统执行进程调度的开销</p><p>八、为什么说多级反馈队列调度算法能较好地满足各个方面用户的需要？<br>  多级反馈队列调度算法不必事先知道各种进程所需的执行时间，不同类型的进程放在不同优先级的就绪队列中，每个队列采用FCFS算法，这种算法能够较好地满足各种类型进程的需要，因此能够很好地满足各个方面用户的需要</p><p>九、什么是最低松弛度优先调度算法？举例说明之。<br>  根据任务的紧急程度确定任务的优先级，紧急程度越高，该任务的优先级就越高<br>  例如：若一个任务A在200ms时必须完成，它本身运行所需的时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度为100ms。而另一个任务B在400ms时必须完成，它本身运行所需的时间是150ms，则松弛程度为250ms。根据算法可知，最低松弛度的任务是A，接下来应该执行A任务</p><p>十、何谓“优先级倒置”现象，可采取什么方法来解决？<br>  优先级倒置：低优先级的任务占有了高优先级任务的资源，导致高优先级任务阻塞，可采取优先级继承的方法解决</p><p>十一、试分别说明可重用资源和可消耗资源的性质。<br>  可重用资源：可供用户重复使用多次的资源，每一个可重用的资源只能分配给一个进程使用。进程在使用可重用资源时，必须参照：请求资源、使用资源、解放资源的顺序使用。系统中的可重用资源数量相对是固定的<br>  可消耗资源：又称临时性资源，是在进程运行期间不断变化的。进程在运行期间可以不断创造可消耗性资源的单元，在进程结束后可消耗资源也跟着消失</p><p>十二、试举例说明竞争不可抢占资源引起的死锁。<br>  假设A进程运行需要1号和2号资源，目前1号资源已经申请成功，由A进程占用。而B进程的运行也需要1号和2号资源，且B进程已经申请占用了2号资源。两个进程都在等待对方释放资源，从而引起了进程的死锁</p><p>十三、为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议。<br>  第一种协议：进程在运行之前必须一次性申请在整个运行过程中所需的全部资源。其优点是简单、易行且安全，但资源被严重浪费，并且进程会经常发生饥饿现象<br>  第二种协议：是第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行，运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。第二种协议不仅能使进程更快地完成任务，提高设备的利用率，还可以减少进程发生饥饿的概率</p><p>十四、何谓死锁？产生死锁的原因和必要条件是什么？<br>  如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的<br>  产生死锁的原因有：竞争不可抢占性资源引起死锁，竞争可消耗资源引起死锁<br>  产生死锁的必要条件：互斥条件-&gt;进程对所分配到的资源进行排他性使用；请求和保持条件-&gt;进程已经保持了至少一个资源，但又提出了新的资源请求；不可抢占条件-&gt;进程已获得的资源在未使用完之前不能被抢占；循环等待条件-&gt;在发生死锁时，必然存在一个进程——资源的循环链</p><p>十五、在解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？<br>  解决死锁问题有预防和解除2种思路。预防死锁有：破坏“请求和保持”条件，破坏“循环等待”条件，保持系统处于安全状态，银行家算法等方法。解除死锁有：终止进程，抢占资源等方法<br>  这几种方法中，破坏死锁产生的条件最容易实现，银行家算法和保持系统处于安全状态的资源利用率最高</p><p>十六、请详细说明可通过哪些途径预防死锁。<br>  破坏“请求和保持”条件：进程逐步申请、释放资源<br>  破坏“循环等待”条件：进程占有的资源可以被抢占<br>  保持系统处于安全状态：在分配资源之前计算资源分配的安全性<br>  银行家算法：在分配资源之前计算剩余资源的可用情况</p><p>十七、在银行家算法的例子中，如果P0发出的请求向量由Request(0,2,0)改为Request(0,1,0)，问系统可否将资源分配给它？<br>  假设资源分配给了P0，则剩余情况如下：Avalibale(2, 2, 0)。可以找到一个安全序列：{P1, P3, P2, P0, P4}，因此系统能将资源分配给他</p><p>十八、在银行家算法中，若出现下述资源分配情况，试问：</p><table><thead><tr><th>Process</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td>P0</td><td>0 0 3 2</td><td>0 0 1 2</td><td>1 6 2 2</td></tr><tr><td>P1</td><td>1 0 0 0</td><td>1 7 5 0</td><td></td></tr><tr><td>P2</td><td>1 3 5 4</td><td>2 3 5 6</td><td></td></tr><tr><td>P3</td><td>0 3 3 2</td><td>0 6 5 2</td><td></td></tr><tr><td>P4</td><td>0 0 1 4</td><td>0 6 5 6</td></tr></tbody></table><p>（1）该状态是否安全？<br>​ 可以找到一个安全序列：{P0, P3, P1, P2, P4}，因此该状态是安全的<br>（2）若进程P2提出请求Request(1,2,2,2)后，系统能否将资源分配给它？<br>​ 因为Need(2,3,5,6)&lt;Request(1,2,2,2)且Request(1,2,2,2)&lt;Avaliable(1,6,2,2)。暂且认为可以分配之后，可用资源为Avaliable(0,4,0,0)，无法找到一个安全序列，因此系统不能将资源分配给它</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;一、设计现代OS的主要目标是什么？&lt;br&gt;  现代OS的主要目标有4个：方便性、有效性、可扩充性、开放性&lt;br&gt;  方便性：系统将用户采用高级语言编写的程序翻译成机器码，或直接通过OS所提供的各种命令操纵计算机系统，方便了用户，使计算机变得易学易用&lt;br&gt;  有效性：提高了系统资源的利用率，提高系统的吞吐量，缩短程序运行周期&lt;br&gt;  可扩充性：能够方便地添加新功能和模块，以及对原有的功能和模块进行修改&lt;br&gt;  开放性：能够遵循国际标准开发硬件和软件，都能彼此兼容，方便地实现互联&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://fisher.lazybone.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验四：带优先级的时间片轮换的进程调度算法的实现</title>
    <link href="http://fisher.lazybone.xyz/%E5%B8%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E6%8D%A2%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html"/>
    <id>http://fisher.lazybone.xyz/带优先级的时间片轮换的进程调度算法.html</id>
    <published>2019-12-04T11:21:55.000Z</published>
    <updated>2019-12-05T11:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统系列博客的所有实验源自于课程<code>&quot;操作系统原理与实践检验&quot;</code>，代码是参考老师给的<code>&quot;软件工程专业操作系统实验指导书&quot;</code>文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法</p><a id="more"></a><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>掌握进程状态转换过程</li><li>掌握时间片轮转的进程调度算法</li><li>掌握带优先级的进程调度算法</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>自定义PCB的数据结构</li><li>使用带优先级的时间片轮转调度算法进行进程调度，每运行一个时间片，进程优先级减半</li><li>需要完成的命令集：<ul><li><code>create</code>：随机创建进程，进程的优先级与所需要的时间片随机决定</li><li><code>round</code>：执行一次时间片轮转操作，其方法为运行高优先级队列的第一个，再降低其优先级，插入到相应的队列中</li><li><code>ps</code>：查看当前进程状态</li><li><code>sleep</code>：将一个就绪的进程挂起</li><li><code>awake</code>：唤醒一个被挂起的进程</li><li><code>kill</code>：杀死一个进程</li><li><code>help</code>：系统帮助</li><li><code>quit</code>：退出系统</li></ul></li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>本次实验结合了进程的状态转换、优先级调度、时间片轮转调度，这三个方面的内容。根据进程状态转换图，设置<code>sleep</code>命令，将一个进程挂起；<code>awake</code>命令唤醒一个被挂起的进程（从阻塞状态到就绪状态）</p><ul><li><p>优先级</p><p>优先级体现了进程的重要程度或紧迫程度，在大多数现代操作系统中，都采用了优先级调度策略。优先级从小到大（如0-127）逐渐降低，0的优先级最高，127的优先级最低。在本次实验中，进程的优先级分为3个等级（0-2），数值越大，优先级越高</p></li><li><p>基于时间片调度</p><p>将所有的就绪进程按照先来先服务的原则，排成一个队列，每次调度时，将CPU分配给队首进程，并令其执行一个时间片。当时间片用完时，由一个计时器发出时钟中断请求，调度程序把此进程终止，然后把该进程放到队尾</p><p>在本次实验中，时间片以大约1000ms为单位（实际上要小得多），使用双重for循环实现。在调度过程中，需要通过时间函数检测进程的执行时间，当该进程执行时间&gt;=时间片大小时进行调度</p></li><li><p>高优先级调度</p><p>优先级高的进程先得到CPU，等该进程执行完毕后，另外的进程才能执行</p></li><li><p>基于时间片的高优先级调度</p><p>在调度算法中，只有处于就绪状态的进程才能被调度，调度算法结合了优先级调度和时间片轮转调度算法，约定：从最高优先级队列取第一个就绪状态的进程进行调度，时间片到后降低其优先级（降低一半），然后插入到底优先级队列的尾部，每次调度后，显示进程的状态</p></li></ul><h1 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h1><p>由于实验的代码比较长，这里采用分块的方法来进行代码汇总</p><h2 id="定义系统常量，数据结构，初始化函数"><a href="#定义系统常量，数据结构，初始化函数" class="headerlink" title="定义系统常量，数据结构，初始化函数"></a>定义系统常量，数据结构，初始化函数</h2><p>需要的系统常量有：系统最大进程数、最高优先级、时间片大小、命令列表</p><p>定义的数据结构：进程控制块PCB、<code>priority_array</code>优先级数组+链表，数组用于记录不同的优先级链表中的第一个进程，其余同优先级进程使用链表进行储存、<code>id_list</code>，记录进程的创建状况</p><p><code>init</code>函数：初始化优先级链表，将其置为NULL。初始化命令列表，一共有8条命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义进程数</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PROCESS_NUMBER 10</span></span><br><span class="line"><span class="comment">// 定义最高优先级（0-2）</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_PRIORITY 3</span></span><br><span class="line"><span class="comment">// 定义时间片</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> QUANTUM 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> status;<span class="comment">// 进程状态：0-就绪，1-运行，2-阻塞</span></span><br><span class="line">    <span class="keyword">int</span> prio;<span class="comment">// 进程优先级</span></span><br><span class="line">    <span class="keyword">int</span> life;<span class="comment">// 剩余生命周期</span></span><br><span class="line">    pcb *next;<span class="comment">// 优先级链表指针</span></span><br><span class="line">&#125; *priority_array[MAX_PRIORITY];<span class="comment">// 优先级数组+链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> id_list[PROCESS_NUMBER];<span class="comment">// 进程ID列表，记录进程创建状态</span></span><br><span class="line"><span class="keyword">int</span> life = <span class="number">0</span>;<span class="comment">// 系统剩余总生命周期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> command[<span class="number">8</span>][<span class="number">10</span>];<span class="comment">// 命令列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_PRIORITY; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        priority_array[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">0</span>], <span class="string">"quit"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">1</span>], <span class="string">"help"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">2</span>], <span class="string">"ps"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">3</span>], <span class="string">"create"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">4</span>], <span class="string">"kill"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">5</span>], <span class="string">"runtime"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">6</span>], <span class="string">"sleep"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(command[<span class="number">7</span>], <span class="string">"awake"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出当前系统状态信息"><a href="#输出当前系统状态信息" class="headerlink" title="输出当前系统状态信息"></a>输出当前系统状态信息</h2><p><code>ps</code>函数：使用优先级数组+链表的数据结构，可以很容易按照优先级进行遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出系统当前进程状态</span></span><br><span class="line"><span class="comment"> * p: 遍历指针</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total system life: %d\n"</span>, life);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_PRIORITY; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Priority level: %d\n"</span>, i);</span><br><span class="line">        p = priority_array[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"id: %d, status: %d, priority: %d, life: %d\n"</span>, p-&gt;id, p-&gt;status, p-&gt;prio, p-&gt;life);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h2><p><code>create</code>函数：按照顺序分配一个进程ID，随机分配进程优先级和进程生命周期，然后插入到相应的优先级链表中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机创建一个新进程</span></span><br><span class="line"><span class="comment"> * i：进程ID</span></span><br><span class="line"><span class="comment"> * prio：进程优先级</span></span><br><span class="line"><span class="comment"> * plife：进程生命周期</span></span><br><span class="line"><span class="comment"> * p：指向同等优先级链表表头，遍历中发生变化</span></span><br><span class="line"><span class="comment"> * p_previous：指向p的上一个节点，用于尾插法</span></span><br><span class="line"><span class="comment"> * s：指向新创建的进程</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, prio = <span class="number">0</span>, plife = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">p</span> = <span class="title">NULL</span>, *<span class="title">p_previous</span> = <span class="title">NULL</span>, *<span class="title">s</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 检查是否到达进程数量上限，同时分配进程ID</span></span><br><span class="line">    <span class="keyword">while</span> (id_list[i] != <span class="number">0</span> &amp;&amp; i &lt;= PROCESS_NUMBER - <span class="number">1</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (PROCESS_NUMBER == i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"System max process error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新进程的参数，增加总生命周期</span></span><br><span class="line">    id_list[i] = <span class="number">1</span>;</span><br><span class="line">    prio = rand()%MAX_PRIORITY;</span><br><span class="line">    plife = rand()%<span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">    life += plife;</span><br><span class="line">    <span class="comment">// 创建新进程</span></span><br><span class="line">    s = <span class="keyword">new</span> pcb;</span><br><span class="line">    s-&gt;id = i;</span><br><span class="line">    s-&gt;status = <span class="number">0</span>;</span><br><span class="line">    s-&gt;prio = prio;</span><br><span class="line">    s-&gt;life = plife;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 插入到进程优先级链表中</span></span><br><span class="line">    p = priority_array[prio];</span><br><span class="line">    <span class="comment">// 如果表头为NULL，新进程为表头</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        priority_array[prio] = s;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 表头不为空，使用尾插法插入到链表尾部</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p_previous = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p_previous-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入完成，输出当前进程状态</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Successfully create process(id: %d), current system status: \n"</span>, i);</span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞-唤醒线程"><a href="#阻塞-唤醒线程" class="headerlink" title="阻塞/唤醒线程"></a>阻塞/唤醒线程</h2><p><code>sleep/awake</code>函数：这两个函数的操作基本一样，都是找到进程后修改进程的状态码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞某个进程</span></span><br><span class="line"><span class="comment"> * i：进程x的优先级索引</span></span><br><span class="line"><span class="comment"> * find：进程x找到的标记</span></span><br><span class="line"><span class="comment"> * p：指向进程x</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, find = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 搜索ID为x的进程</span></span><br><span class="line">    <span class="keyword">while</span> (!find &amp;&amp; i!=MAX_PRIORITY)</span><br><span class="line">    &#123;</span><br><span class="line">        p = priority_array[i];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;id == x)</span><br><span class="line">            &#123;</span><br><span class="line">                find = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到进程x，操作终止</span></span><br><span class="line">    <span class="keyword">if</span> (!find)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Sleep: Invaild process number!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将进程x的状态设为阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;status == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The process(id: %d) has been blocked, cannot sleep again!\n"</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;status = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 操作结束后系统进程状态</span></span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒某个进程</span></span><br><span class="line"><span class="comment"> * i：进程x的优先级索引</span></span><br><span class="line"><span class="comment"> * find：进程x找到的标记</span></span><br><span class="line"><span class="comment"> * p：指向进程x</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awake</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, find = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 搜索ID为x的进程</span></span><br><span class="line">    <span class="keyword">while</span> (!find &amp;&amp; i!=MAX_PRIORITY)</span><br><span class="line">    &#123;</span><br><span class="line">        p = priority_array[i];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;id == x)</span><br><span class="line">            &#123;</span><br><span class="line">                find = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到进程x，操作终止</span></span><br><span class="line">    <span class="keyword">if</span> (!find)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Awake: Invaild process number!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将进程x的状态设为就绪</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;status != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The process(id: %d) has been awaked, cannot awaked again!\n"</span>, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 操作结束后系统进程状态</span></span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><p><code>kill</code>函数：首先找到进程的位置，将其从优先级链表上摘下来后删除，同时<code>id_list</code>相应位置置为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杀死某个进程</span></span><br><span class="line"><span class="comment"> * i：进程x的优先级索引</span></span><br><span class="line"><span class="comment"> * find：进程x找到的标记</span></span><br><span class="line"><span class="comment"> * p：指向进程x</span></span><br><span class="line"><span class="comment"> * p_previous：指向进程x在优先级链表上的前一个节点</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, find = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">p</span> = <span class="title">NULL</span>, *<span class="title">p_previous</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 搜索ID为x的进程</span></span><br><span class="line">    <span class="keyword">while</span> (!find &amp;&amp; i!=MAX_PRIORITY)</span><br><span class="line">    &#123;</span><br><span class="line">        p = priority_array[i];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;id == x)</span><br><span class="line">            &#123;</span><br><span class="line">                find = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_previous = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到进程x，操作终止</span></span><br><span class="line">    <span class="keyword">if</span> (!find)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Kill: Invaild process number!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 杀死进程，同时摘链</span></span><br><span class="line">    <span class="keyword">if</span> (p == priority_array[i])<span class="comment">// 进程节点在链表头部</span></span><br><span class="line">    &#123;</span><br><span class="line">        priority_array[i] = priority_array[i]-&gt;next;</span><br><span class="line">        id_list[x] = <span class="number">0</span>;</span><br><span class="line">        life -= p-&gt;life;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 进程节点不在链表头部</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_previous-&gt;next = p-&gt;next;</span><br><span class="line">        id_list[x] = <span class="number">0</span>;</span><br><span class="line">        life -= p-&gt;life;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作结束后系统进程状态</span></span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间片运行"><a href="#时间片运行" class="headerlink" title="时间片运行"></a>时间片运行</h2><p><code>runtime</code>函数：模拟运行一个周期，然后降低该进程的优先级，如果该进程未运行完成，则将该进程节点移动到新的优先级链表上，如果已经运行完成，则执行<code>kill</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行一个时间片周期</span></span><br><span class="line"><span class="comment"> * i：优先级链表索引</span></span><br><span class="line"><span class="comment"> * prio：新的优先级</span></span><br><span class="line"><span class="comment"> * t：新的优先级链表索引</span></span><br><span class="line"><span class="comment"> * pp：指向新优先级链表要插入的节点</span></span><br><span class="line"><span class="comment"> * qq：指向新优先级链表要插入的节点的上一个节点</span></span><br><span class="line"><span class="comment"> * r_previous：要运行的进程的上一个节点</span></span><br><span class="line"><span class="comment"> * r：要运行的进程</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = MAX_PRIORITY - <span class="number">1</span>, prio = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> *<span class="title">pp</span> = <span class="title">NULL</span>, *<span class="title">qq</span> = <span class="title">NULL</span>, *<span class="title">r_previous</span> = <span class="title">NULL</span>, *<span class="title">r</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 寻找优先级最高的，状态为就绪的进程，指针r指向它</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; priority_array[i] == <span class="literal">NULL</span>)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No process in the system, create/awake a process and try again!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r_previous = priority_array[i];</span><br><span class="line">        r = priority_array[i];</span><br><span class="line">        <span class="keyword">while</span> (r != <span class="literal">NULL</span> &amp;&amp; r-&gt;status != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r_previous = r;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (r == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 运行一个时间片周期</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process(id: %d) gain the CPU time and will execute %d quantum\n"</span>, r-&gt;id, QUANTUM);</span><br><span class="line">    r-&gt;status = <span class="number">1</span>;<span class="comment">// 将进程状态置为运行中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Process %d is running......\n"</span>, r-&gt;id);</span><br><span class="line">    <span class="comment">// 制造运行时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">600000</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Time out, change to ready status, reduce priority\n"</span>);</span><br><span class="line">    r-&gt;status = <span class="number">0</span>;</span><br><span class="line">    r-&gt;prio /= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 更新系统生命周期和进程生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;life - QUANTUM &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;life -= QUANTUM;</span><br><span class="line">        life -= QUANTUM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        life -= r-&gt;life;</span><br><span class="line">        r-&gt;life = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查进程生命周期是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;life == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Process %d completed, now release it!\n"</span>, r-&gt;id);</span><br><span class="line">        kill(r-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r_previous == r)</span><br><span class="line">            priority_array[i+<span class="number">1</span>] = r-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r_previous-&gt;next = r-&gt;next;</span><br><span class="line">        <span class="comment">// 添加到新优先级链表的尾部</span></span><br><span class="line">        t = r-&gt;prio;</span><br><span class="line">        pp = priority_array[t];</span><br><span class="line">        <span class="keyword">while</span> (pp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qq = pp;</span><br><span class="line">            pp = pp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qq == <span class="literal">NULL</span>)</span><br><span class="line">            priority_array[t] = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            qq-&gt;next = r;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个生命周期结束，显示系统进程状态</span></span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行控制台和系统主入口"><a href="#命令行控制台和系统主入口" class="headerlink" title="命令行控制台和系统主入口"></a>命令行控制台和系统主入口</h2><p>命令控制台和系统主入口都很好理解，这里就不多说了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 命令行控制台</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdstr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> cmd = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmdstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(command[i], cmdstr))</span><br><span class="line">            &#123;</span><br><span class="line">                cmd = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"id: 当前进程ID  status: 进程状态:0-就绪,1-运行,2-阻塞  prio: 进程优先级  life: 进程生命\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"随机创建一个新进程: create\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"杀死一个进程: kill\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"使一个进程进入阻塞状态: sleep\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"唤醒一个进程: awake\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"查看当前进程信息: ps\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"运行一个时间片周期: runtime\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"获取帮助: help\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"退出: quit\n"</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                ps();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                create();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Which process you want to kill: "</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">                kill(id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                runtime();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Which process you want to sleep: "</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">                sleep(id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Which process you want to awake: "</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;id);</span><br><span class="line">                awake(id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error command!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    terminal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h1><ol><li><p>编译并运行程序，早上编译的时候按多了一下Tab键，导致cpp源文件直接被覆盖重写成了二进制文件，重写代码花了1个小时，有时候Tab键真的能坑死人😂</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ dispatcher.cpp -o dispatcher</span><br><span class="line">./dispatcher</span><br></pre></td></tr></table></figure><p><img src="images/os/compile1.png" alt="编译运行"></p></li><li><p>使用<code>help</code>命令查看帮助信息</p><p><img src="images/os/help.png" alt="帮助信息"></p></li><li><p>创建多个进程，进程超过系统上限后就无法创建了，然后查看系统进程状态</p><p><img src="images/os/createpc1.png" alt="创建进程"></p></li><li><p>阻塞/唤醒一些进程，使系统进程有不同的状态。尝试重复阻塞/唤醒某些进程，看看系统能否检查出错误操作</p><p>图中可以看到，我将<code>3,0,2,1,4</code>号进程阻塞，7号进程是阻塞后又唤醒的进程</p><p><img src="images/os/sleepawake.png" alt="阻塞/唤醒进程"></p></li><li><p>杀死进程，检查进程是否从优先级链表中移除</p><p>图里可以看到，我将ID为1的进程杀死之后，系统状态中已不存在ID为1的进程</p><p><img src="images/os/kill.png" alt="杀死进程"></p></li><li><p>运行一个时间片</p><p>可以看到0，2，4号进程因为阻塞状态而不运行，系统选择了8号进程运行，时间片走完之后，8号进程的优先级减半，并且插入到优先级为0的等待队列中</p><p><img src="images/os/runtime.png" alt="运行"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验我们模拟了操作系统中的进程调度，我们使用的调度算法是最高优先级的调度算法，即从等待队列中取出优先级最高的进程运行。该算法的好处是保证了高优先级的进程获得更多的时间片，缺点在于如果不断有新的高优先级进程加入等待队列，低优先级的进程获得时间片的概率很低。该算法的时间复杂度为O(n)，只需要运行一次扫描就能选取出优先级最高的进程，空间复杂度也同样为O(n)，只需要指针进行标记，不需要额外的空间就能进行进程的调度。在现代操作系统中，系统通常选取多种不同的算法来进行进程的调度，尽量保证每个进程获得CPU时间片的概率是相同的</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li><p>读懂程序，画出算法所用的数据结构简图</p><p>该算法的数据结构很简单，一个类型为PCB指针的数组，下标代表优先级，在本次实验的定义中，下标越大优先级越高，数组中的元素是该优先级链表中的第一个PCB。在算法执行过程中，只需要取优先级最高，并且为就绪状态的PCB即可，这需要一个<code>for</code>循环：用于优先级数组遍历，和一个<code>while</code>循环：用于链表的遍历，即可选出对应的PCB</p><p><img src="images/os/datastruct.png" alt="数据结构"></p></li><li><p>修改<code>runtime</code>函数，使得算法能够模拟运行中的进程被外界中断或因设备请求而不能运行，自动转入阻塞状态并进行调度</p><p>答：在执行过程中的两个<code>for</code>循环处加上对该进程的<code>sleep</code>操作和<code>runtime</code>递归调用即可，如果该进程的优先级不需要减半，再加上<code>return</code>终止此次调度即可</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;操作系统系列博客的所有实验源自于课程&lt;code&gt;&amp;quot;操作系统原理与实践检验&amp;quot;&lt;/code&gt;，代码是参考老师给的&lt;code&gt;&amp;quot;软件工程专业操作系统实验指导书&amp;quot;&lt;/code&gt;文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>VMware运行bin引导文件</title>
    <link href="http://fisher.lazybone.xyz/vmware%E8%BF%90%E8%A1%8Cbin%E5%BC%95%E5%AF%BC%E6%96%87%E4%BB%B6.html"/>
    <id>http://fisher.lazybone.xyz/vmware运行bin引导文件.html</id>
    <published>2019-12-01T07:26:24.000Z</published>
    <updated>2019-12-01T14:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《自己动手写操作系统》这本书，其中第一章有一段简单的引导代码。书中的指导是将源代码文件<code>.asm</code>编译为二进制文件<code>.bin</code>后写入到软盘中，然后启动运行；又或者是使用<code>FloppyWriter</code>将二进制文件<code>.bin</code>写为镜像文件<code>.img</code>，再放到<code>Virtual PC</code>中运行。由于年代久远，现在的电脑已经没有软盘位，遗留下来的软盘也早被我小时候当玩具玩坏了，而且macOS已经不支持<code>Virtual PC</code>了，<code>FloppyWriter</code>也仅仅是在Windows平台下能够运行。由此看来，书上的运行方法已经全部行不通了</p><a id="more"></a><p>但是<code>.img</code>镜像文件能在<code>VMware Fusion</code>中运行，因此我就想着有没有工具能够将<code>.bin</code>文件转换为<code>.img</code>文件，上网查了一下还真有，工具的名称叫<code>dd</code>，听起来很奇怪，但是这工具却很强大，能够将文件写入到镜像文件中。废话不多说，那就开始试试吧</p><h1 id="编译源文件"><a href="#编译源文件" class="headerlink" title="编译源文件"></a>编译源文件</h1><p>书中第一章最简单的<code>Hello world</code>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">org 07c00h ; 告诉编译器程序加载到07c00h处</span><br><span class="line">    mov ax, cs</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    call DispStr ; 调用显示字符串函数  </span><br><span class="line">    jmp $; 无限循环</span><br><span class="line"></span><br><span class="line">DispStr:</span><br><span class="line">    mov ax, BootMessge</span><br><span class="line">    mov bp, ax</span><br><span class="line">    mov cx, 16</span><br><span class="line">    mov ax, 01301h</span><br><span class="line">    mov bx, 000ch</span><br><span class="line">    mov dl, 0</span><br><span class="line">    int 10h</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">BootMessge: db &quot;hello, OS world!&quot;</span><br><span class="line">times 510 - ($ - $$) db 0; 剩余字节用0填充，一共512字节</span><br><span class="line">dw 0aa55h; 以这个地址结束，计算机认为是一个引导扇区</span><br></pre></td></tr></table></figure><p>编译一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure><p>这样子我们就得到了二进制格式的引导文件，接下来就是制作镜像了</p><h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><p>使用<code>dd</code>制作为镜像，<code>dd</code>本身有很多种参数，我们只需要定义输入和输出即可，其他参数默认就行了</p><blockquote><p>网上的教程思路是先将bin文件写入为img文件，每次写入操作的缓冲大小为512byte，写入到第一块扇区中。然后另外创建一块空的大小为1.44MB（标准软盘容量）的空镜像文件，每次执行写入缓冲的大小也是512byte，总共2880块扇区。最后将空镜像的第2到2880块扇区追加写入到刚刚写入的镜像文件中，这样子就做成了一张标准的软盘。但经过我的测试之后发现，不需要这么标准的操作，只需要把bin文件写成img文件就能在VMware中运行了</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=boot.bin of=boot.img</span><br></pre></td></tr></table></figure><p><img src="images/os/bintoimg.png" alt="写入镜像"></p><p>这样子我们就得到了一个镜像文件，接下来就可以放到虚拟机中运行测试了</p><h1 id="启动虚拟机，查看成果"><a href="#启动虚拟机，查看成果" class="headerlink" title="启动虚拟机，查看成果"></a>启动虚拟机，查看成果</h1><p>虚拟机的创建就不多说了，自定义的虚拟机不需要很高的配置，甚至硬盘都能去掉。我的虚拟机整体配置如下：</p><ul><li>客户机操作系统：其他</li><li>新硬盘：无（先创建后移除）</li><li>内存：32MB</li><li>网络连接：无（创建后移除网卡）</li><li>设备摘要：软盘（创建后移除CD/DVD和声卡，添加软盘）</li></ul><p>需要注意一点的就是，我们需要为虚拟机添加软盘设备，然后软盘的镜像选择我们刚刚制作的镜像</p><p><img src="images/os/vmconfig.png" alt="虚拟机配置"></p><p>启动虚拟机，看到以下界面，大功告成！</p><p><img src="images/os/boot.png" alt="启动界面"></p><p><strong>注意：在VMware中，书上所说的将<code>org</code>的跳转地址修改为<code>0100h</code>即进入Debug模式，这个方法在VMware中似乎不起作用，因此在后面参考书本源码时，我们需要将<code>org</code>跳转地址固定为<code>07c00h</code></strong></p><h1 id="一键转换脚本"><a href="#一键转换脚本" class="headerlink" title="一键转换脚本"></a>一键转换脚本</h1><p>每次从<code>asm</code>文件转换到<code>img</code>文件都会产生一个<code>bin</code>文件，并且输入的命令都颇为麻烦，因此我写了一个小小的脚本<code>AsmToImg.sh</code>，该脚本能帮我们将中间的过程省去，直接输出一个<code>img</code>文件</p><p>该脚本的仓库地址在<a href="https://github.com/FisherWY/Shell/blob/master/asmtoimg/AsmToImg.sh" target="_blank" rel="noopener">这里</a></p><p>用法：<code>./AsmToImg.sh [-h] source.asm</code></p><p>脚本会将<code>img</code>文件输出到与<code>source.asm</code>同一级目录中，并且自动将<code>bin</code>文件删除</p><p><img src="images/os/asmtoimg.png" alt="脚本演示"></p><h1 id="附：书本源码资源"><a href="#附：书本源码资源" class="headerlink" title="附：书本源码资源"></a>附：书本源码资源</h1><p>书中的源码其实是不全的，我看到第三章，尝试编译的时候才发现，作者把源码和FloppyWriter都放在随书光盘中了</p><p>书的年代久远，光盘早就弄丢了，找这本书的资源花了我好长时间，我把资源就放在我的服务器上吧，下载地址点<a href="http://fisher.lazybone.xyz/downloads/document/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《自己动手写操作系统》这本书，其中第一章有一段简单的引导代码。书中的指导是将源代码文件&lt;code&gt;.asm&lt;/code&gt;编译为二进制文件&lt;code&gt;.bin&lt;/code&gt;后写入到软盘中，然后启动运行；又或者是使用&lt;code&gt;FloppyWriter&lt;/code&gt;将二进制文件&lt;code&gt;.bin&lt;/code&gt;写为镜像文件&lt;code&gt;.img&lt;/code&gt;，再放到&lt;code&gt;Virtual PC&lt;/code&gt;中运行。由于年代久远，现在的电脑已经没有软盘位，遗留下来的软盘也早被我小时候当玩具玩坏了，而且macOS已经不支持&lt;code&gt;Virtual PC&lt;/code&gt;了，&lt;code&gt;FloppyWriter&lt;/code&gt;也仅仅是在Windows平台下能够运行。由此看来，书上的运行方法已经全部行不通了&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://fisher.lazybone.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MacOS改有线网IP地址</title>
    <link href="http://fisher.lazybone.xyz/macos%E6%94%B9%E6%9C%89%E7%BA%BF%E7%BD%91ip%E5%9C%B0%E5%9D%80.html"/>
    <id>http://fisher.lazybone.xyz/macos改有线网ip地址.html</id>
    <published>2019-11-28T08:22:16.000Z</published>
    <updated>2019-11-28T08:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>机房的无线网络一如既往的差，自带的电脑想要上网还得找根网线，连接电脑然后手动指定一下IP地址就好了。但是macOS下有时会遇到让人无语的问题：”无效的服务器地址BasicIPv6ValidationError”。这问题的意思就是手动指定的时候，IPV6地址合法性验证错误，我也没想着指定IPV6地址，留空都不行，关闭也不行😓</p><a id="more"></a><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>这时候没办法了，只能用终端直接改IP地址就好了</p><p>首先查看有线网络服务的名称</p><p><code>networksetup -listallnetworkservices</code></p><p>一般名称都为：<code>Ethernet</code></p><p>然后修改IP地址，第一个参数是网络服务的名称，第二个参数是IP地址，第三个参数是子网掩码，第四个参数是路由器地址</p><p><code>networksetup -setmanual &quot;Ethernet&quot; ${IP_Addr} ${Net_Mask} ${Router_Addr}</code></p><p>之后可以用<code>networksetup -getinfo &quot;Ethernet&quot;</code>查看修改是否成功</p><p>最后再在网络设置页面添加DNS服务器地址就OK了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;机房的无线网络一如既往的差，自带的电脑想要上网还得找根网线，连接电脑然后手动指定一下IP地址就好了。但是macOS下有时会遇到让人无语的问题：”无效的服务器地址BasicIPv6ValidationError”。这问题的意思就是手动指定的时候，IPV6地址合法性验证错误，我也没想着指定IPV6地址，留空都不行，关闭也不行😓&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://fisher.lazybone.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>中级软件实作总结</title>
    <link href="http://fisher.lazybone.xyz/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%AE%9E%E4%BD%9C%E6%80%BB%E7%BB%93.html"/>
    <id>http://fisher.lazybone.xyz/中级软件实作总结.html</id>
    <published>2019-11-26T08:34:01.000Z</published>
    <updated>2019-11-26T12:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>为期一周的中级软件实作结束了。这一周以来，我们跟着老师的步伐，前端使用Bootstrap，后端使用Express框架完成了一个购物商城注册、首页的页面和功能。整个项目的下载地址在<a href="http://fisher.lazybone.xyz/downloads/document/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%AE%9E%E4%BD%9C.zip">这里</a>（因为项目只做DEMO，因此就不放上GitHub了），以下是我关于这一周笔记的总结</p><h1 id="后端笔记总结"><a href="#后端笔记总结" class="headerlink" title="后端笔记总结"></a>后端笔记总结</h1><h2 id="我的观点"><a href="#我的观点" class="headerlink" title="我的观点"></a>我的观点</h2><p>这次的中级软件实作和以往不一样，我们首次使用了Node.JS作为后端开发语言，相比于老一代的后端开发语言<code>Java/PHP/.NET</code>，新生代的后端开发语言<code>Node.JS/GO/Python</code>语法更加简单，配置十分简易，上手难度低</p><a id="more"></a><p>我认为，新生代的后端语言能够用于中小型项目的开发，随着第三方库的发展，越来越多的人能够上手开发属于自己的小项目</p><p>对于大型的项目，我认为目前还是老一代后端开发语言比较适合，经历了这么长时间的技术沉淀，老一代后端开发语言已经形成了许多应用于不同场景的技术框架，稳定性可靠性相对较高，但对于新手来说，了解学习这些框架需要一定的时间</p><h2 id="关于Node-JS"><a href="#关于Node-JS" class="headerlink" title="关于Node.JS"></a>关于Node.JS</h2><p><code>Node.JS</code>不是前端框架，是后端技术，遵循<code>CommonJS</code>规范。可用于在特定场合下取代PHP、Java等技术，实现文件IO、网络访问、数据库操作等</p><p><strong><code>Node.JS</code>特点：</strong></p><ol><li>语法基于JavaScript，但是功能是后台技术，可以实现IO、Network、DB等操作</li><li>单线程模型，避免了多线程并发的问题</li><li>异步的回调函数，避免了线程阻塞的问题</li><li>适合于IO密集型应用，不合适于CPU密集型应用</li></ol><p><strong>创建<code>Node.JS</code>项目的基本步骤：</strong></p><ol><li>在项目根目录下使用<code>npm create</code>创建项目描述文件<code>package.json</code>和<code>package-lock.json</code></li><li>使用<code>npm install &lt;package&gt;</code>下载项目所需要的第三方包</li><li>代码的编写。如果是Web项目，需要创建Web服务器，监听端口，提供响应消息</li></ol><p><strong>一问一答：</strong></p><ul><li><p>为什么数据库中的日期要用<code>bigint</code>储存？</p><p>答：因为不同国家地区使用的日期制式和时区不一样，单纯地使用”Date”或”DateTime”会导致日期格式固定单一，不利于国际化</p></li></ul><p><strong>HTTP协议中，请求消息的格式：</strong></p><ul><li><p>GET请求：</p><p>请求参数放在<code>req.query</code>中，浏览器地址栏可见</p><p>GET <code>/url?para1=1&amp;para2=2</code> HTTP/1.1</p><p>Content-Type: xxx</p></li><li><p>POST请求：</p><p>请求参数放在<code>req.body</code>中，浏览器地址栏不可见</p><p>POST <code>/url</code> HTTP/1.1</p><p>Content-Type: xxx</p><p>para1=1&amp;para2=2</p></li></ul><p><strong>ES6中的部分新特性：</strong></p><ul><li>反引号字符串，字符串可以换行</li><li>使用<code>${}</code>替换变量</li></ul><h1 id="前端笔记总结"><a href="#前端笔记总结" class="headerlink" title="前端笔记总结"></a>前端笔记总结</h1><h2 id="我的观点-1"><a href="#我的观点-1" class="headerlink" title="我的观点"></a>我的观点</h2><p>上个学期的期末大作业中，我第一次用到了Bootstrap。当时的我也了解到了栅格系统，但是并不会使用Bootstrap CSS。我还是傻乎乎地自己手写CSS文件，一开始还能保证页面是响应式的，一切的样式都使用%，但随着页面越来越复杂，以及没有清除默认样式导致的各种奇怪的问题，后面的代码就写烂了。到现在回看当初写的代码，根本就不想去修改哪怕是一行代码，再联想一下企业开发中，历史遗留下来的HTML页面，那简直就是陨石坑。因此我认为，即使HTML是标记性语言，我们也应该用工程化的思想和方法，去制定一些编写的规范，搭建开发的框架。这样不仅能降低开发维护的难度和成本，还能延长项目的生命周期</p><h2 id="关于Bootstrap"><a href="#关于Bootstrap" class="headerlink" title="关于Bootstrap"></a>关于Bootstrap</h2><p><strong>前端可用的技术栈：</strong></p><ul><li>HTML/CSS/JS</li><li>Bootstrap/jQuery/AJAX</li><li>Vue.js/Vue-Router/MintUI/Axios</li><li>Angular.js/Router/lonic/HttpClient</li><li>React/React-Native/Fetch</li></ul><p><strong>响应式网页：</strong></p><ul><li>也称为自适应式网页，一个页面可以根据不同浏览器设备而呈现不同的布局和外观</li><li>所有的尺寸都使用相对值（%,em），而不是绝对值（px）</li><li>布局容器宽度使用百分比，内部都使用百分比，浮动或者是弹性的</li><li>图片宽度都使用<code>max-width:100%</code>，防止图片失真</li><li>使用<code>CSS3 Media Query（媒体查询技术）</code>，针对不同尺寸的设备使用不同尺寸的图片，以及不同的样式</li></ul><p><strong>网页尺寸的定义：</strong></p><ul><li>PC：&gt;=992px</li><li>Pad：768~992px</li><li>Phone：&lt;768px</li></ul><p><strong>对于大型页面的CSS，我们使用以下方法降低开发维护难度：</strong></p><ul><li>样式重置（CSS Reset）：Normalize.css，一个重置页面默认样式的CSS文件</li><li>样式脚手架，例如Bootstrap</li><li>栅格布局系统</li><li>常用组件的复用：轮播、下拉、弹框</li><li>当前页面专有的头部、主体、尾部</li></ul><p><strong>关于Bootstrap框架：</strong></p><ul><li><p>Bootstrap是一个由Twitter维护的CSS框架，可用于编写响应式网页</p></li><li><p>Bootstrap把屏幕分为4类：</p><p>lg：Large，size&gt;=1200px，适用于PC</p><p>md：Medium，992px&lt;=size&lt;1200px，适用于高分辨率平板电脑</p><p>sm：Small，768px&lt;=size&lt;992px，适用于平板电脑</p><p>xs：Extra Small，size&lt;768px，适用于手机屏幕</p></li><li><p>Bootstrap栅格系统的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container/container-fluid"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xx-x"</span>&gt;</span></span><br><span class="line">            内容或者".row" ".col-xx-x"</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>前后端都有一个共同的问题，那就是跨域请求的问题</p><ul><li><p>什么是跨域访问？</p><p>假设现在有2个资源：</p><ul><li>资源1: <a href="http://localhost:5500/index.html" target="_blank" rel="noopener">http://localhost:5500/index.html</a></li><li>资源2: <a href="http://localhost:8888/user/register" target="_blank" rel="noopener">http://localhost:8888/user/register</a></li></ul><p>浏览器中，如果访问的两个资源的<code>协议</code>、<code>主机名</code>或<code>端口号</code>三者之中只要有1项不同，就是跨域访问。注意：<code>localhost</code>和<code>127.0.0.1</code>是不同的域名，也属于跨域访问</p></li><li><p>默认情况下，有些内容默认允许跨域，如：<code>&lt;img&gt;、&lt;script&gt;、&lt;link&gt;、&lt;a&gt;</code></p></li><li><p>默认情况下，浏览器默认禁止XHR跨域访问</p></li><li><p>如何解决浏览器对XHR的跨域请求限制？（每种方法详细<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">解析</a>）</p><ul><li>JSONP</li><li>CORS</li><li>PostMessage</li><li>WebSocket</li><li>Node中间件代理</li><li>Nginx反向代理</li><li>window.name + iframe</li><li>location.hash + iframe</li><li>document.domain + iframe</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为期一周的中级软件实作结束了。这一周以来，我们跟着老师的步伐，前端使用Bootstrap，后端使用Express框架完成了一个购物商城注册、首页的页面和功能。整个项目的下载地址在&lt;a href=&quot;http://fisher.lazybone.xyz/downloads/document/%E4%B8%AD%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%AE%9E%E4%BD%9C.zip&quot;&gt;这里&lt;/a&gt;（因为项目只做DEMO，因此就不放上GitHub了），以下是我关于这一周笔记的总结&lt;/p&gt;&lt;h1 id=&quot;后端笔记总结&quot;&gt;&lt;a href=&quot;#后端笔记总结&quot; class=&quot;headerlink&quot; title=&quot;后端笔记总结&quot;&gt;&lt;/a&gt;后端笔记总结&lt;/h1&gt;&lt;h2 id=&quot;我的观点&quot;&gt;&lt;a href=&quot;#我的观点&quot; class=&quot;headerlink&quot; title=&quot;我的观点&quot;&gt;&lt;/a&gt;我的观点&lt;/h2&gt;&lt;p&gt;这次的中级软件实作和以往不一样，我们首次使用了Node.JS作为后端开发语言，相比于老一代的后端开发语言&lt;code&gt;Java/PHP/.NET&lt;/code&gt;，新生代的后端开发语言&lt;code&gt;Node.JS/GO/Python&lt;/code&gt;语法更加简单，配置十分简易，上手难度低&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习总结" scheme="http://fisher.lazybone.xyz/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
      <category term="JavaScript" scheme="http://fisher.lazybone.xyz/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hackintosh安装过程记录</title>
    <link href="http://fisher.lazybone.xyz/hackintosh%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.html"/>
    <id>http://fisher.lazybone.xyz/hackintosh安装过程记录.html</id>
    <published>2019-11-22T07:09:30.000Z</published>
    <updated>2019-11-24T13:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇的EFI文件准备工作完成之后，我们就可以正式开始装系统了。这篇博客用于记录我的安装过程以及安装过程中遇到的问题和解决方法</p><h1 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h1><p>首先我们需要准备一个8GB的U盘、macOS的镜像文件。我的镜像是从<code>黑果小兵</code>处下载的，他提供的镜像中自带了Clover，因此制作启动盘之后我们需要将自带的Clover替换掉</p><a id="more"></a><h2 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h2><p>我们使用<code>baleanEtcher</code>制作启动盘，这个软件界面界面简洁，操作也简单，分为3步：选择镜像，选择设备，写入镜像</p><p><img src="images/hackintosh/etcher.jpg" alt="Etcher"></p><h2 id="替换EFI"><a href="#替换EFI" class="headerlink" title="替换EFI"></a>替换EFI</h2><p>镜像写入完成之后，我们使用<code>Clover Configurator</code>挂载U盘的EFI分区，然后将其中的EFI文件替换。这样启动盘就制作完成了</p><p>挂载EFI分区：</p><p><img src="images/hackintosh/efi.png" alt="挂载EFI分区"></p><p>替换EFI文件夹，注意文件夹名字一定要一样：</p><p><img src="images/hackintosh/replaceefi.png" alt="替换EFI"></p><h1 id="Bios配置"><a href="#Bios配置" class="headerlink" title="Bios配置"></a>Bios配置</h1><p>Bios的配置参数我参考了网上的<code>华硕主板黑苹果设置</code>，如果你的主板没有某一项参数，忽略即可。具体配置如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Boot -- Fast Boot -&gt; Disabled</span><br><span class="line">Advanced -- PCH Sorage Configuration -- SATA Mode Selection -&gt; AHCI</span><br><span class="line">Boot -- CSM(Compatibility Support Module) -&gt; Disabled</span><br><span class="line">Ai Tweaker -- Ai Overclock Tuner -&gt; XMP</span><br><span class="line">Advanced -- CPU configuration -- Intel Virtualization Technology -&gt; Disabled</span><br><span class="line">Advanced --<span class="built_in"> System </span>Agent (SA) Configuration -- VT-D -&gt; Disabled</span><br><span class="line">Advanced --<span class="built_in"> System </span>Agent (SA) Configuration -- Above 4G Decoding -&gt; Disabled</span><br><span class="line">Advanced -- PCH configruation - IOAPIC 24-119 Entries -&gt; Enabled</span><br><span class="line">Advanced -- PCH-FW Configuration -- TPM Device Selection -&gt; Discrete TPM</span><br><span class="line">Advanced -- APM Configuration -- ErP Ready -&gt; Disabled</span><br><span class="line">Advanced --<span class="built_in"> Network </span>Stack Configuration --<span class="built_in"> Network </span>Stack -&gt; Disabled</span><br><span class="line">Advanced -- Advanced PCH Configuration --<span class="built_in"> system </span>time <span class="keyword">and</span> alarm source -&gt; Legacy RTC</span><br><span class="line">Boot -- Secure Boot -- OS<span class="built_in"> Type </span>-- Other OS</span><br></pre></td></tr></table></figure><h1 id="安装macOS"><a href="#安装macOS" class="headerlink" title="安装macOS"></a>安装macOS</h1><p>接下来就是macOS的安装了，开机按F8选择启动盘为U盘，就可以看到如下界面：</p><p><img src="images/hackintosh/cloverboot.jpeg" alt="Clover界面"></p><p>选择<code>Boot macOS Install from Install macOS High Sierra</code>，跑了一段代码之后就会进入安装系统的界面：</p><p><img src="images/hackintosh/macosinstall.jpeg" alt="安装界面"></p><p>先打开磁盘工具，将新硬盘格式化为<code>APFS</code>文件系统（这里我用U盘作为示例，自行选择要格式化的硬盘）：</p><p><img src="images/hackintosh/reformatdisk.jpeg" alt="格式化硬盘"></p><p>然后返回安装界面，点击安装。如果这时候报错<code>应用程序副本已损坏，不能用来安装macOS</code>：</p><p><img src="images/hackintosh/installerror.jpeg" alt="报错信息"></p><p>这是因为证书已经过期，我们需要把系统时间调早一些。首先我们需要断开网络连接，然后左上角找到<code>实用工具</code>，打开<code>终端</code>，然后输入<code>date 0101010119</code>，终端会输出修改后的系统时间。这时候关闭终端，可以继续系统的安装了</p><p><img src="images/hackintosh/date.jpeg" alt="调时间"></p><h1 id="安装WebDriver，修改CPU显示型号"><a href="#安装WebDriver，修改CPU显示型号" class="headerlink" title="安装WebDriver，修改CPU显示型号"></a>安装WebDriver，修改CPU显示型号</h1><p>系统安装好后，我们需要安装显卡驱动。显卡驱动的安装也是很简单，需要注意的一点就是系统的版本要和驱动的版本对应，否则可能会出现无法驱动导致的开机黑屏问题。在<a href="https://www.tonymacx86.com/nvidia-drivers/" target="_blank" rel="noopener">tonymacx86</a>上有对应的列表，找到对应版本的驱动下载安装就好了</p><p>我安装的是<code>macOS 10.13.6(17G65)</code>，对应的Web Driver版本是<code>387.10.10.10.40.105</code></p><p><img src="images/hackintosh/driver.png" alt="对应驱动"></p><p>最后一个小地方就是关于本机中，处理器的型号显示为<code>Unknown</code>。这里我参考了<a href="https://www.sqlsec.com/2018/09/cpu.html" target="_blank" rel="noopener">国光的博客</a>，将其修改为自己定义的字符串</p><p><img src="images/hackintosh/about.png" alt="修改CPU型号"></p><p>大功告成！以后负担重的任务就交给Hackintosh，老Macbook Pro就拿来写写博客，享受退休生活！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇的EFI文件准备工作完成之后，我们就可以正式开始装系统了。这篇博客用于记录我的安装过程以及安装过程中遇到的问题和解决方法&lt;/p&gt;&lt;h1 id=&quot;制作启动盘&quot;&gt;&lt;a href=&quot;#制作启动盘&quot; class=&quot;headerlink&quot; title=&quot;制作启动盘&quot;&gt;&lt;/a&gt;制作启动盘&lt;/h1&gt;&lt;p&gt;首先我们需要准备一个8GB的U盘、macOS的镜像文件。我的镜像是从&lt;code&gt;黑果小兵&lt;/code&gt;处下载的，他提供的镜像中自带了Clover，因此制作启动盘之后我们需要将自带的Clover替换掉&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://fisher.lazybone.xyz/tags/hackintosh/"/>
    
  </entry>
  
</feed>
