<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fisher&#39;s Blog</title>
  
  <subtitle>自由尋覓快樂別人從沒法感受</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fisheryung.top/"/>
  <updated>2022-06-21T08:49:45.355Z</updated>
  <id>http://www.fisheryung.top/</id>
  
  <author>
    <name>Fisher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSPP之旅（二）</title>
    <link href="http://www.fisheryung.top/ospp%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.fisheryung.top/ospp之旅（二）.html</id>
    <published>2022-06-21T07:42:04.000Z</published>
    <updated>2022-06-21T08:49:45.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开工的第一步当然是要搭建好工作环境。根据任务的描述，我们需要编译构建出<code>libvirt 8.2.0</code>RPM包，因此工作环境首先是要顺利完成源码编译的任务。因此本篇博客中，我们需要新建一个虚拟机，在虚拟机中安装<code>openEuler 22.03 LTS</code>，拉取<code>libvirt</code>库，根据<code>libvirt</code>的文档手动编译出<code>8.2.0</code>版本。</p><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>以下是编译前需要准备的东西，由于过于简单，就不详细说明如何搭建的：</p><ul><li>操作系统：<code>openEuler 22.03 LTS</code>，在虚拟机中安装，流程几乎和<code>CentOS</code>一样</li><li><code>Meson</code>：<code>libvirt 8.2.0</code>的构建工具，可以使用命令<code>sudo pip3 install meson</code>安装</li><li><code>Ninja</code>：<code>libvirt 8.2.0</code>的构建系统，可以使用命令<code>sudo pip3 install ninja</code>安装</li><li><code>Clangd</code>：<code>LLVM</code>推出的语法分析工具，使用<code>compile_commands.json</code>文件分析项目代码，配合VSCode的Clangd插件使用起来很舒服，照着官方文档安装即可，文档地址在<a href="https://clangd.llvm.org/installation" target="_blank" rel="noopener">这里</a></li><li><code>libvirt</code>其他依赖：好像还有xml什么的依赖，<code>meson build</code>检查依赖的时候会有日志的，提示缺什么包用<code>pip</code>照着安装就行了</li></ul><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="准备源码"><a href="#准备源码" class="headerlink" title="准备源码"></a>准备源码</h2><p>在Gitee上Fork<code>libvirt</code>仓库，地址在<a href="https://gitee.com/openeuler/libvirt" target="_blank" rel="noopener">这里</a>，并拉取到本地：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> git@gitee.com:wengyu1/libvirt.git</span><br></pre></td></tr></table></figure></p><p>从<code>8.2.0</code>的Tag创建新的分支，命名为<code>libvirt-8.2.0</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libvirt</span><br><span class="line">git branch libvirt-8.2.0 v8.2.0</span><br></pre></td></tr></table></figure></p><h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>官方的编译文档在<a href="https://libvirt.org/compiling.html" target="_blank" rel="noopener">这里</a>。由于我们不需要安装，因此我们直接编译构建即可，编译选项直接默认即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meson build</span><br><span class="line">ninja -C build</span><br></pre></td></tr></table></figure></p><p>顺利编译完成，速度还挺快的</p><p><img src="images/ospp/compile.png" alt="编译完成"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>将<code>build</code>文件夹中的<code>compile_commands.json</code>链接到项目根目录，<code>clangd</code>就会自动分析项目代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s `<span class="built_in">pwd</span>`/build/compile_commands.json `<span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>验证下编译的效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/tools</span><br><span class="line">./virsh --version</span><br></pre></td></tr></table></figure></p><p>效果如下图</p><p><img src="images/ospp/virsh.png" alt="运行效果"></p><p>至此，<code>libvirt</code>的源码编译完成了，下一步可以编写RPM spec文件，使用<code>rpmbuild</code>工具构建RPM包</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;开工的第一步当然是要搭建好工作环境。根据任务的描述，我们需要编译构建出&lt;code&gt;libvirt 8.2.0&lt;/code&gt;RPM包，因此工作环境首先是要顺利完成源码编译的任务。因此本篇博客中，我们需要新建一个虚拟机，在虚拟机中安装&lt;code&gt;openEuler 22.03 LTS&lt;/code&gt;，拉取&lt;code&gt;libvirt&lt;/code&gt;库，根据&lt;code&gt;libvirt&lt;/code&gt;的文档手动编译出&lt;code&gt;8.2.0&lt;/code&gt;版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OSPP" scheme="http://www.fisheryung.top/tags/ospp/"/>
    
      <category term="开源" scheme="http://www.fisheryung.top/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟化" scheme="http://www.fisheryung.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OSPP之旅（一）</title>
    <link href="http://www.fisheryung.top/ospp%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.fisheryung.top/ospp之旅（一）.html</id>
    <published>2022-06-18T03:08:14.000Z</published>
    <updated>2022-06-21T07:42:47.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>世界上有能够学到技术、提升协作能力、拿丰厚奖金这种“三全其美”的事情吗？在以前我是不相信的，但自从师兄介绍了开源之夏（OSPP）这种活动之后，我第一次知道世界上还有这样一种顶级的活动，鱼和熊掌二者竟可得兼！</p><p>简单地介绍下OSPP吧，这是一个由中科院软件研究所“开源软件供应链点亮计划”发起并长期支持的一项暑期开源活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进优秀开源软件社区的蓬勃发展，培养和发掘更多优秀的开发者。官网地址点<a href="https://summer-ospp.ac.cn/#/homepage" target="_blank" rel="noopener">这里</a>。</p><a id="more"></a><h1 id="申请过程"><a href="#申请过程" class="headerlink" title="申请过程"></a>申请过程</h1><h2 id="选定项目"><a href="#选定项目" class="headerlink" title="选定项目"></a>选定项目</h2><p>首先肯定是要选择自己想做的项目了，选择的角度可以有很多，每个人的情况不同，根据自己的情况自行选择，以下是我选取项目所考虑到的部分角度：</p><ul><li>以后想做什么：这肯定是首先要考虑的因素，我想要做一些更偏向于底层的东西，因为偏向于底层的东西更有技术挑战性。克服一个个困难，实现一个个新功能，这样的开发过程很有意思。</li><li>项目技术与自身的切合度：如果选取一个自己完全陌生的项目，从零开始学习，那么项目做起来的难度肯定是非常大的，所以需要考虑下自己目前所掌握的知识和技术，判断下学习某个项目大概需要的时间，难度是否能够接受。</li><li>社区情况：社区的情况同样也很重要，如果某个社区非常活跃，导师也非常渴望新鲜血液的加入，那么这个社区肯定是值得加入的。</li></ul><p>经过筛选后，我选择了<code>为openEuler操作系统引入libvirt 8.2.0版本</code>这个项目，该项目属于<code>openEuler</code>社区。欧拉社区可以说是国内非常活跃的开源社区了，各种高校活动、比赛、社区活动、开源活动源源不断。社区主要负责开发和维护国产操作系统<code>openEuler</code>，本来就对开发操作系统比较感兴趣的我，与欧拉社区可以算是完美切合了。</p><h2 id="简要了解项目内容"><a href="#简要了解项目内容" class="headerlink" title="简要了解项目内容"></a>简要了解项目内容</h2><p>根据项目简介和项目产出要求，可以得知该项目的简要工作内容是兼容适配新版本的<code>libvirt</code>，当前<code>openEuler</code>使用的<code>libvirt</code>版本为<code>6.2.0</code>，随着<code>qemu</code>、<code>kvm</code>等包的新功能引入，旧版本的<code>libvirt</code>不能很好地适配这些新功能，<code>libvirt</code>也是时候升级一下了。项目的任务就是适配<code>libvirt 8.2.0</code>版本，将<code>6.2.0</code>版本中添加的、欧拉系统独有的功能特性继续在<code>8.2.0</code>版本中支持。</p><p>项目的产出要求如下：</p><ul><li>基于<code>openEuler</code>操作系统构建<code>libvirt 8.2.0</code>RPM包</li><li>将<code>6.2.0</code>版本中的补丁回合到<code>8.2.0</code>版本中</li></ul><p>对于项目的评价：</p><ul><li>涉及到操作系统的虚拟化技术，我对此比较感兴趣</li><li>主要内容是分析补丁并适配，工作量不会很大</li><li>虽然工作量不大，但需要熟悉项目和对应的技术，是个学习新技术的好机会</li><li>涉及到了打补丁的操作，这也是Linux内核维护常用的方式</li><li>C语言项目经验+1</li></ul><h2 id="联系导师"><a href="#联系导师" class="headerlink" title="联系导师"></a>联系导师</h2><p>在对项目进行简要了解之后，接下来就是联系导师了，在给导师发的第一封邮件中，我问了几个关于项目的问题。下午5点发的邮件，当天晚上7点多导师就回信了，不得不说导师的回复效率还是很高的，给导师点个赞！导师详细地回答了我提问的几个问题，同时附上了微信号，我也是马上就加了导师的微信。导师在微信中提供了很多相关的学习资料和文档，让我获益匪浅。</p><p>当然，导师也是很忙的，我们不能稍微有点小问题就去问导师，导师日常工作是很忙的。学习过程中遇到问题后，首先要尝试问问搜索引擎，要善于运用搜索引擎。实在是找不到相关解答的，再去问导师。</p><h2 id="撰写申请书"><a href="#撰写申请书" class="headerlink" title="撰写申请书"></a>撰写申请书</h2><p>撰写申请书是项目申请过程中最关键的一环了，前期联系交流的再愉快，最终还是要看申请书的质量的，关于申请书怎么写，OSPP委员会给出了一些指导意见，我们照着指导意见来写就基本没有问题了。参考链接点<a href="https://summer-ospp.ac.cn/help/proj_apply/" target="_blank" rel="noopener">这里</a>，此外今年中选的项目申请书都公示了，想要看看别人的写的申请书可以去官网项目列表中看。</p><p>我的项目书结构如下：</p><ul><li>标题</li><li>目录</li><li>项目简要描述</li><li>实现方案</li><li>开发计划</li><li>未来期望</li></ul><p>申请书写完之后就可以发给导师看看，让导师给出一些修改的建议，导师说基本没有问题之后，就可以等着提交到系统中了。</p><h1 id="申请结果"><a href="#申请结果" class="headerlink" title="申请结果"></a>申请结果</h1><p>6月5日申请书提交截至，6月15日晚公布结果，这10天毫无疑问就是折磨。但好事多磨，公布中选名单之后，邮箱第一时间就收到了邮件，不负所望，正式中选！</p><p><img src="images/ospp/selected.png" alt="中选邮件"></p><p>接下来就是正式开工前的准备了，跟导师开个线上会议，讨论接下来需要做的工作，确认工作内容后，就可以愉快地开工咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;世界上有能够学到技术、提升协作能力、拿丰厚奖金这种“三全其美”的事情吗？在以前我是不相信的，但自从师兄介绍了开源之夏（OSPP）这种活动之后，我第一次知道世界上还有这样一种顶级的活动，鱼和熊掌二者竟可得兼！&lt;/p&gt;&lt;p&gt;简单地介绍下OSPP吧，这是一个由中科院软件研究所“开源软件供应链点亮计划”发起并长期支持的一项暑期开源活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进优秀开源软件社区的蓬勃发展，培养和发掘更多优秀的开发者。官网地址点&lt;a href=&quot;https://summer-ospp.ac.cn/#/homepage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OSPP" scheme="http://www.fisheryung.top/tags/ospp/"/>
    
      <category term="开源" scheme="http://www.fisheryung.top/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟化" scheme="http://www.fisheryung.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建CSGO服务器</title>
    <link href="http://www.fisheryung.top/docker%E6%90%AD%E5%BB%BAcsgo%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>http://www.fisheryung.top/docker搭建csgo服务器.html</id>
    <published>2022-05-26T11:05:26.000Z</published>
    <updated>2022-05-26T11:29:14.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久之前在简书上写过几篇博客，内容就是搭建属于自己的CSGO服务器，点击<a href="https://www.jianshu.com/u/a23466842ccc" target="_blank" rel="noopener">这里</a>可以进行考古。但是纯命令行的搭建方式有着以下几种缺点：</p><ul><li>搭建步骤繁琐：全程直接使用命令行搭建服务器，对于不熟悉Linux环境的新手并不友好</li><li>插件切换繁琐：想要服务器能够快速地切换不同的插件（回防、Multi 1v1、跑图、KZ等），每次手动操作Addons文件夹中的插件极其令人烦躁</li><li>硬盘空间珍贵：同样是插件切换繁琐引起的问题，当时用的是阿里云最便宜的云服务器，只有40G的硬盘，只能存一份服务器游戏文件，没有足够的空间存多份服务器游戏文件然后多开</li></ul><a id="more"></a><p>后来也尝试写了一个CSGO服务器一键安装脚本，但是效果也不好，不能从根本上解决快速切换插件的问题。最后经过了解并尝试使用Docker，终于解决了上述问题，服务器目前稳定使用了几个月，用起来非常愉快，是时候分享给有着同样需求的小伙伴了，Github仓库地址在<a href="https://github.com/FisherWY/Docker-CSGO" target="_blank" rel="noopener">这里</a>，懂哥可以直接看仓库README开始搭建，萌新建议还是看这篇博客，有些细节和README并不相同（如：没有使用pwd命令等）。目前本容器有着以下几个特点：</p><ul><li>一个容器关联一种插件：Docker可以创建不同的容器，将CSGO服务器的插件分别挂载到不同的容器中。通过容器的启动和停止，达到快速切换插件的目的</li><li>不影响服务器游戏文件：容器只向<code>csgo/cfg</code>文件夹中添加插件的配置文件，不涉及到其他文件的改动，插件配置出问题后直接删除容器，重新创建即可</li><li>（理论上）同时启动多个服务器：每个容器都是相对独立的运行环境，Mod从文件中加载后不会重新加载，也就是说启动一个容器后可以更换Mod去启动另一个容器，因此可以同时启动多个运行不同插件的服务器</li></ul><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>实现的核心思路主要是以下两点：挂载、软链接。如下图所示，服务器游戏文件、Steamcmd和Mod文件夹均挂载到容器中，容器在启动时将Mod文件夹中的<code>addons</code>文件夹链接到服务器游戏文件夹中的<code>csgo/addons</code>，相当于创建一个快捷方式，服务器在启动时就会从这个软连接跳转到对应的Mod文件夹中，去加载对应的插件，完成服务器的启动。</p><p><img src="images/csgo/docker/arch.png" alt="实现思路"></p><p>通过控制容器的启动和停止，我们能够快速地切换到不同功能的服务器，在高效地管理Mod的同时不影响到原本的游戏服务器文件。接下来的搭建教程分为简单的三步：Steamcmd和服务器的安装、Mod的下载解压和CFG文件夹链接、容器的启动。</p><h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>在开始之前，首先需要做以下准备：</p><ul><li><code>docker</code>和<code>docker-compose</code>：可以通过官网的文档安装（不用docker-compose也可以直接使用命令行创建和启动容器，仓库中的README有对应命令）</li><li>端口：每家的云服务器端口管理方案不同，需要开启27015端口的TCP和UDP，否则会出现服务器没有响应或无法连接等问题</li><li>系统：Ubuntu 20.04（其他发行版也可以，但是本人没有测试过）</li><li>Steam服务器登录令牌：服务器登录Steam所需要的令牌，没有令牌的话，启动的服务器不会显示在服务器列表中，可以点击<a href="https://steamcommunity.com/dev/managegameservers" target="_blank" rel="noopener">这里</a>申请令牌（CSGO的APPID为740）</li><li>Steam网页API：加载创意工坊地图需要使用的API密钥，可以点击<a href="http://steamcommunity.com/dev/apikey" target="_blank" rel="noopener">这里</a>注册一个</li><li>储备知识：默认小伙伴们会使用SSH连接服务器，并且懂得如何使用Vim、Linux基本命令，明白相对路径、绝对路径、用户权限的概念</li></ul><h1 id="安装Steamcmd和CSGO服务器"><a href="#安装Steamcmd和CSGO服务器" class="headerlink" title="安装Steamcmd和CSGO服务器"></a>安装Steamcmd和CSGO服务器</h1><ol><li>首先是拉取安装器镜像  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:installer</span><br></pre></td></tr></table></figure></li></ol><p><img src="images/csgo/docker/get_installer.png" alt="拉取安装器镜像"></p><ol start="2"><li>创建和启动安装器的容器<br>将Steamcmd和CSGO服务器的安装文件夹挂载到容器中，容器会自动将Steamcmd和CSGO服务器安装到挂载的文件夹中，同时将一些基本配置写入到服务器配置文件<code>csgo/cfg/server.cfg</code>中，写入的配置有以下几种：</li></ol><ul><li><code>STEAMACCOUNT</code>: Steam服务器登录令牌，参见准备阶段的描述</li><li><code>SERVER_HOSTNAME</code>: CSGO服务器名称，该名称显示在服务器列表中</li><li><code>RCON_PASSWORD</code>: CSGO服务器远程控制台连接密码，默认为<code>12345678</code></li><li><code>SV_PASSWORD</code>: CSGO服务器房间密码，默认为<code>12345678</code></li></ul><p>创建用于储存Steamcmd和CSGO服务器文件的挂载文件夹（文件夹路径和名称可以自定义，但需要记住路径）。个人习惯，本人喜欢把游戏相关的文件放到games文件夹中，由于我的用户名是<code>fisher</code>，所以我的steamcmd路径为<code>/home/fisher/games/steamcmd</code>，CSGO服务器路径为<code>/home/fisher/games/csgo-server</code>，这些路径都需要记住，等会挂载文件夹中需要用到。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir games &amp;&amp; <span class="built_in">cd</span> games</span><br><span class="line">mkdir steamcmd</span><br><span class="line">mkdir csgo-server</span><br></pre></td></tr></table></figure></p><p>创建一个<code>docker-compose</code>配置文件，用于配置将要创建的安装器容器，我将这份配置文件命名为<code>docker-csgo-installer.yaml</code>，储存路径为<code>home/fisher/games/docker-csgo-installer.yaml</code>。配置项如下，需要注意的地方有两个。第一个要注意的地方是<code>volumes</code>，表示要挂载的文件夹，需要将上面刚刚创建的两个文件夹路径写到冒号的前面。第二个要注意的地方是<code>environment</code>，也就是上面所说的服务器配置，根据自己的情况修改。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名: docker-csgo-installer.yaml</span></span><br><span class="line"><span class="comment"># docker-csgo:installer 的示例配置文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  csgo-installer:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">csgo-installer</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:installer</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/games/steamcmd:/steamcmd</span> <span class="comment"># 冒号前的挂载路径需要根据自己的配置改变，可以使用pwd命令查看当前路径</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/games/csgo-server:/csgo-server</span>   <span class="comment"># 挂载路径配置同上</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">STEAMACCOUNT=xxxxxxxxxx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SERVER_HOSTNAME=CSGOSERVER</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">RCON_PASSWORD=12345678</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">SV_PASSWORD=12345678</span></span><br></pre></td></tr></table></figure></p><p>使用<code>docker-compose</code>创建和启动容器（注意：仓库README中使用了<code>-d</code>参数，使容器在后台运行，在此不用<code>-d</code>参数的目的是让萌新能看到Steamcmd和CSGO服务器的安装进度），随后便能够看到安装进度，耐心等待容器运行结束并自动退出即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose -f docker-csgo-installer.yaml up</span><br></pre></td></tr></table></figure></p><p><img src="images/csgo/docker/installer_up.png" alt="安装进度"></p><p><strong>注意：服务器在下载过程中可能会跑满带宽，导致SSH连接卡住不动或者直接断开连接，不用担心，容器还是在后台运行中的，耐心等待就可以了。</strong><br>如果有跟我一样断开SSH连接的小伙伴，可以重新连接并使用<code>sudo docker ps -a</code>命令查看所有容器状态，如下图所示，STATUS为UP表示容器正在运行中。可以使用命令<code>sudo docker logs csgo-installer --tail=50</code>查看容器最新的日志，下图中可以看到下载的进度。</p><p><img src="images/csgo/docker/installer_status.png" alt="安装器状态和日志"></p><h1 id="创建和启动无Mod的CSGO服务器"><a href="#创建和启动无Mod的CSGO服务器" class="headerlink" title="创建和启动无Mod的CSGO服务器"></a>创建和启动无Mod的CSGO服务器</h1><p>如果需要创建和启动有Mod的CSGO服务器，直接跳到下一节。  </p><ol><li>首先是拉取无Mod的CSGO服务器容器镜像  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:origin</span><br></pre></td></tr></table></figure></li></ol><p><img src="images/csgo/docker/get_origin.png" alt="拉取无Mod版本镜像"></p><ol start="2"><li>创建和启动无Mod的CSGO服务器<br>同样将Steamcmd和CSGO服务器文件夹挂载到容器中，同时需要自定义一些启动参数，目前支持的参数有以下几种：</li></ol><ul><li><code>PORT</code>: 服务器端口，默认为<code>27015</code>，本样例中没有设置该参数(懂的可自行修改，同时需要设置容器的端口映射)</li><li><code>TICKRATE</code>: 服务器的Tickrate，可以设置为<code>64</code>或<code>128</code>，默认为<code>128</code></li><li><code>GAMETYPE</code>: 游戏类型和游戏模式设置(休闲、竞技、死斗)，默认为<code>0</code>，想要启动其他模式可以参考<a href="https://developer.valvesoftware.com/wiki/Counter-Strike:_Global_Offensive_Dedicated_Servers#Starting_the_Server" target="_blank" rel="noopener">这里</a></li><li><code>GAMEMODE</code>: 游戏类型和游戏模式设置(休闲、竞技、死斗)，默认为<code>0</code>，想要启动其他模式可以参考<a href="https://developer.valvesoftware.com/wiki/Counter-Strike:_Global_Offensive_Dedicated_Servers#Starting_the_Server" target="_blank" rel="noopener">这里</a></li><li><code>MAPGROUP</code>: 游戏地图组设置，默认为<code>mg_active</code></li><li><code>MAP</code>: 游戏地图设置，默认为<code>de_dust2</code></li></ul><p>创建<code>docker-compose</code>配置文件，用于配置将要启动的CSGO服务器，我将这份配置文件命名为<code>docker-origin.yaml</code>，储存路径为<code>/home/fisher/games/docker-origin.yaml</code>。<code>volumes</code>的配置与上面的安装器配置文件一致，<code>environment</code>是服务器的启动参数，可以根据自己的需要进行修改。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名: docker-origin.yaml</span></span><br><span class="line"><span class="comment"># docker-csgo:origin 的示例配置文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  csgo-origin:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">csgo-origin</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:origin</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span>  <span class="comment"># 需要多开的伙伴可以指定端口映射</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/games/steamcmd:/steamcmd</span> <span class="comment"># 冒号前的挂载路径需要根据自己的配置改变，可以使用pwd命令查看当前路径</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/games/csgo-server:/csgo-server</span>   <span class="comment"># 同上</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TICKRATE=128</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">GAMETYPE=0</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">GAMEMODE=0</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MAPGROUP=mg_active</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MAP=de_mirage</span></span><br></pre></td></tr></table></figure></p><p>使用<code>docker-compose</code>创建和启动容器，此时容器将在后台启动。关于如何连接服务器、更新服务器和停止服务器，跳转到最后一节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose -f docker-origin.yaml up -d</span><br></pre></td></tr></table></figure></p><p><img src="images/csgo/docker/start_origin.png" alt="启动无MOD的CSGO服务器"></p><h1 id="创建和启动有Mod的CSGO服务器"><a href="#创建和启动有Mod的CSGO服务器" class="headerlink" title="创建和启动有Mod的CSGO服务器"></a>创建和启动有Mod的CSGO服务器</h1><p>在此以<a href="https://github.com/splewis/csgo-multi-1v1" target="_blank" rel="noopener">Multi-1v1</a>插件为例子，同时使用到了插件和创意工坊地图，在使用创意工坊地图之前，首先要去获取一个Steam网页API密钥，详细参见准备阶段。</p><ol><li>首先是拉取有Mod的CSGO服务器容器镜像  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:mods</span><br></pre></td></tr></table></figure></li></ol><p><img src="images/csgo/docker/get_mods.png" alt="拉取有Mod版本镜像"></p><ol start="2"><li><p>创建插件文件夹，下载所需要的插件<br>需要的插件有：<code>mmsource</code>，<code>sourcemod</code>，<code>multi-1v1</code>。注意，该操作依旧是在<code>/home/fisher/games</code>文件夹中，小伙伴们需要注意自己的当前的路径，做出相应的修改。注意，有些小伙伴下载速度可能会很慢，可能需要配合上网技巧。同时，有些插件的压缩包格式为zip，需要注意这些后缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir mods &amp;&amp; <span class="built_in">cd</span> mods</span><br><span class="line">mkdir 1v1 &amp;&amp; <span class="built_in">cd</span> 1v1</span><br><span class="line">wget --no-check-certificate -O mmsource.tar.gz https://mms.alliedmods.net/mmsdrop/1.11/mmsource-1.11.0-git1145-linux.tar.gz</span><br><span class="line">wget --no-check-certificate -O sourcemod.tar.gz https://sm.alliedmods.net/smdrop/1.10/sourcemod-1.10.0-git6537-linux.tar.gz</span><br><span class="line">wget --no-check-certificate -O plugin.zip https://github.com/splewis/csgo-multi-1v1/releases/download/1.1.10/multi1v1_1.1.10.zip</span><br></pre></td></tr></table></figure></li><li><p>链接CSGO服务器的CFG文件夹<br><strong>注意：这是关键一步。</strong><br>在解压刚刚下载的所有插件之前，我们需要先将服务器中的CFG文件夹链接到插件文件夹中，保证随后解压的插件配置文件都解压到服务器的CFG文件夹中。注意链接的路径需要根据自己的情况修改，链接之后在1v1文件夹中可以看到一个cfg的软链接，该软链接指向CSGO服务器文件夹中的CFG文件夹，表示操作成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/fisher/games/csgo-server/csgo/cfg/ /home/fisher/games/mods/1v1/cfg</span><br></pre></td></tr></table></figure></li></ol><p><img src="images/csgo/docker/link.png" alt="查看软链接"></p><ol start="4"><li>解压插件<br>注意此时的工作路径应为：<code>/home/fisher/games/mods/1v1</code>，有些插件压缩包格式为zip，需要使用unzip解压。解压后的Mod文件夹结构如下图所示，插件的CFG配置文件均解压到CSGO服务器文件夹中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxkf mmsource.tar.gz</span><br><span class="line">tar zxkf sourcemod.tar.gz</span><br><span class="line">unzip -o plugin.zip</span><br></pre></td></tr></table></figure></li></ol><p><img src="images/csgo/docker/unzip.png" alt="解压完成"></p><ol start="5"><li>创建和启动有Mod的CSGO服务器<br>与无Mod的CSGO服务器镜像不同，有Mod的CSGO服务器镜像有部分不同的意义的参数：</li></ol><ul><li><code>MAPGROUP</code>: 创意工坊地图合集，管理游戏结束后投票下一张地图的菜单，想用官方地图组可以直接改为<code>mg_active</code>或其他</li><li><code>MAP</code>: 创意工坊地图ID，想用官方图可以直接改为<code>de_dust2</code>或其他</li><li><code>AUTHKEY</code>: Steam网页API密钥，使用创意工坊地图时要用，如果只需要启动官方地图，则设置为<code>NONE</code>即可</li></ul><p>返回到路径<code>/home/fisher/games</code>。创建<code>docker-compose</code>配置文件，用于配置将要启动的CSGO服务器，我将这份配置文件命名为<code>docker-1v1.yaml</code>，储存路径为<code>/home/fisher/games/docker-1v1.yaml</code>。<code>volumes</code>的配置除了挂载Steamcmd和CSGO服务器文件夹外，还需要挂载Mod文件夹，<code>environment</code>是服务器的启动参数，可以根据自己的需要进行修改。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名: docker-1v1.yaml</span></span><br><span class="line"><span class="comment"># docker-csgo:mods 的示例配置文件</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  csgo-1v1:</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">csgo-1v1</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/fisheryung/docker-csgo:mods</span></span><br><span class="line"><span class="attr">    network_mode:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/steamcmd:/steamcmd</span> <span class="comment"># 冒号前的挂载路径需要根据自己的配置改变，可以使用pwd命令查看当前路径</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/csgo-server:/csgo-server</span>   <span class="comment"># 同上</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/home/fisher/1v1:/mod</span>   <span class="comment"># 注意这里把要启动的插件对应的文件夹挂载上</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TICKRATE=128</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">GAMETYPE=0</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">GAMEMODE=0</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MAPGROUP=279177557</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">MAP=279708083</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">AUTHKEY=xxxxxxxxxx</span></span><br></pre></td></tr></table></figure></p><p>使用<code>docker-compose</code>创建和启动容器，此时容器将在后台启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose -f docker-1v1.yaml up -d</span><br></pre></td></tr></table></figure></p><p><img src="images/csgo/docker/start_mods.png" alt="启动有Mod的CSGO服务器"></p><h1 id="连接、启动、停止、切换服务器"><a href="#连接、启动、停止、切换服务器" class="headerlink" title="连接、启动、停止、切换服务器"></a>连接、启动、停止、切换服务器</h1><ol><li>连接服务器<br>我建议小伙伴们将服务器添加到自己的收藏夹中，方便每次连接，并且这种方法不区分国服或国际服。<br>打开Steam，点击左上角的<code>查看</code>，点击<code>服务器</code>，将会弹出一个服务器列表窗口，点击窗口中的<code>收藏夹</code>，点击右下角的<code>添加服务器</code>。</li></ol><p><img src="images/csgo/docker/servers.png" alt="将服务器添加到收藏夹"></p><p>将自己的服务器IP地址填入或者将自己的域名填入，点击<code>在此地址上寻找游戏</code>，如果你的服务器端口不是默认的27015，则需要加上端口号再寻找游戏，点击<code>将选定的游戏服务器添加至收藏夹</code>，就能在收藏夹中收藏自己的服务器了，双击服务器连接，输入服务器密码就能进入服务器了。</p><p><img src="images/csgo/docker/add_server.png" alt="将服务器添加到收藏夹"></p><ol start="2"><li>启动、停止、切换服务器<br>使用Docker启动、停止、切换服务器非常简单。首先使用命令<code>sudo docker ps -a</code>查看目前启动了哪一个服务器，如下图所示，我启动的是带有1v1插件的单挑服务器。切换到储存有<code>docker-compose</code>配置文件的文件夹，我的文件夹路径是<code>/home/fisher/games</code>，然后使用命令<code>sudo docker-compose -f docker-1v1.yaml down</code>停止容器，容器停止后会自动移除，再次使用<code>sudo docker ps -a</code>查看就看不到csgo-1v1的容器存在了。</li></ol><p><img src="images/csgo/docker/stop_server.png" alt="停止服务器"></p><p>然后启动服务器的方法和上面一样，我这里启动的是原版无Mod的服务器，命令为<code>sudo docker-compose -f docker-origin.yaml up -d</code>。服务器列表中会暂时显示服务器无响应，等一阵子服务器启动好之后，就能连接进入了。</p><p><img src="images/csgo/docker/start_server.png" alt="启动服务器"></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol><li><p>如何判断<code>docker-csgo:installer</code>正确完成了安装？<br>查看<code>steamcmd</code>和<code>csgo-server</code>文件夹中是否有文件，如果有文件且安装器容器已经停止，可以认为正确完成了安装。查看安装过程中容器的日志可以使用命令<code>sudo docker logs csgo-installer --tail=50</code></p></li><li><p>如何更改服务器的名称、密码、RCON密码等其他配置？<br>可以编辑<code>server.cfg</code>文件，容器只配置了部分启动参数，更多的参数可以通过这个文件配置，以我的配置，文件路径为: <code>/home/fisher/games/csgo-server/csgo/cfg/server.cfg</code></p></li><li><p>使用创意工坊地图后，服务器启动速度很慢？<br>使用创意工坊地图和创意工坊地图合集后，服务器启动时需要下载这些地图，这需要看服务器所在的地区，某些地区需要使用特殊方式才能下载成功</p></li><li><p>服务器空闲一段时间后，重新连接很慢？<br>服务器中没有玩家后，一段时间后会挂起，此时客户端重新连接，服务器需要重新启动一次，耐心等待即可</p></li><li><p>连接服务器后马上回弹到主界面，控制台显示<code>server is running on an older version</code>？<br>服务器运行的还是旧版CSGO，重新启动容器就能自动更新了。命令行重启: <code>sudo docker restart csgo-origin</code>，<code>docker-compose</code>重启: <code>sudo docker-compose -f docker-csgo-origin.yaml restart -d</code></p></li><li><p>可以同时启动多个容器吗？<br>理论上，使用不同的端口是可以同时启动多个容器的，但可能存在一个Steam Account(固定在<code>server.cfg</code>中，并没有使用参数化启动的配置)只能启动一个服务器的限制。由于本仓库的初衷是一份服务器游戏文件+多份Mod的快捷切换和管理，因此本人没有尝试过同时启动多个容器，有兴趣的朋友可以试一下</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很久之前在简书上写过几篇博客，内容就是搭建属于自己的CSGO服务器，点击&lt;a href=&quot;https://www.jianshu.com/u/a23466842ccc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;可以进行考古。但是纯命令行的搭建方式有着以下几种缺点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;搭建步骤繁琐：全程直接使用命令行搭建服务器，对于不熟悉Linux环境的新手并不友好&lt;/li&gt;
&lt;li&gt;插件切换繁琐：想要服务器能够快速地切换不同的插件（回防、Multi 1v1、跑图、KZ等），每次手动操作Addons文件夹中的插件极其令人烦躁&lt;/li&gt;
&lt;li&gt;硬盘空间珍贵：同样是插件切换繁琐引起的问题，当时用的是阿里云最便宜的云服务器，只有40G的硬盘，只能存一份服务器游戏文件，没有足够的空间存多份服务器游戏文件然后多开&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://www.fisheryung.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="服务器配置" scheme="http://www.fisheryung.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker" scheme="http://www.fisheryung.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Git同步开发机与开发服务器的代码</title>
    <link href="http://www.fisheryung.top/%E4%BD%BF%E7%94%A8git%E5%90%8C%E6%AD%A5%E5%BC%80%E5%8F%91%E6%9C%BA%E4%B8%8E%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BB%A3%E7%A0%81.html"/>
    <id>http://www.fisheryung.top/使用git同步开发机与开发服务器的代码.html</id>
    <published>2021-12-25T02:06:08.000Z</published>
    <updated>2021-12-25T02:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发机上开发完成一个小版本的开发之后，需要将代码部署到开发服务器上，但由于代码仍在测试中，可能需要频繁修改代码，每次打包都会显得很麻烦，而每次手动将修改的代码复制到服务器上更是低效的做法，因此想到了用Git的钩子来解决这个痛点，下面是具体的操作。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先是在开发机和服务器上都安装Git，我使用的Git版本如下：</p><a id="more"></a><ul><li>Windows开发机：<code>git version 2.33.0.windows.2</code></li><li>Linux开发服务器：<code>git version 2.17.1</code></li></ul><p>其次是配置本机的SSH密钥，生成密钥的命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa<span class="comment"># 一路回车即可</span></span><br></pre></td></tr></table></figure><p>然后将公钥复制到服务器的<code>~/.ssh/authorized_keys</code>文件上，当SSH连接服务器不需要输入密码时，表示这项配置成功，具体是怎么配置的这里就不说明了，上网查查大把教程。</p><h1 id="服务器的配置"><a href="#服务器的配置" class="headerlink" title="服务器的配置"></a>服务器的配置</h1><p>首先是建立一个Git裸库，用于保存提交信息，仓库建立的位置和名字可以自行修改，但需要记住，等会要用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git init --bare repo.git</span><br></pre></td></tr></table></figure><p>接着建立一个空文件夹，用于存放从开发机同步过来的代码，文件夹创建的位置和名字可自行修改，但需要记住，也是要用的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir code</span><br></pre></td></tr></table></figure><p>然后编写Git的Hooks脚本，这里用的是<code>post-receive</code>脚本，该脚本在仓库发生提交后自动执行，我们使用该脚本将仓库中最新的代码同步到代码文件夹中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/repo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>将以下语句写入钩子文件中，其中的两个路径，第一个是同步代码的文件夹所在位置，第二个是仓库的位置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/home/fisher/code --git-dir=/home/fisher/repo.git checkout -f</span><br></pre></td></tr></table></figure><p>保存退出vim后，赋予该脚本执行权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /home/fisher/repo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>至此，服务器端的配置完成，接下来是开发机的配置。</p><h1 id="开发机的配置"><a href="#开发机的配置" class="headerlink" title="开发机的配置"></a>开发机的配置</h1><p>如果开发机的项目不是Git项目，则需要进入项目的根目录，执行以下命令初始化为Git项目并提交一下，如果已经是Git项目，则这一步跳过，直接添加远程仓库地址即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commmit -m <span class="string">"Initial commit"</span></span><br></pre></td></tr></table></figure><p>接着添加远程仓库地址，其中<code>USER</code>表示你在服务器上使用的用户，<code>ADDRESS</code>表示服务器的地址，<code>:</code>接服务器上仓库的地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin USER@ADDRESS:/home/fisher/repo.git</span><br></pre></td></tr></table></figure><p>使用以下命令查看远程仓库地址的添加是否成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>添加远程仓库地址之后，将代码提交到仓库中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>至此，开发机的配置也完成了，需要同步的时候，就用Git将代码提交到远程仓库即可。</p><h1 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h1><p>提交代码之后，在服务器的<code>~/code/</code>文件夹中应该能看到与开发机项目相同的目录结构，这时候就能够直接在服务器上部署测试的代码了，当本地开发机代码修改之后，使用Git提交到远程仓库，开发服务器上的代码也会同步修改了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开发机上开发完成一个小版本的开发之后，需要将代码部署到开发服务器上，但由于代码仍在测试中，可能需要频繁修改代码，每次打包都会显得很麻烦，而每次手动将修改的代码复制到服务器上更是低效的做法，因此想到了用Git的钩子来解决这个痛点，下面是具体的操作。&lt;/p&gt;&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;首先是在开发机和服务器上都安装Git，我使用的Git版本如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器配置" scheme="http://www.fisheryung.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="学习总结" scheme="http://www.fisheryung.top/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>将SVN托管的SSH项目导入到IDEA中——以Scholat为例</title>
    <link href="http://www.fisheryung.top/%E5%B0%86svn%E6%89%98%E7%AE%A1%E7%9A%84ssh%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E5%88%B0idea%E4%B8%AD.html"/>
    <id>http://www.fisheryung.top/将svn托管的ssh项目导入到idea中.html</id>
    <published>2021-12-23T14:42:33.000Z</published>
    <updated>2021-12-23T15:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于要整合Scholat主站和Scholat+站点的资源，汤老师向我们提出了做单点登录的需求，因此需要对主站的登录功能部分做出改动。但主站项目是一个老项目，用的是SSH架构，没有Maven包管理，代码托管在SVN上，老师兄们用的都是MyEclipse开发，对于我这种人来说绝对忍不了，一定要用Intelij IDEA开发。经过一晚上的摸爬滚打和师兄的指点迷津后，现将导入的过程记录为文档，为以后师弟师妹的开发维护铺平道路。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先需要准备以下的工具和对应的版本：</p><ul><li>Intelij IDEA Ultimate Edition 2021.2.1（旗舰版IDE，功能齐全，相比于师兄的旧版IDEA，导入过程中多了一些自动配置项，方便一些，下载地址点<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows" target="_blank" rel="noopener">这里</a>）</li><li>Tortoise Subversion（SVN工具，下载地址点<a href="https://tortoisesvn.net/downloads.html" target="_blank" rel="noopener">这里</a>）</li><li>Apache Tomcat 7.0.82（Web容器，与主站使用的版本对应，8以上的不兼容JDK6，建议直接用这个版本，下载地址点<a href="https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.82/bin/" target="_blank" rel="noopener">这里</a>）</li><li>Java JDK6（需要注册一个Oracle账号，下载地址点<a href="https://www.oracle.com/java/technologies/javase-java-archive-javase6-downloads.html" target="_blank" rel="noopener">这里</a>）</li></ul><p>以上工具下载完成后安装，记住自己选择的安装路径。</p><h1 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h1><p>打开IDEA，在欢迎界面右上角点击<code>Get from VCS</code>。</p><p><img src="images/idea/get_from_vcs.png" alt="Get From VCS"></p><p>版本控制工具选<code>Subversion</code>，点击下面<code>+</code>号，输入仓库地址，账号密码找华哥要，<strong>选择记住账号密码</strong>（一定要记住账号密码，否则跑不起来的，项目会检查SVN配置），添加之后就能看到下图中的一个仓库地址了。</p><p><img src="images/idea/svn.png" alt="SVN"></p><p>点击<code>Check out</code>后，选择一个项目的存放地址，就开始拉取源码了。代码拉取完成后IDEA会自动打开项目，并提示发现了一个IDEA的配置文件，是否重复使用，这里我们点否，毕竟是别人的配置文件，这里我们不能照搬使用。</p><p>等项目索引完之后，关闭项目，打开项目存放的文件夹，将文件夹中的<code>.idea和trunk.iml</code>删掉，并将该项目从IDEA中移除（不是删除项目文件夹）。</p><p><img src="images/idea/delete_profile.png" alt="删除配置文件"></p><p><img src="images/idea/delete_project.png" alt="删除项目"></p><p>随便打开另外一个项目，在左上角选择<code>File -&gt; New -&gt; Project from Existing Sources</code>，导入刚刚拉取的代码。</p><p><img src="images/idea/import_project.png" alt="导入项目"></p><p>第一步直接选择<code>Create project from existing sources</code>，然后Next。</p><p><img src="images/idea/step1.png" alt="第一步"></p><p>第二步也不用改，除非想换个项目名称，然后Next。</p><p><img src="images/idea/step2.png" alt="第二步"></p><p>第三步，接着IDEA会扫描项目，并自动标记项目文件夹的类型，聪明的IDEA一般不会标记错的，这里选择<code>Mark All</code>，然后Next。</p><p><img src="images/idea/step3.png" alt="第三步"></p><p>第四步，IDEA会扫描依赖库文件夹，并自动添加为依赖库，如果这里搞不懂项目用到了哪些依赖的话，建议全部勾选，然后Next。</p><p><img src="images/idea/step4.png" alt="第四步"></p><p>第五步，也是跟项目依赖有关，直接按照IDEA给出的意见即可，点击Next。</p><p><img src="images/idea/step5.png" alt="第五步"></p><p>第六步，选择项目使用的JDK，这里我们选择刚刚安装JDK6，然后点Next。</p><p><img src="images/idea/step6.png" alt="第六步"></p><p>第七步，IDEA会扫描项目使用的框架，然后标记框架的配置文件，这里全部勾选即可，然后点Finish。</p><p><img src="images/idea/step7.png" alt="第七步"></p><p>到此，项目的导入部分到此完成，下一节中将介绍如何配置项目。</p><h1 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h1><h2 id="配置Project-Structure"><a href="#配置Project-Structure" class="headerlink" title="配置Project Structure"></a>配置Project Structure</h2><p>点击<code>File -&gt; Project Structure</code>，打开项目配置。</p><p>在Project页面确认使用的JDK版本为6，编译语言等级与JDK版本一致为6。</p><p><img src="images/idea/project.png" alt="Project配置"></p><p>在Modules页面，将conf文件夹标记为源码文件夹。</p><p><img src="images/idea/modules_sources.png" alt="Mudules页面"></p><p>在Libraries页面，将Tomcat中的<code>js-api.jar和servlet-api.jar</code>包添加到依赖库中，这两个包在Tomcat7安装路径的<code>./lib</code>目录下。</p><p><img src="images/idea/libraries.png" alt="Libraries页面"></p><p>在Facts页面，正常情况下，IDEA在导入时就已经自动配置好了，如果没有看到<code>Web</code>这项配置可以手动添加一下，因为还没有创建Artifacts，所以有个警告也是正常的。</p><p><img src="images/idea/facts.png" alt="Facts页面"></p><p>在Artifacts页面，点击<code>+ -&gt; WebApplication:Exploded -&gt; From modules...</code>，选择本项目配置好的Modules，点击OK。</p><p><img src="images/idea/Artifacts.png" alt="Artifacts页面"></p><p>项目有关的配置到此为止，接下来时配置启动项目的容器Tomcat</p><h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p>点击IDEA界面右上角的<code>Add Configuration</code>，打开运行配置</p><p>在Server页面中点击<code>+ -&gt; Tomcat Server -&gt; Local</code>，名字自定义一个，点击Application server右边的Configure按钮，选择准备工作中下载的Tomcat7的解压位置。</p><p><img src="images/idea/tomcat1.png" alt="Tomcat配置1"></p><p>继续在Server页面中找到VM options，填入以下参数：<code>-Xms1024m -Xmx4096m -XX:PermSize=4096m -XX:MaxPermSize=4096m</code>。该参数防止Tomcat内存太小导致项目跑不起来。</p><p><img src="images/idea/tomcat2.png" alt="Tomcat配置2"></p><p>在Deployment页面中，点击<code>+ -&gt; Artifact</code>，将项目添加到容器中，同时Application context一定要改为<code>/scholat</code>。</p><p><img src="images/idea/tomcat3.png" alt="Tomcat配置3"></p><p>至此，所有的配置工作均已完成，尝试编译运行一下。</p><h1 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h1><p>点击小锤子编译，看看有没有编译出错等问题，如果没有问题，点击运行跑起来看看效果。</p><p><img src="images/idea/button.png" alt="按钮"></p><p>如果电脑配置不是很好的话，需要耐心等待一下，毕竟这项目还挺大的。</p><p><img src="images/idea/build.png" alt="编译"></p><p>编译没有错误的话，就可以启动容器看看能不能跑起来了，跑起来也需要耐心等待一下，要启动的东西还挺多的。</p><p><img src="images/idea/deploy.png" alt="运行"></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>如果Tomcat运行输出的是乱码，则需要修改一下Tomcat的日志输出编码，打开Tomcat目录中的<code>conf/logging.properties</code>文件，将所有<code>UTF-8</code>全部改为<code>GBK</code>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于要整合Scholat主站和Scholat+站点的资源，汤老师向我们提出了做单点登录的需求，因此需要对主站的登录功能部分做出改动。但主站项目是一个老项目，用的是SSH架构，没有Maven包管理，代码托管在SVN上，老师兄们用的都是MyEclipse开发，对于我这种人来说绝对忍不了，一定要用Intelij IDEA开发。经过一晚上的摸爬滚打和师兄的指点迷津后，现将导入的过程记录为文档，为以后师弟师妹的开发维护铺平道路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.fisheryung.top/tags/java/"/>
    
      <category term="学习总结" scheme="http://www.fisheryung.top/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt的DDNS配置</title>
    <link href="http://www.fisheryung.top/openwrt%E7%9A%84ddns%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.fisheryung.top/openwrt的ddns配置.html</id>
    <published>2021-08-06T03:27:28.000Z</published>
    <updated>2021-08-06T06:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近着手改造家里的网络，买了一个D2550软路由，把家里的光猫由拨号改成了桥接，并使用D2550拨号和管理家里的网络。很久之前就向电信申请了公网IP，一直没用上，此次趁着网络改造，顺带给这个公网IP配置DDNS，利用起来并为后续NAS的搭建提供外网访问的环境。</p><h1 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h1><p>首先是需要有一个域名，在阿里云购买一个域名非常简单，填写实名制模版，使用模版购买域名即可，现在好像不需要背景布拍照上传手持身份证的照片了，跟以前相比简直太方便了，这里就不详细描述如何购买域名和实名制认证了。</p><a id="more"></a><p>打开阿里云的<code>云解析DNS</code>，点击需要修改解析设置的域名，点击<code>添加记录</code>，每项的配置如下：</p><ul><li>记录类型：<code>A</code>（如果需要解析IPv6地址就选择<code>AAAA</code>）</li><li>主机记录：<code>myhome</code>（修改为自己想要的三级域名，留空则不使用三级域名）</li><li>解析线路：<code>默认</code>（一般默认即可）</li><li>记录值：<code>xx.xxx.xx.xx</code>（填入D2550的wan口IP地址）</li><li>TTL：<code>10分钟</code>（一般默认即可）</li></ul><p>点击添加后，看到页面记录显示解析状态正常，域名解析配置就完成了。</p><p><img src="images/router/D2550_Aliyun_DNS.png" alt="云解析配置"></p><h1 id="访问控制配置"><a href="#访问控制配置" class="headerlink" title="访问控制配置"></a>访问控制配置</h1><p>接下来需要配置的是云解析DNS的访问控制，配置访问控制的目的是让D2550获得更改解析记录的权限。</p><p>打开阿里云的<code>访问控制/RAM访问控制</code>，打开<code>身份管理</code>中的<code>用户</code>，点击<code>创建用户</code>，<code>登录名称</code>和<code>显示名称</code>自定，勾选<code>Open API调用访问</code>。</p><p>创建用户后，阿里云会提供该用户的<code>AccessKey ID</code>和<code>AccessKey Secret</code>，将其记录下来，页面关闭后就不再显示Secret了。点击用户操作选项中的<code>添加权限</code>，在系统策略中找到<code>管理云解析DNS的权限</code>，选择添加并确定。</p><p><img src="images/router/D2550_Aliyun_RAM.png" alt="访问控制配置"></p><p>这一步完成后，云端的配置工作就完成了。</p><h1 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h1><p>打开D2550的管理界面，打开<code>动态DNS</code>服务页面，添加一份配置，配置如下：</p><ul><li>启用：☑️</li><li>查询主机名：<code>myhome.fisheryung.top</code>（填入在域名解析配置中设置的域名）</li><li>IP地址版本：<code>IPv4地址</code>（如果用IPv6则改成v6地址）</li><li>DDNS服务提供商：<code>aliyun.com</code></li><li>域名：<code>myhome.fisheryung.top</code>（同查询主机名）</li><li>用户名：<code>AccessKey ID</code>（访问控制配置中提供的ID）</li><li>密码：<code>AccessKey Secret</code>（访问控制配置中提供的Secret）</li></ul><p>保存并应用，过一段时间查看日志，如果有定时检查并更新IP地址，则表示配置成功。</p><p><img src="images/router/D2550_DDNS.png" alt="DDNS"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>给D2550配置端口转发，在本地启动Hexo博客，用手机流量尝试进行访问，可以看到访问成功，自此DDNS配置完成。</p><p><img src="images/router/D2550_DDNS_test.png" alt="测试" style="zoom: 50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近着手改造家里的网络，买了一个D2550软路由，把家里的光猫由拨号改成了桥接，并使用D2550拨号和管理家里的网络。很久之前就向电信申请了公网IP，一直没用上，此次趁着网络改造，顺带给这个公网IP配置DDNS，利用起来并为后续NAS的搭建提供外网访问的环境。&lt;/p&gt;&lt;h1 id=&quot;域名解析配置&quot;&gt;&lt;a href=&quot;#域名解析配置&quot; class=&quot;headerlink&quot; title=&quot;域名解析配置&quot;&gt;&lt;/a&gt;域名解析配置&lt;/h1&gt;&lt;p&gt;首先是需要有一个域名，在阿里云购买一个域名非常简单，填写实名制模版，使用模版购买域名即可，现在好像不需要背景布拍照上传手持身份证的照片了，跟以前相比简直太方便了，这里就不详细描述如何购买域名和实名制认证了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.fisheryung.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://www.fisheryung.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>小米路由器4千兆版刷OpenWrt</title>
    <link href="http://www.fisheryung.top/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A84%E5%8D%83%E5%85%86%E7%89%88%E5%88%B7openwrt.html"/>
    <id>http://www.fisheryung.top/小米路由器4千兆版刷openwrt.html</id>
    <published>2021-07-08T08:53:37.000Z</published>
    <updated>2021-07-14T13:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在家用了一段时间的小米路由器4千兆版，使用一段时间之后就会发生网络不稳定，甚至无法连接网络等情况，怀疑是官方固件的问题。同时也有一些插件上的需求，于是就开始动手把OpenWrt固件刷入到小米路由器4千兆版中。</p><h1 id="刷机环境"><a href="#刷机环境" class="headerlink" title="刷机环境"></a>刷机环境</h1><ul><li>刷机使用的系统：macOS 11.4</li><li>编译OpenWrt使用的系统：Ubuntu 21.04</li><li>小米路由器4千兆版固件版本：MiWiFi 稳定版 2.28.58</li></ul><a id="more"></a><h1 id="开启SSH"><a href="#开启SSH" class="headerlink" title="开启SSH"></a>开启SSH</h1><p>开启路由器的SSH需要用到<a href="https://github.com/acecilia/OpenWRTInvasion" target="_blank" rel="noopener">OpenWRTInvasion</a>，首先克隆仓库，安装依赖。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/acecilia/OpenWRTInvasion.git</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> OpenWRTInvasion/</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>接下来打开路由器管理界面，获取<code>stok</code>，<code>stok</code>在路由器的地址栏处，如下图所示，<code>stok=xxxx</code>一直到<code>/</code>前，那么<code>stok</code>就是<code>ff43b68c8e20a6bcd3d33377c0c889dd</code>。</p><p><img src="images/router/Mi4G_stok.png" alt="Stok"></p><p>运行<code>OpenWRTInvasion</code>中的<code>remote_command_execution_vulnerability.py</code>，输入路由器<code>IP地址</code>和<code>stok</code>，脚本会执行命令并开启SSH、Telnet和FTP。如果出现如下图提示，表示开启成功。</p><p><img src="images/router/Mi4G_ssh.png" alt="开启SSH成功"></p><p><strong>如果等了很久都没有反应，则有可能是下载<code>busybox</code>和<code>dropbear</code>时遇到了网络问题，此时需要手动修改一下<code>busybox</code>和<code>dropbear</code>的下载地址</strong>。</p><p>打开<code>OpenWRTInvasion</code>文件夹中的<code>script.sh</code>文件，找到<code>setup_busybox()</code>函数和<code>start_ssh()</code>函数中的<code>curl</code>命令，将其中的下载地址进行修改，这里我使用自己的服务器提供下载。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setup_busybox函数</span></span><br><span class="line"><span class="comment"># Rationale for using --insecure: https://github.com/acecilia/OpenWRTInvasion/issues/31#issuecomment-690755250</span></span><br><span class="line">curl -L <span class="string">"https://fisher.lazybone.xyz/downloads/busybox-mipsel"</span> --insecure --output busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># start_ssh函数</span></span><br><span class="line"><span class="comment"># Donwload dropbear static mipsel binary</span></span><br><span class="line">curl -L <span class="string">"https://fisher.lazybone.xyz/downloads/dropbearStaticMipsel.tar.bz2"</span> --output dropbear.tar.bz2</span><br></pre></td></tr></table></figure><p>再次运行<code>OpenWRTInvasion</code>，网络状态良好的情况下能够正常开启ssh了。复制执行脚本给出的ssh命令，输入密码<code>root</code>，就能够ssh登录到路由器中了。</p><p><img src="images/router/Mi4G_login.png" alt="SSH登录"></p><h1 id="刷入Breed"><a href="#刷入Breed" class="headerlink" title="刷入Breed"></a>刷入Breed</h1><p>ssh登录路由器后，使用Curl下载Breed，将其重命名为breed.bin并进行md5校验，md5一致后才能刷Breed。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">curl -o breed.bin https://breed.hackpascal.net/breed-mt7621-pbr-m1.bin</span><br><span class="line">md5sum breed.bin</span><br></pre></td></tr></table></figure><p>使用mtd将Breed刷入Bootloader分区中，此时路由器会自动重启。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtd -r write /tmp/breed.bin Bootloader</span><br></pre></td></tr></table></figure><p><img src="images/router/Mi4G_breed.png" alt="刷入Breed"></p><p>使用网线连接路由器，待网卡正确获取到IP为<code>192.168.1.x</code>的地址后，路由器电源指示灯为淡紫色，表示正常进入Breed中了。</p><p><img src="images/router/Mi4G_breedindex.png" alt="进入Breed"></p><h1 id="编译OpenWrt"><a href="#编译OpenWrt" class="headerlink" title="编译OpenWrt"></a>编译OpenWrt</h1><p>如果从网上下载别人编译好的固件，这一步就可以省略了，下面说说我在编译固件时踩过的坑。</p><ul><li>首先是直接使用coolsnowwolf的<a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener">LEDE</a>编译出来的固件，用Breed刷入后是无法正常引导的，这里需要修改一下内存分区的源码，具体操作流程可参考恩山大佬的<a href="https://www.right.com.cn/forum/thread-4052254-1-1.html" target="_blank" rel="noopener">帖子</a>。</li><li>接着是编译后的固件没有2.4g无线网卡的驱动，这个需要在编译配置中勾选<code>kmod-mt7603</code>，以支持小米路由器4千兆版的2.4g无线网卡。</li></ul><h1 id="刷入OpenWrt"><a href="#刷入OpenWrt" class="headerlink" title="刷入OpenWrt"></a>刷入OpenWrt</h1><p>打开Breed的固件更新页面，选择要刷入的Openwrt固件，直接刷入即可。</p><p><img src="images/router/Mi4G_overview.png" alt="OpenWrt"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在家用了一段时间的小米路由器4千兆版，使用一段时间之后就会发生网络不稳定，甚至无法连接网络等情况，怀疑是官方固件的问题。同时也有一些插件上的需求，于是就开始动手把OpenWrt固件刷入到小米路由器4千兆版中。&lt;/p&gt;&lt;h1 id=&quot;刷机环境&quot;&gt;&lt;a href=&quot;#刷机环境&quot; class=&quot;headerlink&quot; title=&quot;刷机环境&quot;&gt;&lt;/a&gt;刷机环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;刷机使用的系统：macOS 11.4&lt;/li&gt;
&lt;li&gt;编译OpenWrt使用的系统：Ubuntu 21.04&lt;/li&gt;
&lt;li&gt;小米路由器4千兆版固件版本：MiWiFi 稳定版 2.28.58&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.fisheryung.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://www.fisheryung.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>SCNU校园网IPv6配置</title>
    <link href="http://www.fisheryung.top/scnu%E6%A0%A1%E5%9B%AD%E7%BD%91ipv6%E9%85%8D%E7%BD%AE.html"/>
    <id>http://www.fisheryung.top/scnu校园网ipv6配置.html</id>
    <published>2021-06-24T03:03:47.000Z</published>
    <updated>2021-06-24T04:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因教育网IPv6不限速，使用清华TUNA的开源镜像站下载资源能够跑满带宽，体验非常好，所以就有了给路由器配置IPv6的想法。之前使用极路由官方固件时有官方的教育网插件可以用（使用6relay），但换了Openwrt后使用的是odhcpd，需要自己重新配置一下。这篇博客纪录了我的配置过程，其中参考了恩山论坛的<a href="https://www.right.com.cn/forum/thread-316405-1-1.html" target="_blank" rel="noopener">这篇</a>帖子。</p><a id="more"></a><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ol><li>本次配置使用的硬件设备：极路由3（HC5861、MT7620）</li><li>本次配置使用的固件：Lean’s Openwrt R21.6.22</li><li>本次配置使用的Mentohust：<a href="https://github.com/KyleRicardo/MentoHUST-OpenWrt-ipk" target="_blank" rel="noopener">Mentohust-ipk</a>、<a href="https://github.com/BoringCat/luci-app-mentohust" target="_blank" rel="noopener">Luci-App-Mentohust</a></li></ol><p>Lean’s Openwrt中内核模块默认勾选了NAT6功能，因此编译时只需要勾选编译Mentohust相关的软件包即可，编译的过程在此就不赘述了。</p><h1 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h1><p>刷入固件后，先不要连接路由器的WAN口，待电脑DHCP获取到由路由器分发的IP地址后，再将网线连接到WAN口。（如果一直连接WAN口，电脑会首先获取到校园网DHCP的IP地址，此时需要断开并重启电脑与路由器的连接）</p><h2 id="WAN6接口配置"><a href="#WAN6接口配置" class="headerlink" title="WAN6接口配置"></a>WAN6接口配置</h2><p>在基本设置中，各项配置如下：</p><ul><li>协议：DHCPv6客户端</li><li>请求IPv6地址：try</li><li>请求指定长度的IPv6前缀：自动</li></ul><p>在高级设置中，各项配置如下：</p><ul><li>使用内置的IPv6管理：不勾选</li><li>使用对端通告的 DNS 服务器：不勾选（SCNU校园网不分发IPv6的DNS服务器地址，IPv6的地址解析全都是用v4的DNS服务器，因此需要自行指定）</li><li>使用自定义的DNS服务器：<code>2001:da8::666</code></li></ul><p>保存并应用，可以看到WAN口同时获得了IPv4和IPv6的地址，接下来可以进行Mentohust的配置了。</p><p><img src="images/router/ipv6_wan6.png" alt="WAN口状态"></p><h2 id="Mentohust配置"><a href="#Mentohust配置" class="headerlink" title="Mentohust配置"></a>Mentohust配置</h2><p>打开<code>服务-MentoHUST</code>，在常规设置中进行如下配置：</p><ul><li>用户名和密码：填入自己的校园网用户名和密码</li><li>接口：选择WAN口网卡，我的路由器是WAN口是<code>eth0.2</code></li><li>Ping主机：如果需要掉线检测功能，就填入一个公网IP地址，我使用了自己的云服务器IP地址</li></ul><p>在高级设置中进行如下配置，其他无需修改：</p><ul><li>验证失败等待时间：5</li><li>DHCP设置：认证前</li><li>DHCP的脚本：<code>udhcpc -i eth0.2</code></li></ul><p>最后在常规设置中勾选启用，保存并应用，查看日志，试试能否登录成功。</p><p><img src="images/router/ipv6_mentohust.png" alt="Mentohust日志"></p><p>确认能够连上互联网后，ssh连接路由器，尝试ping一下IPv6的地址，验证路由器是否正确获取IPv6地址并连接成功，以下是ping6的命令和执行结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping6 -c 4 bt.byr.cn</span><br></pre></td></tr></table></figure><p><img src="images/router/ipv6_ping6.png" alt="Ping结果"></p><h2 id="LAN口配置"><a href="#LAN口配置" class="headerlink" title="LAN口配置"></a>LAN口配置</h2><p>在<code>接口</code>页面，找到<code>全局网络选项</code>，修改<code>IPv6 ULA前缀</code>：</p><ul><li>将地址的首位改为<code>d</code>（你喜欢改什么都行），我从<code>fd73:1f1d:a603::/48</code>改为了<code>dd73:1f1d:a603::/48</code></li></ul><p>编辑LAN口配置，找到<code>DHCP服务器</code>，修改<code>IPv6</code>设置：</p><ul><li>路由通告服务：服务器模式</li><li>DHCPv6服务：服务器模式</li><li>NDP代理：已禁用</li><li>DHCPv6模式：无状态的+有状态的</li><li>总是通告默认路由：取消勾选</li></ul><p>保存并等待一段时间，此时电脑应该获取到了路由器自行分发的IPv6地址，LAN口也有自己的IPv6地址。</p><p><img src="images/router/ipv6_interface.png" alt="接口配置"></p><h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><p>打开防火墙的<code>自定义规则</code>，添加如下一行规则并点击重启防火墙，开启IPv6数据包的转发。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -t nat -A POSTROUTING -o eth0.2 -j MASQUERADE</span><br></pre></td></tr></table></figure><h2 id="网关配置"><a href="#网关配置" class="headerlink" title="网关配置"></a>网关配置</h2><p>首先ssh登录路由器，查看当前IPv6的默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -6 route | grep default</span><br></pre></td></tr></table></figure><p>可以看到有2条路由配置</p><p><img src="images/router/ipv6_route.png" alt="默认路由"></p><p>复制这个<code>fe80</code>开头的IPv6地址，将当前的默认网关添加到默认路由中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -A inet6 add default gw fe80::274:9cff:fe80:dc7d dev eth0.2</span><br></pre></td></tr></table></figure><p>再次查看当前的默认路由，可以看到有3条记录</p><p><img src="images/router/ipv6_route1.png" alt="默认路由"></p><p>重启网络服务，验证局域网设备能否连上IPv6网络（重启后记得手动重启Mentohust服务）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure><p>由于默认路由重启后会重置，因此需要添加一个脚本，让路由器开机自动添加默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hotplug.d/iface/90-ipv6</span><br></pre></td></tr></table></figure><p>添加如下内容，其中的默认路由地址修改为自己的默认路由</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">[ <span class="string">"<span class="variable">$ACTION</span>"</span> = ifup ] || <span class="built_in">exit</span> 0</span><br><span class="line">route -A inet6 add default gw fe80::274:9cff:fe80:dc7d dev eth0.2</span><br></pre></td></tr></table></figure><p>保存退出后，赋予执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/hotplug.d/iface/90-ipv6</span><br></pre></td></tr></table></figure><h1 id="IPv6测试"><a href="#IPv6测试" class="headerlink" title="IPv6测试"></a>IPv6测试</h1><p>打开<a href="http://ipv6-test.com/" target="_blank" rel="noopener">http://ipv6-test.com/</a></p><p><img src="images/router/ipv6_test2.png" alt="测试结果"></p><p>打开<a href="http://test-ipv6.com/" target="_blank" rel="noopener">http://test-ipv6.com/</a></p><p><img src="images/router/ipv6_test1.png" alt="测试结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于SCNUNET，一开始我使用的IPv6方案为全中继的模式，路由器局域网设备IPv6地址全由上级路由器分发，局域网设备的确是获得了公网IPv6的地址，但是这个地址是上不了网的，而路由器的IPv6地址却使用正常，个人猜测是因为这些IPv6地址没有登录校园网，因此也无法使用。</p><p>既然在中继IPv6的方案下不可行，那就只能使用NAT6的方法了。在参考了许多篇配置的文章后，终于是配置成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因教育网IPv6不限速，使用清华TUNA的开源镜像站下载资源能够跑满带宽，体验非常好，所以就有了给路由器配置IPv6的想法。之前使用极路由官方固件时有官方的教育网插件可以用（使用6relay），但换了Openwrt后使用的是odhcpd，需要自己重新配置一下。这篇博客纪录了我的配置过程，其中参考了恩山论坛的&lt;a href=&quot;https://www.right.com.cn/forum/thread-316405-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇&lt;/a&gt;帖子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.fisheryung.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="路由器" scheme="http://www.fisheryung.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从High Sierra升级到Big Sur</title>
    <link href="http://www.fisheryung.top/%E4%BB%8Ehigh-sierra%E5%8D%87%E7%BA%A7%E5%88%B0big-sur.html"/>
    <id>http://www.fisheryung.top/从high-sierra升级到big-sur.html</id>
    <published>2021-05-30T03:52:26.000Z</published>
    <updated>2021-05-30T09:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看着Dock栏的图标一个个变成了正方形，软件慢慢开始不支持High Sierra系统，我也按耐不住想要升级系统了。但插在主板上的GTX1060告诉我，升级了系统之后就再也用不了它了，并且升级后的系统也不知道能不能正常使用。为了解决显卡这个问题，我去网上查了许多资料，研究了几种不同的解法，最终在不变动当前配置的情况下成功升级到Big Sur，Windows系统也毫无影响，付出的代价有2个：一是Big Sur下GTX1060无法使用；二是需要频繁插拔HDMI线，想要切换到Windows系统并使用GTX1060，需要把HDMI线从板载HDMI口拔下并插到显卡HDMI口上。</p><a id="more"></a><h1 id="升级思路"><a href="#升级思路" class="headerlink" title="升级思路"></a>升级思路</h1><p>升级系统的思路主要有以下几种：</p><ul><li>只用集显的方法，这是最简单的一种方法了，把GTX1060拔了，舍弃独显，重新配置机型，全新安装Big Sur。这种方法最简单，但是Windows下只能用UHD630，游戏没法好好玩了。</li><li>显卡置换的方法，把GTX1060卖了之后换免驱的A卡，前一个星期我都在观察RX560和R9 Nano，想要入手一张。奈何是ITX机箱，A卡的ITX卡存量较少，价格较高，没舍得采用这种方案。</li><li>系统分开使用显卡的方法，在Big Sur中只用UHD630集显，在Windows中使用GTX1060。这种方法的好处是机器不需要对配置进行任何改动，但想要启动Windows打游戏的时候，需要把HDMI线插到独显上，想要启动Big Sur干活的时候，需要把HDMI线插到板载HDMI口上。</li></ul><p>最终，我使用了第三种方法，虽然频繁插拔HDMI线麻烦了一点，但是不需要花钱，也不需要动硬件，也算是一种比较省心的方法了。</p><h1 id="Bios设置"><a href="#Bios设置" class="headerlink" title="Bios设置"></a>Bios设置</h1><p>本次升级中，Bios设置主要集中在北桥中，设置如下：</p><ul><li>首选显卡：CPU Graphics</li><li>iGPU：Disable（启用后，主板会将板载和独显的HDMI口当成两个屏幕的输出，这样子就无法做输出区分了）</li><li>DVMT Pre-Allocated：128M（网上资料说：分配显存过小可能会出现花屏和黑屏，具体我没验证过）</li><li>RC6：Auto</li></ul><p><img src="images/hackintosh/bigsur_bios.png" alt="Bios设置"></p><h1 id="系统下载"><a href="#系统下载" class="headerlink" title="系统下载"></a>系统下载</h1><p>由于百度云没会员实在是太慢了，我使用了<a href="https://github.com/munki/macadmin-scripts" target="_blank" rel="noopener">macadmin-scripts</a>脚本下载系统，该脚本的使用方法很简单，下载的镜像也是官方的纯净镜像。</p><ul><li>拉取仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop/</span><br><span class="line">git clone https://github.com/munki/macadmin-scripts.git</span><br><span class="line">cd macadmin-scripts/</span><br></pre></td></tr></table></figure><ul><li>以管理员身份运行脚本，如果提示缺少依赖，使用pip3安装对应依赖即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 ./installinstallmacos.py</span><br></pre></td></tr></table></figure><ul><li>在更新资源目录之后，脚本会询问想要下载哪个版本的镜像，这里我直接选择最新版的Big Sur，序号是18</li></ul><p><img src="images/hackintosh/downloadimage.png" alt="选择需要下载的镜像"></p><ul><li>接着脚本就会自动下载镜像，下载完成之后在文件夹中会自动生成一个dmg文件，该文件就是系统镜像了</li></ul><p>提示：如果下载过程中由于网络波动等原因导致下载失败，没有关系，重新运行脚本并选择相同的镜像序号，脚本会自动从下载失败的地方继续下载。</p><h1 id="OpenCore配置"><a href="#OpenCore配置" class="headerlink" title="OpenCore配置"></a>OpenCore配置</h1><p>这一步中，我们需要准备一个U盘，往里面放一份当前系统的EFI配置，然后进行修改。接下来的升级安装过程中全程使用这一份配置来引导系统。</p><p>由于之前的OpenCore配置文件中启用了独立显卡并指定为N卡，我们需要修改一下，将独显禁用并添加核显配置参数。如有需要，还要更换机型配置。（我从iMac18,2更换到Macmini8,1）</p><ul><li>首先是添加对集显的支持，我的集显是UHD630，添加的参数配置如下，其他型号的集显可以在各种黑苹果论坛查对应的键值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>PciRoot(0x0)/Pci(0x2,0x0)<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>AAPL,ig-platform-id<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>BwCbPg==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>AAPL,slot-name<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Internal@0,2,0<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>device-id<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>mz4AAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>device_type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>VGA compatible controller<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>dpcd-max-link-rate<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>FAAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-dpcd-max-link-rate-fix<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-hdmi20<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>enable-lspcon-support<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-busid<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-has-lspcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CgAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con0-type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAgAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-has-lspcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AwAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CAAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con1-type<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAgAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-busid<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-index<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-con2-pipe<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>CQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-patch-enable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AQAAAA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>framebuffer-unifiedmem<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span>AAAAgA==<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>hda-gfx<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>onboard-1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>model<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Intel UHD Graphics 630<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加后的OC配置如下图所示</p><p><img src="images/hackintosh/ocdeviceproperties_update_bigsur.png" alt="集显配置"></p><ul><li>接下来是禁用Intel网卡和蓝牙的驱动，因为不同系统版本有对应编译的驱动，升级完系统后还需要对这两个驱动升级，最后才能启用这两个驱动</li><li>同时，对于我的主板（Asus B360i），我还需要勾选<code>DisableRtcChecksum</code>，否则升级系统后每次开机主板都会进入安全模式</li></ul><p><img src="images/hackintosh/ockernel_update_bigsur.png" alt="禁用驱动"></p><ul><li>随后是启动参数的修改，清空之前的所有参数，填入以下参数：<ul><li><code>-v</code>：启动Debug模式，出问题时方便排查</li><li><code>debug=0x100</code>：显示更多的Debug信息</li><li><code>keepsyms=1</code>：出现问题后不自动重启，而是卡住并保持输出Debug信息</li><li><code>alcid=7</code>：声卡驱动ID注入</li><li><code>igfxfw=2</code>：使用核显启动</li><li><code>igfxonln=1</code>：修复视频线热插拔问题</li><li><code>-wegnoegpu</code>：禁用独立显卡</li></ul></li></ul><p><img src="images/hackintosh/ocnvram_update_bigsur.png" alt="启动参数的修改"></p><ul><li>最后是机型的修改（可选），由于我之前的机型参数<code>iMac18,2</code>使用的是7代酷睿，因此在Hackintool中CPU架构显示为<code>???</code>。本次升级顺带将机型参数也更换掉，更换为配置更接近的<code>Macmini8,1</code></li><li>具体操作在OCC的PlatformInfo中选择对应机型，检查序列号，确定该序列号无效后即可</li></ul><h1 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h1><p>本次升级中，我曾尝试制作U盘启动盘，然后从<code>安装Big Sur</code>中启动并升级系统，但是升级到一大半就会提示该镜像已损坏，请重新下载的提醒。没办法，我只好放弃从U盘启动盘中升级系统。</p><p>随后我在硬盘EFI中删除<code>nvda_drv=1</code>，添加<code>-wegnoegpu</code>参数禁用独立显卡，将HDMI线接到板载HDMI接口，启动系统，此时系统是没有显卡驱动的。直接双击打开镜像然后点击升级，当系统自动重启时，转成使用U盘EFI进行引导，并在随后的启动中都使用U盘EFI进行引导。没想到这种方法居然升级成功了，因为不确定是否会成功，所以没有拍什么图片，只有下面这一张。</p><p><img src="images/hackintosh/bigsur_update.png" alt="升级成功"></p><p>值得注意的是，刚刚升级成功后电脑非常的卡，以至于在系统初始化设置界面，每点一次下一步都要等很久，这是正常现象，慢慢等就好了。</p><h1 id="完成升级"><a href="#完成升级" class="headerlink" title="完成升级"></a>完成升级</h1><p>进入系统之后，首先提醒的是N卡的WebDriver不再使用于本系统，直接卸载就可以了。</p><p>接下来更新驱动，把OC中能更新的驱动全部更新，注意Intel的Wi-Fi和蓝牙驱动要下载Big Sur版本的，在配置文件中重新勾选启用这两个驱动，保存重启测试，确认能够正常启动之后，我们就可以将新版的EFI从U盘覆盖到硬盘中了。</p><p>注意：这次升级之后我还遇到了一个问题是USB驱动问题，刚开机的时候鼠标和键盘非常卡，并且蓝牙驱动不会加载，这很明显就是USB定制驱动的问题，需要重新定制一次。重新定制之后，蓝牙驱动能够正常加载了，但是开机速度慢了很多，通过Debug的日志可以看到，蓝牙驱动一直在循环等待<code>IO USB Controller</code>这个控制器启动，而这个控制器的启动速度慢的离谱，具体解决方案目前还没有。如果你知道这个问题的解决方法，请在<a href="https://github.com/FisherWY/Asus-B360i-Hackintosh-EFI" target="_blank" rel="noopener">我的仓库</a>中提issue，非常感谢。</p><p>至此，一次系统的升级终于完成，可以开始好好体验Big Sur的新功能了。</p><p><img src="images/hackintosh/bigsur_version.png" alt="升级完成"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看着Dock栏的图标一个个变成了正方形，软件慢慢开始不支持High Sierra系统，我也按耐不住想要升级系统了。但插在主板上的GTX1060告诉我，升级了系统之后就再也用不了它了，并且升级后的系统也不知道能不能正常使用。为了解决显卡这个问题，我去网上查了许多资料，研究了几种不同的解法，最终在不变动当前配置的情况下成功升级到Big Sur，Windows系统也毫无影响，付出的代价有2个：一是Big Sur下GTX1060无法使用；二是需要频繁插拔HDMI线，想要切换到Windows系统并使用GTX1060，需要把HDMI线从板载HDMI口拔下并插到显卡HDMI口上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://www.fisheryung.top/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>从Clover迁移到OpenCore</title>
    <link href="http://www.fisheryung.top/%E4%BB%8Eclover%E8%BF%81%E7%A7%BB%E5%88%B0opencore.html"/>
    <id>http://www.fisheryung.top/从clover迁移到opencore.html</id>
    <published>2021-04-11T01:48:59.000Z</published>
    <updated>2021-04-11T04:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前，OpenCore Bootloader已经开发了相当一段时间，已经趋近于稳定。OpenCore的启动方式更接近于原生macOS电脑，对系统的注入更少，越来越多的驱动都基于OpenCore适配开发。因此，将Bootloader从Clover迁移到OpenCore也是时候提上日程了。以下博客记录了我的迁移过程，并向大家分享一下我的迁移方法。不同于网上的纯ProperTree手动配置、纯OpenCore Configurator图形配置或OC Gen-X直接生成，我同时用到了以上三种工具，节省了迁移成本的同时，也避免遇到了很多错误。</p><a id="more"></a><h1 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h1><p>首先介绍的是我的硬件信息，如下表所示。</p><table><thead><tr><th style="text-align:center">硬件类型</th><th style="text-align:center">型号</th></tr></thead><tbody><tr><td style="text-align:center">主板</td><td style="text-align:center">Asus Rog Strix B360-i Mini ITX</td></tr><tr><td style="text-align:center">处理器</td><td style="text-align:center">Intel Core i5-8500</td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">Crucial By Micron DDR4 2666MHz 8GB + Corsair LPX DDR4 3000MHz 8GB(运行在2666MHz)</td></tr><tr><td style="text-align:center">显卡</td><td style="text-align:center">Nvidia GeForce GTX 1060 3GB</td></tr><tr><td style="text-align:center">硬盘</td><td style="text-align:center">Asgard AN2 NVMe 250GB</td></tr><tr><td style="text-align:center">网卡</td><td style="text-align:center">板载Intel AC 9560</td></tr></tbody></table><h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>整个配置的过程需要用到以下的工具包，均可以从GitHub下载，注意工具对应的OC版本需要一致，否则极大概率会出错。</p><ul><li>OpenCore（版本0.6.8正式版），地址在<a href="https://github.com/acidanthera/OpenCorePkg" target="_blank" rel="noopener">这里</a></li><li>OC Gen-X（版本3.0.2），地址在<a href="https://github.com/Pavo-IM/OC-Gen-X" target="_blank" rel="noopener">这里</a></li><li>OpenCore Configurator（版本2.33.1.2），GitHub地址在<a href="https://github.com/notiflux/OpenCore-Configurator" target="_blank" rel="noopener">这里</a>，软件下载地址在<a href="https://www.macwk.com/soft/opencore-configurator" target="_blank" rel="noopener">这里</a></li></ul><p>将OpenCore解压，安装OC Gen-X，安装OpenCore Configurator。至此，工具的准备工作完成。</p><h1 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h1><p>首先我们需要准备一份适合本机配置的配置文件，如果使用OCC或ProperTree纯手动配置的话，需要手动填入很多参数，费时又容易出错。因此我们使用OC Gen-X直接生成一份简单的配置文件，然后再基于这份配置文件进行修改。</p><p>打开OC Gen-X，首先确认系统架构。因为我使用的是第八代酷睿，因此在System Type选择<code>Intel Consumer</code>的<code>Coffee Lake</code>。</p><p><img src="images/hackintosh/genxsystemtype.png" alt="系统架构"></p><p>接下来在Kext中进行如下列表的勾选，图比较多我就只放<code>Essential</code>中的一张了</p><ul><li>Essential，勾选：Lilu和VirtualSMC</li><li>VirtualSMC Plugins，勾选：SMCProcessor、SMCSuperIO和SMCLightSensor</li><li>Graphics，勾选：WhateverGreen（Boot Args留空），AGPMInjector（显卡节能用，选择你目前的仿冒型号和GPU，我的选择是<code>iMac18,2</code>和<code>GTX1060</code>）</li><li>Audio，勾选：AppleALC（Boot Args留空）</li><li>Ethernet，勾选：IntelMausi</li><li>USB，勾选：USBInjectALL</li><li>WI-FI and Bluetooth，无需勾选，稍后手动添加驱动</li><li>Extra’s，无需勾选，里面的驱动是给AMD CPU使用的</li></ul><p><img src="images/hackintosh/genxkext.png" alt="驱动选择"></p><p>接下来在Firmware Drivers中，在<code>UEFI</code>中勾选<code>OpenRuntime.efi</code>和<code>HfsPlus.efi</code>。</p><p><img src="images/hackintosh/genxfirmwaredrivers.png" alt="固件选择"></p><p>最后在SMBIOS中，OC Gen-X会自动填入当前系统的SMBIOS信息，不需要去修改了。在Additional BootArgs中也不需要填入任何参数，稍后用OCC手动填入即可。</p><p>点击下方<code>Generate EFI</code>，就会在你的桌面生成一个EFI文件夹，此时可以关闭OC Gen-X了，接下来的操作就是修改这个EFI的配置。</p><p><img src="images/hackintosh/genxsuccess.png" alt="生成配置"></p><h1 id="添加固件、驱动、主题"><a href="#添加固件、驱动、主题" class="headerlink" title="添加固件、驱动、主题"></a>添加固件、驱动、主题</h1><p>OC Gen-X生成的EFI文件并不是立即就能使用的，还需要根据自己的需要进行修改，以下是我的修改过程。</p><p>首先打开<code>EFI/OC/Drivers</code>，可以看到里面只有刚刚勾选添加的2个固件，缺少了其他固件，OC是启动不起来的，因此需要添加OpenCore官方包中的固件。打开<code>OpenCore</code>官方EFI（准备阶段中下载解压的）中的<code>OpenCore-0.6.8-RELEASE/X64/EFI/OC/Drivers</code>，可以看到里面有很多OC的启动固件，把这些固件全部复制到Gen-X生成的EFI中。</p><p><img src="images/hackintosh/genxdriverscopy.png" alt="复制固件"></p><p>接下来打开<code>EFI/OC/Kexts</code>，可以看到文件夹中已经添加了我们刚刚在Gen-X中勾选的驱动。但每个人的配置都不同，还需要根据自己的配置添加对应的驱动。对于我的配置来说，我还需要添加的驱动和作用在以下列表中。</p><ul><li>AirportItlwm.kext，Intel AC 9560网卡驱动，这个Airport版本支持原生Airdrop</li><li>CPUFriend.kext，CPU变频补丁驱动，添加后有低频档位</li><li>HibernationFixup.kext，睡眠修复补丁，目前发现添加与否并不影响睡眠，先加了再说</li><li>IntelBluetoothFirmware.kext，Intel AC 9560蓝牙驱动</li><li>IntelBluetoothInjector.kext，修复系统蓝牙开关为灰色的补丁</li><li>NVMeFix.kext，NVME固态硬盘兼容性提升驱动</li></ul><p>添加完驱动后的Kexts文件夹如下图所示。</p><p><img src="images/hackintosh/genxkextscopy.png" alt="添加驱动"></p><p>（可选）最后可以根据需要添加Bootloader的主题，如果没有主题，OpenCore的启动界面是纯文字的，也不是不能用。但是为了好看，我还是弄了一套官方的主题。</p><p>从GitHub拉取<code>OcBinaryData</code>仓库，地址在<a href="https://github.com/acidanthera/OcBinaryData" target="_blank" rel="noopener">这里</a>。因为我不需要开机声音，所以我把拉取后把仓库中的<code>Resources/Audio</code>下的音频文件全部删除了。</p><p>最后，把整个Resources文件夹替换掉<code>EFI/OC/</code>中的Resources文件夹即可。</p><p>至此，EFI中的固件、驱动、主题文件准备完毕，接下来就是对配置文件进行修改。</p><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>在修改配置文件之前，我们需要准备一个有EFI分区的U盘，最好是以前配置Clover时留下来的一个备份。挂载这个U盘的EFI分区，将里面的EFI文件替换，然后就可以开始配置文件的修改了。</p><p>使用OpenCore Configurator打开U盘<code>EFI/OC</code>中的<code>config.plist</code>，开始配置文件的修改。</p><p>首先是<code>ACPI-ACPI设置</code>，这里需要根据机型的不同添加对应的SSDT文件，在右侧列表框的下方点击<code>下载/更新Acpi文件</code>，对于我的配置，我需要下载以下SSDT文件：</p><ul><li>SSDT-AWAC</li><li>SSDT-EC-USBX-DESKTOP</li><li>SSDT-PLUG-DRTNIA</li><li>SSDT-PMC</li></ul><p><img src="images/hackintosh/occacpidownload.png" alt="下载SSDT"></p><p>点击下载后，就可以关闭ACPI补丁下载器了，然后点击<code>快照添加</code>，刚刚下载的SSDT配置文件就会自动添加并启用，配置完成后的ACPI设置界面如下。</p><p><img src="images/hackintosh/occacpi.png" alt="ACPI设置"></p><p>接下来的<code>Booter-启动设置</code>，不需要修改里面的任何选项，直接跳过。</p><p>接下来的<code>DeviceProperties-设备属性设置</code>，如果想开启核显加速，就需要在里面添加核显设备。点击左侧设备列表的加号，在新添加的空白栏中填入<code>PciRoot(0x0)/Pci(0x2,0x0)</code>，然后点击右侧表格下方的加号，在新添加的空白栏中的键填入<code>AAPL,ig-platform-id</code>，在值中填入<code>0300983E</code>，不同CPU，不同核显和不同的加速效果有着不同的值，这个值需要在网上查询自己核显的<code>ig-platform-id</code>，添加后的效果如下。</p><p><img src="images/hackintosh/occdeviceproperties.png" alt="设备属性设置"></p><p>接下来的<code>Kernel-内核设置</code>，需要在<code>添加</code>页面加入自己需要启用的驱动，打开<code>EFI/OC/Kexts</code>，拖动自己添加的驱动到列表中，启用即可。这里需要注意调整启动顺序，自己添加驱动启动顺序最好放在最后面。添加后的效果如下。</p><p><img src="images/hackintosh/occkerneladd.png" alt="驱动页设置"></p><p>在<code>Kernel-内核设置</code>中，还需要添加的是RTC修复的补丁，否则每次重启开机BIOS都会进入安全模式，具体原因在xjn的博客中有详细描述，想了解更多的点<a href="https://blog.xjn819.com/post/rtc-issues-related-to-oc.html" target="_blank" rel="noopener">这里</a>。点击<code>补丁</code>，在表格右下角点2次加号，添加两个补丁条目。在两个条目中，标识符均填入<code>com.apple.driver.AppleRTC</code>，替换次数均填入<code>1</code>，均勾选启用。在第一个条目中的查找中填入<code>752E0FB6</code>，在第一个条目中的替换中填入<code>EB2E0FB6</code>。在第二个条目中的查找中填入<code>75330FB7</code>，在第二个条目中的替换中填入<code>EB330FB7</code>，最小内核和最大内核填入<code>18.5.0</code>（网上也有解决方法是不需要填入内核参数的，但我并没有进行测试，有兴趣的朋友可以测试一下）。填完后的效果如下。</p><p><img src="images/hackintosh/occkernelpatch.png" alt="补丁页设置"></p><p>接下来是<code>Misc-其他设置</code>，如果在上一节中添加了主题文件并且想启用，在<code>Boot</code>页的设置中需要把<code>Picker Mode启动界面模式修改为External</code>，如果想隐藏多余的启动项（例如：恢复分区、Reset NVRAM等），可以勾选<code>HideAuxiliary</code>，修改后的效果如下。</p><p><img src="images/hackintosh/occmiscboot.png" alt="Boot页设置"></p><p>在<code>Misc-其他设置</code>中，还需要修改启动的安全选项，在<code>Security</code>页中，将<code>Vault</code>参数改为<code>Optional</code>，如果使用<code>AirportItlwn</code>驱动，还需要将<code>SecureBootMode</code>参数修改为<code>Default</code>，这个参数会导致开机速度变慢，但为了使用Intel原生Wi-Fi驱动，也是没办法的事情，修改后的效果如下。</p><p><img src="images/hackintosh/occmiscsecurity.png" alt="Security页设置"></p><p>接下来是<code>NVRAM-随机访问储存器设置</code>，我们需要修改启动参数，不同配置的机型启动参数可能不同。点击左侧UUID表中的<code>7C436110-AB2A-4BBB-A880-FE41995C9F82</code>，在右侧<code>boot-args</code>中把默认的值删掉，填入<code>-v debug=0x100 keepsyms=1 nvda_drv=1 alcid=7</code>，下面是参数含义解释。</p><ul><li>-v，开启debug模式，测试无问题后可删去</li><li>debug=0x100，在启动遇到问题后不自动关机，而是停止操作，方便观察debug log</li><li>keepsyms=1，输出更多的debug信息，方便调试</li><li>nvda_drv=1，启用NVIDIA驱动，N卡独显需要使用</li><li>alcid=7，声卡ID注入，我的板载声卡注入ID为7</li></ul><p>配置完成后的效果如下。</p><p><img src="images/hackintosh/occnvram.png" alt="NVRAM配置"></p><p>接下来是<code>PlatformInfo-机型平台设置</code>，由于Gen-x在生成配置文件时已经自动填入机型信息，这一页不需要再手动配置了。</p><p>最后是<code>UEFI-UEFI设置</code>，如果要开启OC的主题，还需要添加UEFI驱动。点击<code>UEFI驱动</code>页面，点击<code>浏览</code>，将<code>EFI/OC/Drivers</code>中的<code>OpenCanopy.efi</code>添加到表格中，添加后效果如下。</p><p><img src="images/hackintosh/occuefi.png" alt="UEFI设置"></p><p>至此，OC的启动配置文件修改完成，按<code>command + s</code>保存配置，就可以开始重启，使用OC尝试引导系统了。</p><h1 id="清除Clover残余"><a href="#清除Clover残余" class="headerlink" title="清除Clover残余"></a>清除Clover残余</h1><p>如果使用OC能够成功引导系统，并且使用一段时间后没有任何问题，就可以将硬盘上的Clover EFI替换为OpenCore EFI了。替换的操作也是一样的，将整个EFI文件夹替换即可，最后在Terminal中执行以下代码，清除Clover残留文件即可完成迁移。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 Clover 位于系统偏好设置中的面板</span></span><br><span class="line">sudo rm -rf <span class="string">"/Library/PreferencePanes/Clover.prefPane"</span></span><br><span class="line"><span class="comment"># 删除 Clover 的自动脚本</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.clover.lib"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/10.save_and_rotate_boot_log.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/20.mount_ESP.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d/80.save_nvram_plist.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.shutdown.local"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.boot.d"</span></span><br><span class="line">rm -rf <span class="string">"/etc/rc.shutdown.d"</span></span><br><span class="line"><span class="comment"># 删除 Clover 的守护进程</span></span><br><span class="line">launchctl unload <span class="string">'/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'</span></span><br><span class="line">rm -rf <span class="string">'/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverDaemonNew'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverLogOut'</span></span><br><span class="line">rm -rf <span class="string">'/Library/Application Support/Clover/CloverWrapper.sh'</span></span><br></pre></td></tr></table></figure><p>在迁移到OC后，最好再重置一次NVRAM，重置完后系统就完全是由OC来引导启动了，接下来就开启愉快的OC之旅了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前，OpenCore Bootloader已经开发了相当一段时间，已经趋近于稳定。OpenCore的启动方式更接近于原生macOS电脑，对系统的注入更少，越来越多的驱动都基于OpenCore适配开发。因此，将Bootloader从Clover迁移到OpenCore也是时候提上日程了。以下博客记录了我的迁移过程，并向大家分享一下我的迁移方法。不同于网上的纯ProperTree手动配置、纯OpenCore Configurator图形配置或OC Gen-X直接生成，我同时用到了以上三种工具，节省了迁移成本的同时，也避免遇到了很多错误。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hackintosh" scheme="http://www.fisheryung.top/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>获取米家MIIO设备Token</title>
    <link href="http://www.fisheryung.top/%E8%8E%B7%E5%8F%96%E7%B1%B3%E5%AE%B6miio%E8%AE%BE%E5%A4%87token.html"/>
    <id>http://www.fisheryung.top/获取米家miio设备token.html</id>
    <published>2021-02-28T12:52:04.000Z</published>
    <updated>2021-03-27T08:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因毕设选题是和物联网相关的主题，要做一个能够控制智能家居设备的微信小程序。所以就有了自由控制米家智能家居设备的需求，想要控制米家MIIO设备，就需要获取智能设备的token。但小米对获取token的方法不断进行封堵，截止这篇博客发布时，通过Android手机Root，读取旧版米家中存有token的sqlite文件已经不可行了（旧版米家APP直接闪退）；通过抓包的方式读取device_list包中的token也不行了（数据包的body已经被加密）；python-miio中discover方法也早已不行了（返回的是无效的token）。我所知道的方法中，使用<a href="https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor" target="_blank" rel="noopener">tokens-extractor</a>和读取IOS设备备份文件数据的方法还可以使用，但何时失效就不好说了</p><a id="more"></a><h1 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h1><p>最简单的方法当然是使用<a href="https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor" target="_blank" rel="noopener">Xiaomi Cloud Tokens Extractor</a>了，该脚本模拟Android米家APP的登录，以直接获取到自己账号下的智能设备信息，就能直接拿到token了。操作的流程也很简单，下载脚本运行即可，脚本需要依赖python的requests库，以下是简单的shell代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests</span><br><span class="line">wget https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor/raw/master/token_extractor.py</span><br><span class="line">python3 token_extractor.py</span><br></pre></td></tr></table></figure><p>按照脚本中的提示输入账号密码，选择地区（一般是cn），然后看输出即可，如下图所示：</p><p><img src="./images/miio/token_success.png" alt="成功获取token"></p><p>但是，这个脚本不是一直都成功的，以上图片是我在2021年2月初时获取成功后截图的。如果出现脚本不能用的情况，就要等待作者更新脚本了，在这里先对作者说声辛苦了，非常感谢！</p><h1 id="读取IOS设备备份文件数据"><a href="#读取IOS设备备份文件数据" class="headerlink" title="读取IOS设备备份文件数据"></a>读取IOS设备备份文件数据</h1><p>这个方法相对来说比较麻烦，尤其是对于我这种手机文件多的，备份一次要好久…但是没办法，活还是得干嘛，至于小米何时再给数据文件来个加密，那就真的是麻烦了</p><h2 id="将设备备份"><a href="#将设备备份" class="headerlink" title="将设备备份"></a>将设备备份</h2><p>首先要修改一下备份的选项，在手机摘要页面的备份中，将<code>给iPhone备份加密</code>选项关掉，如下图所示，然后再点击立即备份，等待备份完成即可</p><p><img src="./images/miio/backup.png" alt="备份选项"></p><h2 id="iBackup-Viewer导出数据"><a href="#iBackup-Viewer导出数据" class="headerlink" title="iBackup Viewer导出数据"></a>iBackup Viewer导出数据</h2><p>点击<a href="https://www.imactools.com/iphonebackupviewer/" target="_blank" rel="noopener">这里</a>可以下载iBackup Viewer，下载完后安装即可，如果这个网站打不开，也可以下载我的服务器<a href="https://fisher.lazybone.xyz/downloads/software/iBackupViewer.dmg" target="_blank" rel="noopener">提供</a>的4.1760版本，安装完之后打开软件，点击自己刚刚备份的那个设备（那个壁纸可以点的），载入备份后点最后一个像分支一样的图标（Raw Files）。</p><p>在<code>AppDomain</code>中找到<code>com.xiaomi.mihome</code>并点击，此时右侧就显示米家APP备份的数据，在右侧点击<code>Name</code>以按照文件名排序，看到一个名为<code>xxx_mihome.sqlite</code>的文件后（xxx是你的小米账号ID），选择这个文件并点击右上角<code>Export</code>，点击<code>Selected...</code>，选择一个位置将这个文件导出即可，以下是操作流程图：</p><p><img src="./images/miio/export.png" alt="导出sqlite文件"></p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取数据需要用到<code>python-miio</code>包，安装一下即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-miio</span><br></pre></td></tr></table></figure><p>接着使用<code>miio-extract-tokens</code>读取数据就可以获得token了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miio-extract-tokens --dump-all xxx_mihome.sqlite</span><br></pre></td></tr></table></figure><p><img src="./images/miio/extract.png" alt="读取数据"></p><p>拿到token后，就能够做自己想做的事情了^_^</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因毕设选题是和物联网相关的主题，要做一个能够控制智能家居设备的微信小程序。所以就有了自由控制米家智能家居设备的需求，想要控制米家MIIO设备，就需要获取智能设备的token。但小米对获取token的方法不断进行封堵，截止这篇博客发布时，通过Android手机Root，读取旧版米家中存有token的sqlite文件已经不可行了（旧版米家APP直接闪退）；通过抓包的方式读取device_list包中的token也不行了（数据包的body已经被加密）；python-miio中discover方法也早已不行了（返回的是无效的token）。我所知道的方法中，使用&lt;a href=&quot;https://github.com/PiotrMachowski/Xiaomi-cloud-tokens-extractor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tokens-extractor&lt;/a&gt;和读取IOS设备备份文件数据的方法还可以使用，但何时失效就不好说了&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.fisheryung.top/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="毕设" scheme="http://www.fisheryung.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码编译</title>
    <link href="http://www.fisheryung.top/jdk%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.html"/>
    <id>http://www.fisheryung.top/jdk源码编译.html</id>
    <published>2021-02-13T02:19:37.000Z</published>
    <updated>2021-02-14T01:54:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>考完研之后，接下来要准备的就是实习了。我也想尝试一下去春招，做好两手准备，所以需要开始学习面试要用到的知识了。我做过的比较好的项目主要使用的是Java，但之前都仅限于使用Java语言，并没有去看过Java的源码。为了深入理解Java这门语言（其实是为了准备面试），我将尝试去看Java的源码，注释写上自己的理解，并将这份源码编译，然后作为自己编译的第一个JDK使用。</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>前期的准备包括以下内容：</p><ul><li>源码和BootJDK的下载</li><li>检查和安装编译需要用到的Toolchain</li></ul><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p>源码下载很简单，去GitHub的<a href="https://github.com/openjdk" target="_blank" rel="noopener">OpenJDK</a>项目组里面找到需要编译的JDK版本对应的仓库，Clone下来即可</p><p>这里我编译的是JDK15，仓库地址在<a href="https://github.com/openjdk/jdk15" target="_blank" rel="noopener">这里</a>，这里我把源码Clone到Document中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Document</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openjdk/jdk15.git</span><br></pre></td></tr></table></figure><h2 id="BootJDK下载"><a href="#BootJDK下载" class="headerlink" title="BootJDK下载"></a>BootJDK下载</h2><p>编译需要一个BootJDK，用这个BootJDK去编译一个新的JDK出来，这个就有点像鸡生蛋，蛋生鸡的问题了hh</p><p>可以用本机已有的JDK，但是如果版本太老的话也有可能出现编译失败的问题，为了保证编译能够成功，我这里下载了JDK15作为BootJDK</p><p>下载JDK的网址在<a href="https://jdk.java.net/" target="_blank" rel="noopener">这里</a>，找到对应的系统版本点下载就好了，下载完之后解压到自己记得的地方</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf openjdk-15.0.2_osx-x64_bin.tar.gz -C /Users/fisher/Document</span><br></pre></td></tr></table></figure><h2 id="检查和安装ToolChain"><a href="#检查和安装ToolChain" class="headerlink" title="检查和安装ToolChain"></a>检查和安装ToolChain</h2><p>macOS首先需要检查安装Xcode command line tool，可以选择在App Store中直接安装Xcode，也可以在终端中使用以下命令仅安装Command line tool</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>接着检查clang，clang++，autoconf，make和freetype</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang --version</span><br><span class="line">clang++ --version</span><br><span class="line">autoconf --version</span><br><span class="line">make --version</span><br><span class="line">freetype-config --ftversion</span><br></pre></td></tr></table></figure><p>如果没有安装的话，使用homebrew安装即可，这里以freetype为例子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install freetype</span><br></pre></td></tr></table></figure><p>其他系统的ToolChain检查安装，可以参考<a href="https://github.com/openjdk/jdk/blob/master/doc/building.md#native-compiler-toolchain-requirements" target="_blank" rel="noopener">这份</a>文档</p><h1 id="配置与编译"><a href="#配置与编译" class="headerlink" title="配置与编译"></a>配置与编译</h1><p>前期准备工作完成后，就可以开始配置和编译了</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>切换到源码的目录下，使用<code>bash configure</code>命令配置，这里我使用2个参数，分别是：目标系统位数，BootJDK位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> jdk15source</span><br><span class="line">bash configure --with-target-bits=64 --with-boot-jdk=/Users/fisher/Documents/jdk15/Contents/Home</span><br></pre></td></tr></table></figure><p>接着就开始滚屏了，如果中途出现缺少依赖等提示，安装提示安装对应的依赖即可。当看到以下界面的时候，就说明编译前的配置成功了，可以正式开始编译了</p><p><img src="images/jdk/configure.png" alt="编译配置成功"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在源码跟目录下使用<code>make images</code>命令编译，等待一段时间就可以编译完了</p><p>Linux建议系统内存要8G以上，我的虚拟机6G内存在编译到JavaDoc的时候出现了内存不足编译失败的情况</p><p><img src="images/jdk/compile.png" alt="编译完成"></p><p>看到以上图片，就表示编译已经完成</p><h1 id="验证编译结果"><a href="#验证编译结果" class="headerlink" title="验证编译结果"></a>验证编译结果</h1><p>切换目录到<code>./build/macosx-x86_64-server-release/jdk</code>下，用<code>./bin/java --version</code>就能看到自己编译的成果了</p><p><img src="images/jdk/verification.png" alt="验证编译成果"></p><p>接下来在IDEA中添加自己刚刚编译的JDK，将<code>source</code>定位到编译JDK使用的源码，在写代码和debug的时候就能够边看自己写的注释边工作了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;考完研之后，接下来要准备的就是实习了。我也想尝试一下去春招，做好两手准备，所以需要开始学习面试要用到的知识了。我做过的比较好的项目主要使用的是Java，但之前都仅限于使用Java语言，并没有去看过Java的源码。为了深入理解Java这门语言（其实是为了准备面试），我将尝试去看Java的源码，注释写上自己的理解，并将这份源码编译，然后作为自己编译的第一个JDK使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.fisheryung.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器更换国内软件源</title>
    <link href="http://www.fisheryung.top/docker%E5%AE%B9%E5%99%A8%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E8%BD%AF%E4%BB%B6%E6%BA%90.html"/>
    <id>http://www.fisheryung.top/docker容器更换国内软件源.html</id>
    <published>2020-07-19T07:54:04.000Z</published>
    <updated>2020-07-19T08:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Docker容器使用apt作为软件包管理器，并且默认软件源是国外服务器，更新源和下载软件的速度都非常慢，因此需要更换为国内的软件源。但由于容器十分纯净，甚至连vi和vim都没有，不能通过编辑器打开修改软件源配置文件，关于这个问题的解决方法，我们可以使用shell的管道直接修改软件源配置文件。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><a id="more"></a><p>我们可以通过管道来将国内软件源地址写入到配置文件中，具体操作如下：</p><ol><li><p>进入容器，备份yum源配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it container bash</span><br><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure></li><li><p>写入国内软件源地址，此处用的是网易的软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/apt/sources.list &lt;&lt; EOF</span><br><span class="line">deb http://mirrors.163.com/debian/ buster main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian/ buster-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-updates main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian/ buster-backports main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-backports main contrib non-free</span></span><br><span class="line">deb http://mirrors.163.com/debian-security buster/updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian-security buster/updates main contrib non-free</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><img src="images/docker/writeconf.png" alt="写入配置"></p></li><li><p>更新apt软件包索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p><img src="images/docker/updateapt.png" alt="更新包索引"></p></li><li><p>安装所需要的软件包，完成！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vim -y</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;Docker容器使用apt作为软件包管理器，并且默认软件源是国外服务器，更新源和下载软件的速度都非常慢，因此需要更换为国内的软件源。但由于容器十分纯净，甚至连vi和vim都没有，不能通过编辑器打开修改软件源配置文件，关于这个问题的解决方法，我们可以使用shell的管道直接修改软件源配置文件。&lt;/p&gt;&lt;h1 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h1&gt;
    
    </summary>
    
    
      <category term="服务器配置" scheme="http://www.fisheryung.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker" scheme="http://www.fisheryung.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于Docker的Redis集群搭建</title>
    <link href="http://www.fisheryung.top/%E5%9F%BA%E4%BA%8Edocker%E7%9A%84redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html"/>
    <id>http://www.fisheryung.top/基于docker的redis集群搭建.html</id>
    <published>2020-07-19T07:53:09.000Z</published>
    <updated>2020-07-19T08:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h1><ul><li>操作系统：CentOS8，由Vmware虚拟机创建，网络使用桥接模式</li><li>Docker版本：19.03.12</li><li>Redis版本：5.0.3</li></ul><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>安装并启动Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker -y</span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure><p>获取Redis镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="创建集群配置文件模板"><a href="#创建集群配置文件模板" class="headerlink" title="创建集群配置文件模板"></a>创建集群配置文件模板</h1><p>首先创建一个文件夹，用于存放配置文件模板，稍后也用于存放Redis集群数据文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/redis_cluster</span><br><span class="line"><span class="built_in">cd</span> ~/redis_cluster</span><br></pre></td></tr></table></figure><p>新建模板文件<code>vim redis_cluster.tmpl</code>，并写入以下配置（注意此处的Cluster IP，需要根据自己的宿主机IP地址来填写）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Redis Port</span><br><span class="line">port $&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"># Protected mode off</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># Cluster enable</span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># Cluster node conf</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"></span><br><span class="line"># Timeout</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line"># Cluster IP</span><br><span class="line">cluster-announce-ip 192.168.1.103</span><br><span class="line"></span><br><span class="line"># Cluster Port-range: 8090-8095</span><br><span class="line">cluster-announce-port $&#123;PORT&#125;</span><br><span class="line">cluster-announce-bus-port 1$&#123;PORT&#125;</span><br><span class="line"></span><br><span class="line"># Enable append only back up mode</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># Back up frequency</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># Disable aof comprass sync</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># Aof rewrite percentage</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line"># Aof rewrite size</span><br><span class="line">auto-aof-rewrite-min-size 512mb</span><br><span class="line"></span><br><span class="line"># Disable back up</span><br><span class="line">save &quot;&quot;</span><br></pre></td></tr></table></figure><h1 id="新建批量生成单个Redis配置的脚本"><a href="#新建批量生成单个Redis配置的脚本" class="headerlink" title="新建批量生成单个Redis配置的脚本"></a>新建批量生成单个Redis配置的脚本</h1><p><code>vim mkconf.sh</code>，随后填入以下内容，此处我的Redis集群端口从8090开始到8095，可根据需要自行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> `seq 8090 8095`; <span class="keyword">do</span> \</span><br><span class="line">    mkdir -p ./<span class="variable">$&#123;port&#125;</span>/conf \</span><br><span class="line">    &amp;&amp; PORT=<span class="variable">$&#123;port&#125;</span> envsubst &lt; ./redis_cluster.tmpl &gt; ./<span class="variable">$&#123;port&#125;</span>/conf/redis.conf \</span><br><span class="line">    &amp;&amp; mkdir -p ./<span class="variable">$&#123;port&#125;</span>/data; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后赋予可执行权限并运行该脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x mkconf.sh</span><br><span class="line">./mkconf.sh</span><br></pre></td></tr></table></figure><h1 id="新建批量生成Docker容器的脚本"><a href="#新建批量生成Docker容器的脚本" class="headerlink" title="新建批量生成Docker容器的脚本"></a>新建批量生成Docker容器的脚本</h1><p><code>vim mkcontainer.sh</code>，随后填入以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> `seq 8090 8095`; <span class="keyword">do</span> \</span><br><span class="line">    docker run -d -it \</span><br><span class="line">        -v ~/redis_cluster/<span class="variable">$&#123;port&#125;</span>/conf/redis.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf \</span><br><span class="line">        -v ~/redis_cluster/<span class="variable">$&#123;port&#125;</span>/data:/data \</span><br><span class="line">        --restart always --name redis-<span class="variable">$&#123;port&#125;</span> --net host \</span><br><span class="line">        --sysctl net.core.somaxconn=1024 redis redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf; \</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="建立Redis集群"><a href="#建立Redis集群" class="headerlink" title="建立Redis集群"></a>建立Redis集群</h1><p>如果宿主机已经安装了<code>redis-cli</code>，就不用进入到容器内部了，可以直接在宿主机上操作</p><p>如果宿主机没有安装<code>redis-cli</code>，则执行以下命令随便进入一个容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis-8090 bash</span><br></pre></td></tr></table></figure><p>执行以下命令创建集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.1.103:8090 192.168.1.103:8091 192.168.1.103:8092 192.168.1.103:8093 192.168.1.103:8094 192.168.1.103:8095 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p><img src="images/docker/createcluster.png" alt="创建集群"></p><p>出现以上图中的询问，输入yes回车即可，自此Redis集群就创建成功了</p><h1 id="验证集群可用性"><a href="#验证集群可用性" class="headerlink" title="验证集群可用性"></a>验证集群可用性</h1><p>登录其中的一个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.1.18 -p 8090</span><br></pre></td></tr></table></figure><p>查看集群节点信息，同时也可以试着写入数据，能查看到节点信息，能写入、读取数据，表示集群搭建成功</p><p><img src="images/docker/clusternodes.png" alt="集群节点信息"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本机环境&quot;&gt;&lt;a href=&quot;#本机环境&quot; class=&quot;headerlink&quot; title=&quot;本机环境&quot;&gt;&lt;/a&gt;本机环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;操作系统：CentOS8，由Vmware虚拟机创建，网络使用桥接模式&lt;/li&gt;
&lt;li&gt;Docker版本：19.03.12&lt;/li&gt;
&lt;li&gt;Redis版本：5.0.3&lt;/li&gt;
&lt;/ul&gt;&lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;p&gt;安装并启动Docker&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install docker -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo service docker start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;获取Redis镜像&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull redis&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="服务器配置" scheme="http://www.fisheryung.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker" scheme="http://www.fisheryung.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Mumble搭建语音服务器</title>
    <link href="http://www.fisheryung.top/%E4%BD%BF%E7%94%A8mumble%E6%90%AD%E5%BB%BA%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>http://www.fisheryung.top/使用mumble搭建语音服务器.html</id>
    <published>2020-03-19T03:14:14.000Z</published>
    <updated>2020-03-19T09:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前与朋友一起在CSGO开黑时一直用的是微信语音，没有按键发言用的很不顺手。YY语音的广告太多不忍直视，Discord又被墙了。正好自己有个阿里云的服务器，就想着自己搭建一个语音服务器，也方便上网课的时候建立讨论组。于是乎上网查找了一番，找到了一个叫Mumble的语音软件，它的语音客户端全平台支持，官方的搭建文档介绍详细，简直就是开黑神器。话不多说，接下来就是我的搭建过程</p><a id="more"></a><h1 id="下载Mumble服务器安装包"><a href="#下载Mumble服务器安装包" class="headerlink" title="下载Mumble服务器安装包"></a>下载Mumble服务器安装包</h1><p>Mumble官方下载页面在<a href="https://www.mumble.info/downloads/" target="_blank" rel="noopener">这里</a>，选择下载<code>Static Linux Server</code>，然后从浏览器的下载管理中把下载链接复制出来，在服务器上使用<code>wget DOWNLOAD_ADDERSS</code>下载（DOWNLOAD_ADDRESS为刚刚复制的下载链接）</p><p>如果官方链接太慢的话，我的服务器上也提供了Mumble V1.3.0的服务器安装包、Windows安装包、macOS安装包，需要的可以从<a href="http://fisher.lazybone.xyz/downloads/software/" target="_blank" rel="noopener">这个</a>页面找到并下载。使用我的服务器提供的下载地址下载Mumble Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://fisher.lazybone.xyz/downloads/software/murmur-static_x86-1.3.0.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="解压安装包、添加用户和用户组"><a href="#解压安装包、添加用户和用户组" class="headerlink" title="解压安装包、添加用户和用户组"></a>解压安装包、添加用户和用户组</h1><p>下载完安装包后，解压并移动到指定目录下。同时从安装包中复制一份配置文件到<code>/etc</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf ./murmur-static_x86-1.3.0.tar.bz2</span><br><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/murmur</span><br><span class="line">sudo cp -r ./murmur-static_x86-1.3.0/* /usr/<span class="built_in">local</span>/murmur/</span><br><span class="line">sudo cp ./murmur-static_x86-1.3.0/murmur.ini /etc/murmur.ini</span><br></pre></td></tr></table></figure><p>创建用户、用户组、数据文件夹和日志文件夹。同时修改创建的文件和文件夹的权限、拥有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd -r murmur</span><br><span class="line">sudo useradd -r -g murmur -m -d /var/lib/murmur -s /sbin/nologin murmur</span><br><span class="line">sudo mkdir /var/<span class="built_in">log</span>/murmur</span><br><span class="line">sudo chown murmur:murmur /var/<span class="built_in">log</span>/murmur</span><br><span class="line">sudo chmod 0770 /var/<span class="built_in">log</span>/murmur</span><br></pre></td></tr></table></figure><h1 id="配置服务器参数"><a href="#配置服务器参数" class="headerlink" title="配置服务器参数"></a>配置服务器参数</h1><p>使用vim编辑<code>murmur.ini</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/murmur.ini</span><br></pre></td></tr></table></figure><p>指定以下3个参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database=/var/lib/murmur/murmur.sqlite</span><br><span class="line">logfile=/var/<span class="built_in">log</span>/murmur/murmur.log</span><br><span class="line">pidfile=/var/run/murmur/murmur.pid</span><br></pre></td></tr></table></figure><p>以下参数可根据自己需要修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 欢迎进入服务器信息，可以修改成自己喜欢的</span></span><br><span class="line">welcometext=<span class="string">"Welcome to Fisher's mumble server!"</span></span><br><span class="line"><span class="comment"># 语音服务器端口，待会对应防火墙端口需要打开</span></span><br><span class="line">port=64738</span><br><span class="line"><span class="comment"># 服务器密码，进入服务器时会询问输入</span></span><br><span class="line">serverpassword=12345678</span><br><span class="line"><span class="comment"># 最大语音带宽，我改成了128kbit/s，可根据自己需要修改</span></span><br><span class="line">bandwidth=128000</span><br><span class="line"><span class="comment"># 最多允许多少名用户进入服务器</span></span><br><span class="line">users=10</span><br></pre></td></tr></table></figure><h1 id="添加系统服务模块"><a href="#添加系统服务模块" class="headerlink" title="添加系统服务模块"></a>添加系统服务模块</h1><p>添加系统服务单元，以允许Mumble在后台运行</p><p>使用<code>root</code>权限创建<code>murmur.service</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/murmur.serivce</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur.service</code>中，然后保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Mumble Server (Murmur)</span><br><span class="line">Requires=network-online.target</span><br><span class="line">After=network-online.target mariadb.service time-sync.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=murmur</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/murmur/murmur.x86 -ini /etc/murmur.ini</span><br><span class="line">PIDFile=/var/run/murmur/murmur.pid</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>由于现在的操作系统会在重启时放弃<code>var/run</code>中的更改，为了重新创建Mumble的PID文件夹，我们需要创建<code>murmur.conf</code>文件</p><p>使用<code>root</code>权限创建<code>murmur.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/tmpfiles.d/murmur.conf</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur.conf</code>中，然后保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d /var/run/murmur 775 murmur murmur</span><br></pre></td></tr></table></figure><h1 id="配置日志文件"><a href="#配置日志文件" class="headerlink" title="配置日志文件"></a>配置日志文件</h1><p>使用<code>root</code>权限创建<code>murmur</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/logrotate.d/murmur</span><br></pre></td></tr></table></figure><p>将以下数据复制到<code>murmur</code>中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/murmur/*<span class="built_in">log</span> &#123;</span><br><span class="line">    su murmur murmur</span><br><span class="line">    dateext</span><br><span class="line">    rotate 4</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    sharedscripts</span><br><span class="line">    delaycompress</span><br><span class="line">    postrotate</span><br><span class="line">        /bin/systemctl reload murmur.service &gt; /dev/null 2&gt;/dev/null || <span class="literal">true</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h1><p>不同的云服务器商设置防火墙的方式不同。对于阿里云的轻量服务器，服务器的管理界面中点击防火墙，添加TCP和UDP的64738端口（端口根据上面配置文件改变而改变）</p><p><img src="images/mumble/firewall.png" alt="防火墙配置"></p><h1 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h1><p>刷新系统服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemd-tmpfiles --create /etc/tmpfiles.d/murmur.conf</span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>允许开机自动启动Mumble服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> murmur.service</span><br></pre></td></tr></table></figure><p>正式启动Mumble服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start murmur.service</span><br></pre></td></tr></table></figure><p>当看到<code>active(running)</code>时，表示Mumble服务器启动成功</p><p><img src="images/mumble/start.png" alt="启动服务器"></p><h1 id="连接服务器，完成！"><a href="#连接服务器，完成！" class="headerlink" title="连接服务器，完成！"></a>连接服务器，完成！</h1><p>打开自己电脑上的Mumble，点击左上角小地球，点击添加，填入自己的服务器地址，用户名自己起一个喜欢的（不能是<code>SpuerUser</code>，这是Mumble管理员账号）。点击OK后连接，输入密码，大功告成！</p><p><img src="images/mumble/add.png" alt="添加服务器"></p><h1 id="进阶操作：添加、修改频道"><a href="#进阶操作：添加、修改频道" class="headerlink" title="进阶操作：添加、修改频道"></a>进阶操作：添加、修改频道</h1><p>如果使用的小伙伴太多了，需要分开不同的频道使用的时候，就需要使用<code>SuperUser</code>用户连接服务器并对<code>root</code>频道进行修改了。要使用<code>SuperUser</code>很简单，可以使用首次启动时系统随机分配的密码，也可以自己设置一个密码</p><h3 id="对于系统随机分配的密码，使用以下命令："><a href="#对于系统随机分配的密码，使用以下命令：" class="headerlink" title="对于系统随机分配的密码，使用以下命令："></a>对于系统随机分配的密码，使用以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/murmur/murmur.log</span><br></pre></td></tr></table></figure><p>查找<code>&lt;W&gt;year-month-day hour:min:sec 1 =&gt; Password for &#39;SuperUser&#39; set to &#39;supersecretpassword&#39;</code>这条日志，密码就是那一串<code>supersecretpassword</code>。由于我的服务器用了好久了，那一串日志被覆盖掉了，这里就没有截图了（逃</p><h3 id="对于自己设置一个密码，使用以下命令即可："><a href="#对于自己设置一个密码，使用以下命令即可：" class="headerlink" title="对于自己设置一个密码，使用以下命令即可："></a>对于自己设置一个密码，使用以下命令即可：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/murmur</span><br><span class="line">./murmur.x86 -ini /etc/murmur.ini -supw PASSWORD</span><br></pre></td></tr></table></figure><p>其中<code>PASSWORD</code>改成自己想要设定的密码。接下来在Mumble软件中添加自己的服务器，用户名使用<code>SuperUser</code>，密码填自己刚刚设置的密码</p><p><img src="images/mumble/super.png" alt="SuperUser"></p><p>连接到服务器后，对着<code>root</code>频道右键，就可以进行频道添加、修改、删除的操作了。最后配置一下自己的音频输入输出，就可以愉快地与朋友开黑了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前与朋友一起在CSGO开黑时一直用的是微信语音，没有按键发言用的很不顺手。YY语音的广告太多不忍直视，Discord又被墙了。正好自己有个阿里云的服务器，就想着自己搭建一个语音服务器，也方便上网课的时候建立讨论组。于是乎上网查找了一番，找到了一个叫Mumble的语音软件，它的语音客户端全平台支持，官方的搭建文档介绍详细，简直就是开黑神器。话不多说，接下来就是我的搭建过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://www.fisheryung.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="服务器配置" scheme="http://www.fisheryung.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题三</title>
    <link href="http://www.fisheryung.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%B8%89.html"/>
    <id>http://www.fisheryung.top/操作系统习题三.html</id>
    <published>2020-01-05T11:45:23.000Z</published>
    <updated>2020-01-05T11:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一、试说明I/O系统的基本功能。</p><ul><li>隐藏物理设备的细节</li><li>与设备的无关性</li><li>提高处理机和I/O设备的利用率</li><li>对I/O设备进行控制</li><li>确保对设备的正确共享</li><li>错误处理</li></ul><p>二、简要说明I/O软件的四个层次的基本功能。</p><ul><li>用户层I/O软件：实现与用户交互的接口，用户可直接调用提供的库函数对I/O设备进行操作</li><li>设备独立性软件：实现用户程序与设备驱动器的统一接口</li><li>设备驱动程序：具体实现系统对设备发出的操作指令，驱动I/O设备工作</li><li>中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序</li></ul><a id="more"></a><p>三、与设备无关性的基本含义是什么？为什么要设置该层？</p><p>其基本含义是：I/O软件独立于具体使用的物理设备，隐藏了物理设备的细节。设置该层提高了I/O系统的可适应性和可扩展性，用户使用设备时可以使用逻辑设备，而不必指定物理设备，在增加新设备或替换老设备时，不需要对I/O软件进行修改，方便了系统的更新和扩展</p><p>四、为了实现CPU与设备控制器间的通信，设备控制器应具备哪些功能？</p><ul><li>接收和识别命令：设备控制器能够接受并识别处理机发来的各种命令</li><li>数据交换：控制器与CPU之间、控制器之间、控制器与物理设备之间的数据交换</li><li>标识和报告设备的状态：记录设备的状态，提供给CPU</li><li>地址识别：识别所控制的每个设备的地址</li><li>数据缓冲区：暂存由高速主机、设备传来的数据</li><li>差错控制：保证数据输入输出的正确性</li></ul><p>五、什么是内存映像I/O？它是如何实现的？</p><p>内存映像I/O在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用统一的地址。地址的一部分范围认为是内存地址，另一部分则认为是某个控制器的寄存器地址</p><p>六、为什么说中断是OS赖以生存的基础？</p><p>因为进程之间的切换是通过中断来完成的，如果没有了中断，就不能实现多道程序，OS也就不复存在了</p><p>七、对多中断源的两种处理方式分别用于何种场合？</p><p>屏蔽中断：对实时性要求较低的中断请求，并且被屏蔽的中断重要性不高，不影响系统的运行</p><p>嵌套中断：对实时性要求较高的中断请求，并且中断处理能够以较快的速度完成</p><p>八、简要说明中断处理程序对中断进行处理的几个步骤。</p><p>测定是否有未响应的中断信号，保护被中断进程的CPU环境，转入到相应的设备处理程序，恢复CPU现场并退出中断</p><p>九、有哪几种I/O控制方式？各适用于何种场合？</p><p>使用轮询的可编程I/O方式：适用于结构简单，只需要少量硬件的电路中</p><p>使用中断的可编程I/O方式：适用于现在操作系统中，对I/O设备效率要求高的计算机中</p><p>十、试说明DMA的工作流程。</p><p>首先设置MAR和DC的初值，然后启动DMA传送命令，接着挪用储存器周期传送数据，每次传送中储存器地址+1、DC-1，如果DC=0，表示本次传送完成，DMA可以发送中断请求，如果DC不等于0，则表示数据未传送完成</p><p>十一、为何要引入与设备的无关性？如何实现设备的独立性？</p><p>在没有设备无关性的情况下，应用程序在使用I/O设备的时候需要指定设备的物理名称，如果该设备已经分配给其他进程并且是独占设备，那么会引起应用程序的阻塞，并且更换设备时，应用程序也需要更新物理设备名称，给用户带来了许多麻烦。现代操作系统通过引入逻辑设备，将逻辑设备映射到物理设备上实现了设备的独立性，并且实现了I/O重定向</p><p>十二、在考虑到设备的独立性时，应如何分配独占设备？</p><p>OS接到对设备的请求后，先对进程所请求的独占设备进行检查，看该设备是否空闲。若空闲才把设备分配给请求进程，否则进程阻塞，放入到该设备的请求队列中等待。等到其他进程释放该设备时，再将队列中的第一个进程唤醒，该进程的到设备后继续运行</p><p>十三、何谓设备虚拟？实现设备虚拟时所依赖的关键技术是什么？</p><p>设备虚拟可以将一个物理设备模拟成多个逻辑上的不同的设备，从而允许多个用户共享使用一个设备。实现设备虚拟需要系统配置一张逻辑设备表，以记录物理设备到虚拟设备的映射，还需要系统对虚拟设备资源分配与回收的支持</p><p>十四、在实现后台打印时，SPOOLIng系统应为请求I/O的进程提供哪些服务？</p><p>输入井和输出井：用于收容I/O设备输入和输出的数据，将数据暂存在磁盘上</p><p>输入缓冲区和输出缓冲区：缓冲区位于内存中，用于缓和CPU和磁盘之间速度不匹配的矛盾</p><p>输入进程和输出进程：用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区</p><p>井管理程序：控制作业与磁盘井之间信息的交换</p><p>十五、假脱机系统向用户提供共享打印机的基本思想是什么？</p><p>将打印的队列和数据存放在磁盘缓冲区中，用户看见的是打印已经成功完成，而打印机从队列中取出要打印的数据进行打印</p><p>十六、引入缓冲的主要原因是什么？</p><p>缓和CPU与I/O设备之间速度不匹配的矛盾，减少对CPU的中断频率，放宽对CPU中断相应时间的限制，解决数据粒度不匹配的问题，提高CPU与I/O设备之间的并行性</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>一、何谓数据项、记录和文件？</p><p>数据项：最低级的数据组织形式 ，可以分为基本数据项和组合数据项。基本数据项用于描述一个对象的某种属性的字符集。组合数据项是由若干个基本数据项组成的，简称组项</p><p>记录：是一组相关数据项的集合，用于描述一个对象在某方面的属性</p><p>文件：指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种</p><p>二、文件系统的模型可分为三层，试说明其每一层所包含的基本内容。</p><p>对象及其属性：管理了以下的对象：文件，文件系统中各种类型的文件都作为文件管理的直接对象。目录，是为了方便用户对文件的存取和检索，也提高了对文件的存取速度。磁盘储存空间，对存储空间的有效管理不仅能提高外存的利用率，还能提高对文件的存取速度</p><p>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分，文件系统的功能大多是在这一层实现的，其中包括有：对文件存储空间的管理；对文件目录的管理；用于将文件的逻辑地址转换为物理地址的机制；对文件读写的管理；对文件的共享与保护等功能</p><p>文件系统接口：提供了一组对文件和记录操作的方法和手段，通常是命令接口和程序接口</p><p>三、与文件系统有关的软件可分为哪几个层次？</p><p>I/O控制层，基本文件系统层，基本I/O管理程序，逻辑文件系统</p><p>四、试说明用户可以对文件施加的主要操作有哪些。</p><p>创建文件，删除文件，读文件，写文件，设置文件的读写位置，打开文件，关闭文件，改变文件名，改变文件的拥有者，改变对文件的访问权，查询文件的状态</p><p>五、何谓文件的逻辑结构？何谓文件的物理结构？</p><p>文件的逻辑结构：即用户所看到的文件，它是由一系列的逻辑记录组成的，是能够被存取的基本单位，是用户可以直接处理的数据及其结构</p><p>文件的物理结构：又称为文件储存结构，指系统将文件储存在外存上所形成的一种储存组织形式，是用户不能看见的</p><p>六、按文件的组织方式可将文件分为哪几种类型？</p><p>普通文件，包括源程序文件、数据文件以及操作系统自身代码文件等</p><p>目录文件，由文件目录组成的文件，通过目录文件可以对齐下属文件的信息进行检索</p><p>特殊文件，指系统中的各类I/O设备，对这些文件的操作将由设备驱动程序来完成</p><p>七、如何提高对变长记录顺序文件的检索速度？</p><p>按照关键字建立索引，为主文件中的每个记录在索引表中分别设置一个表项，记录指向储存地址的指针，把对变长记录的检索转为对定长记录索引文件的随机检索，从而加快对记录检索的速度，实现直接存取</p><p>八、通过哪两种方式来对固定长记录实现随机访问？</p><p>直接文件：利用给定的记录简直，对线性表或链表进行检索，找到指定记录的物理地址</p><p>哈希文件：利用散列函数将关键字转换为某一目录表相应表项的指针，该表项的内容指向对应记录的物理地址</p><p>九、可以采取什么方法来实现对变长记录文件进行随机检索？</p><p>可采取索引顺序文件和哈希文件的方法实现</p><p>十、试说明索引顺序文件的几个主要特征。</p><p>记录是按关键字的顺序组织起来的。引入了文件索引表，通过对该表可以实现对索引顺序文件的随机访问。增加了溢出文件，用来记录新增加、删除、修改的记录</p><p>十一、试说明对索引文件和索引顺序文件的检索方法。</p><p>利用提供的关键字，在索引表中利用多种不同的搜索方法查找对应的表项，再利用表项给出的指向记录的指针值去访问所需要的记录</p><p>十二、试从检索速度和储存费用两方面来比较两级索引文件和索引顺序文件。</p><p>对于一个非常大的文件来说，索引顺序文件的检索速度还是比较慢，两级索引文件能够在大文件的检索中进一步提高检索速度。储存费用来说，两级索引文件的储存费用要比索引顺序文件要低</p><p>十三、对目录管理的主要要求是什么？</p><p>实现“按名存取”，用户只须项系统提供所需访问文件的名字，便能快速准确地找到指定文件在外存上的储存位置</p><p>提高对目录的检索速度，从而提高对文件的存取速度</p><p>实现文件共享，允许多个用户共享一个文件，节省大量的储存空间，方便用户和提高文件的利用率</p><p>允许文件重名，便于用户按照自己的习惯给文件命名和使用文件</p><p>十四、何谓路径名和当前目录？</p><p>路径名：在树形结构目录中，从根目录到任何数据文件的唯一通路</p><p>当前目录，某个进程运行时所在的路径地址</p><p>十五、Hash检索法有何优点？又有何局限性？</p><p>Hash检索法能够快速地检索到所需要的文件、记录的地址。但Hash检索法不能检索使用了通配符查找的文件和记录，既提供给Hash查找的文件、记录必须是明确的</p><p>十六、在Hash检索法中，如何解决“冲突”问题？</p><p>发生了“冲突”，表示某个路径通过Hash计算后与当前存在的表项重复了，则需要在Hash计算后再加上一个常数，直到形成新的，无冲突的索引值为止</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章&quot;&gt;&lt;a href=&quot;#第六章&quot; class=&quot;headerlink&quot; title=&quot;第六章&quot;&gt;&lt;/a&gt;第六章&lt;/h1&gt;&lt;p&gt;一、试说明I/O系统的基本功能。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;隐藏物理设备的细节&lt;/li&gt;
&lt;li&gt;与设备的无关性&lt;/li&gt;
&lt;li&gt;提高处理机和I/O设备的利用率&lt;/li&gt;
&lt;li&gt;对I/O设备进行控制&lt;/li&gt;
&lt;li&gt;确保对设备的正确共享&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二、简要说明I/O软件的四个层次的基本功能。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;用户层I/O软件：实现与用户交互的接口，用户可直接调用提供的库函数对I/O设备进行操作&lt;/li&gt;
&lt;li&gt;设备独立性软件：实现用户程序与设备驱动器的统一接口&lt;/li&gt;
&lt;li&gt;设备驱动程序：具体实现系统对设备发出的操作指令，驱动I/O设备工作&lt;/li&gt;
&lt;li&gt;中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://www.fisheryung.top/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验六：连续动态内存管理</title>
    <link href="http://www.fisheryung.top/%E8%BF%9E%E7%BB%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"/>
    <id>http://www.fisheryung.top/连续动态内存管理.html</id>
    <published>2019-12-21T08:02:37.000Z</published>
    <updated>2019-12-21T09:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统系列博客的所有实验源自于课程<code>&quot;操作系统原理与实践检验&quot;</code>，代码是参考老师给的<code>&quot;软件工程专业操作系统实验指导书&quot;</code>文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法</p><a id="more"></a><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>理解内存管理相关理论</li><li>掌握连续内存管理理论</li><li>掌握动态连续内存管理理论</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>本实验主要针对操作系统中内存管理相关理论进行实验，要求实验者编写一个程序，该程序管理一块虚拟内存，实现内存分配和回收功能</p><ul><li>模拟管理64M的内存块</li><li>设计内存分配函数</li><li>设计内存回收函数</li><li>实现动态分配和回收操作</li><li>可动态显示每个内存块信息</li></ul><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>数据结构，本次实验使用了三种数据结构，构成了2张表，1个双向链表，其定义如下：</p><ul><li>空闲分区表：起始地址（startAddr）、大小（size）、使用情况（status）</li><li>已使用内存表：起始地址（startAddr）、大小（size）</li><li>空闲分区双向链表：空闲分区表项（table）、上一节点（previous）、下一节点（next）</li></ul><p>内存分配算法：本次实验中使用了首次适应算法，该算法总是从内存的低地址出发，寻找第一个满足申请空间要求的空闲分区，然后将其分配给申请的进程。该算法思路简单，实现也比较简单，但是由于申请释放总是从低地址开始，因此低地址的内存碎片化会越来越严重，而高地址的内存使用次数却过少，在商业操作系统中，一般会将几种分配算法综合在一起使用。该算法的实现在下面代码汇总中的<code>allocate</code>函数</p><p>内存回收算法：在回收内存空间时，需要考虑以下四种情况，以达到合并连续空闲内存空间的目的</p><ul><li>回收区与插入点的前一个空闲分区相邻：回收区与前一个空闲分区合并，此时只需要修改前一个空闲分区的大小（size）即可</li><li>回收区与插入点的后一个空闲分区相邻：回收区与后一个空闲分区合并，此时需要修改后一个空闲分区的起始地址（startAddr）和大小（size）</li><li>回收区与插入点的前后空闲分区都相邻：此时需要把前后空闲分区和回收区一起合并，合并到前一空闲分区中，需要修改前一空闲分区的大小（size），同时删除后一空闲分区表项</li><li>回收区不与任何空闲分区相邻：为回收区新建一个空闲分区表项，插入到空闲分区表的对应位置中</li></ul><h1 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// 内存容量，单位为kb</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RAM_SIZE 65536</span></span><br><span class="line"><span class="comment">// 不可再分割的内存大小</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ALLOC_MIN_SIZE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲分区表-数据结构(Free Partition table)</span></span><br><span class="line"><span class="comment"> * 起始地址(内存地址-kb) | 大小(kb) | 使用情况(0:未使用 1:使用中)</span></span><br><span class="line"><span class="comment"> * startAddr | size | status</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> startAddr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲分区链-数据结构(Free Partition chain)</span></span><br><span class="line"><span class="comment"> * table: 指向对应的空闲分区表地址</span></span><br><span class="line"><span class="comment"> * previous: 双向链表的上一项</span></span><br><span class="line"><span class="comment"> * next: 双向链表的下一项</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpChain</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    fpTable *table;</span><br><span class="line">    fpChain *previous;</span><br><span class="line">    fpChain *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已使用的内存</span></span><br><span class="line"><span class="comment"> * 起始地址(内存地址-kb) | 大小(kb)</span></span><br><span class="line"><span class="comment"> * startAddr | size</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">used</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> startAddr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲分区表</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;fpTable *&gt; ramTable;</span><br><span class="line"><span class="comment">// 已使用分区表</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;used *&gt; usedTable;</span><br><span class="line"><span class="comment">// 空闲分区链</span></span><br><span class="line">fpChain *ramChain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化空闲分区表</span></span><br><span class="line">    fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">    tableNode-&gt;startAddr = <span class="number">0</span>;</span><br><span class="line">    tableNode-&gt;size = RAM_SIZE;</span><br><span class="line">    tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">    ramTable.push_back(tableNode);</span><br><span class="line">    <span class="comment">// 初始化空闲分区链</span></span><br><span class="line">    fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">    chainNode-&gt;table = tableNode;</span><br><span class="line">    chainNode-&gt;previous = chainNode;</span><br><span class="line">    chainNode-&gt;next = chainNode;</span><br><span class="line">    ramChain = chainNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看内存使用情况</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n=====空闲分区表================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"起始地址 | 大小(kb) | 使用情况\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%8d | %8d | %5d\n"</span>, ramTable[i]-&gt;startAddr, ramTable[i]-&gt;size, ramTable[i]-&gt;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"===============================\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=====已使用的分区表==========\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程号 | 起始地址 | 大小(kb)\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; usedTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%6d | %8d | %8d\n"</span>, i, usedTable[i]-&gt;startAddr, usedTable[i]-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=============================\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请内存分配</span></span><br><span class="line"><span class="comment"> * s: 申请的内存大小</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || s &gt; RAM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 参数错误！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有空闲内存了</span></span><br><span class="line">    <span class="keyword">if</span> (ramTable.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 内存已分配完毕，申请失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找满足要求的空闲内存块</span></span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    fpChain *chainPointer = ramChain;</span><br><span class="line">    fpTable *tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tablePointer-&gt;size - s) &gt;= ALLOC_MIN_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chainPointer = chainPointer-&gt;next;</span><br><span class="line">            tablePointer = chainPointer-&gt;table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="comment">// 内存空间不足</span></span><br><span class="line">    <span class="keyword">if</span> (!find)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 内存空间不足，申请失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配空间，添加到已使用分区表，修改空闲分区表、空闲分区链</span></span><br><span class="line">    used *usedPointer = <span class="keyword">new</span> used;</span><br><span class="line">    usedPointer-&gt;startAddr = tablePointer-&gt;startAddr;</span><br><span class="line">    usedPointer-&gt;size = s;</span><br><span class="line">    usedTable.push_back(usedPointer);</span><br><span class="line">    <span class="comment">// 寻找要修改的表项位置</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ramTable[i]-&gt;startAddr == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空间刚好分配完，删除分区表和分区链中对应表项</span></span><br><span class="line">    <span class="keyword">if</span> (tablePointer-&gt;size == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"INFO: 该块内存分配完毕，删除空闲分区表和分区链中对应项\n"</span>);</span><br><span class="line">        <span class="comment">// 删除表项</span></span><br><span class="line">        ramTable.erase(ramTable.begin() + pos);</span><br><span class="line">        <span class="comment">// 摘链</span></span><br><span class="line">        <span class="keyword">if</span> (ramTable.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 已无空闲分区，将空闲链表置为NULL\n"</span>);</span><br><span class="line">            ramChain = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果刚好是双向链表的头部，则使用下一节点作为链表头部</span></span><br><span class="line">            <span class="keyword">if</span> (chainPointer == ramChain)</span><br><span class="line">            &#123;</span><br><span class="line">                ramChain = chainPointer-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            chainPointer-&gt;next-&gt;previous = chainPointer-&gt;previous;</span><br><span class="line">            chainPointer-&gt;previous-&gt;next = chainPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> chainPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 分配之后仍有剩余空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"INFO: 该块内存仍有剩余空间，修改空闲分区表大小\n"</span>);</span><br><span class="line">        tablePointer-&gt;size -= s;</span><br><span class="line">        tablePointer-&gt;startAddr += s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放内存</span></span><br><span class="line"><span class="comment"> * index: 要释放内存的进程号</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= usedTable.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: 参数错误！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取要释放的内存块</span></span><br><span class="line">    used *usedPointer = usedTable[index];</span><br><span class="line">    <span class="comment">// 空链情况，直接新建空闲分区并插入</span></span><br><span class="line">    <span class="keyword">if</span> (ramChain == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">        tableNode-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">        tableNode-&gt;size = usedPointer-&gt;size;</span><br><span class="line">        tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">        ramTable.push_back(tableNode);</span><br><span class="line">        fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">        chainNode-&gt;table = tableNode;</span><br><span class="line">        chainNode-&gt;previous = chainNode;</span><br><span class="line">        chainNode-&gt;next = chainNode;</span><br><span class="line">        ramChain = chainNode;</span><br><span class="line">        usedTable.erase(usedTable.begin() + index);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非空链情况，寻求与前后空闲分区合并</span></span><br><span class="line">    fpChain *chainPointer = ramChain;</span><br><span class="line">    fpTable *tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 与前后空闲分区都相邻，合并前后空闲分区</span></span><br><span class="line">        <span class="keyword">if</span> ((tablePointer-&gt;startAddr + tablePointer-&gt;size == usedPointer-&gt;startAddr) &amp;&amp;</span><br><span class="line">            (usedPointer-&gt;startAddr + usedPointer-&gt;size == chainPointer-&gt;next-&gt;table-&gt;startAddr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与前后空闲分区都相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;size = tablePointer-&gt;size + usedPointer-&gt;size + chainPointer-&gt;next-&gt;table-&gt;size;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (chainPointer-&gt;next-&gt;table-&gt;startAddr == ramTable[i]-&gt;startAddr)</span><br><span class="line">                &#123;</span><br><span class="line">                    ramTable.erase(ramTable.begin() + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chainPointer-&gt;next-&gt;next-&gt;previous = chainPointer-&gt;next-&gt;previous;</span><br><span class="line">            chainPointer-&gt;next = chainPointer-&gt;next-&gt;next;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与前面空闲分区相邻，前面空闲分区空间增大</span></span><br><span class="line">        <span class="keyword">if</span> (tablePointer-&gt;startAddr + tablePointer-&gt;size == usedPointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与前面空闲分区相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;size += usedPointer-&gt;size;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与后面空闲分区相邻，后面空闲分区内存起址前移，扩大分区空间</span></span><br><span class="line">        <span class="keyword">if</span> (usedPointer-&gt;startAddr + usedPointer-&gt;size == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 与后面空闲分区相邻\n"</span>);</span><br><span class="line">            tablePointer-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">            tablePointer-&gt;size += usedPointer-&gt;size;</span><br><span class="line">            usedTable.erase(usedTable.begin() + index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chainPointer = chainPointer-&gt;next;</span><br><span class="line">        tablePointer = chainPointer-&gt;table;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="comment">// 非空链情况，新建独立空闲分区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INFO: 非空链情况，新建独立空闲分区\n"</span>);</span><br><span class="line">    <span class="comment">// 寻找插入点</span></span><br><span class="line">    chainPointer = ramChain;</span><br><span class="line">    tablePointer = chainPointer-&gt;table;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tablePointer-&gt;startAddr &gt; usedPointer-&gt;startAddr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chainPointer = chainPointer-&gt;next;</span><br><span class="line">            tablePointer = chainPointer-&gt;table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(chainPointer != ramChain);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"INFO: 插入点位于 %d\n"</span>, tablePointer-&gt;startAddr);</span><br><span class="line">    <span class="comment">// 新建分区并插入</span></span><br><span class="line">    fpTable *tableNode = <span class="keyword">new</span> fpTable;</span><br><span class="line">    tableNode-&gt;startAddr = usedPointer-&gt;startAddr;</span><br><span class="line">    tableNode-&gt;size = usedPointer-&gt;size;</span><br><span class="line">    tableNode-&gt;status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ramTable.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ramTable[i]-&gt;startAddr == tablePointer-&gt;startAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INFO: 找到插入点 %d\n"</span>, i);</span><br><span class="line">            ramTable.insert(ramTable.begin() + i, tableNode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入到双向链表中</span></span><br><span class="line">    fpChain *chainNode = <span class="keyword">new</span> fpChain;</span><br><span class="line">    chainNode-&gt;table = tableNode;</span><br><span class="line">    chainNode-&gt;next = chainPointer;</span><br><span class="line">    chainNode-&gt;previous = chainPointer-&gt;previous;</span><br><span class="line">    chainPointer-&gt;previous-&gt;next = chainNode;</span><br><span class="line">    chainPointer-&gt;previous = chainNode;</span><br><span class="line">    <span class="comment">// 修改链表头部</span></span><br><span class="line">    <span class="keyword">if</span> (chainPointer == ramChain)</span><br><span class="line">    &#123;</span><br><span class="line">        ramChain = chainNode;</span><br><span class="line">    &#125;</span><br><span class="line">    usedTable.erase(usedTable.begin() + index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdstr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> input;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmdstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"exit"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"help"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"申请内存: allocate\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"释放内存: release\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查看当前空余内存: ps\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"获取帮助: help\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出: exit\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"ps"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ps();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"allocate"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请的内存大小(kb): "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">            allocate(input);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"release"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要释放内存的进程号: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line">            release(input);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: 未知的命令！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ps();</span><br><span class="line">    terminal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h1><ol><li><p>编译运行程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ memory.cpp -o memory</span><br><span class="line">./memory</span><br></pre></td></tr></table></figure></li><li><p>使用<code>help</code>命令查看帮助信息</p><p><img src="images/os/memoryhelp.png" alt="help命令"></p></li><li><p>使用<code>ps</code>命令查看当前内存使用信息</p><p><img src="images/os/memoryps.png" alt="ps命令"></p></li><li><p>使用<code>allocate</code>命令申请内存资源，指导书上要求至少进行10次内存申请</p><p><img src="images/os/memoryallocate.png" alt="allocate命令"></p></li><li><p>使用<code>release</code>命令释放内存资源，可以看到在释放资源时，系统会判断并合并连续可用的内存空间</p><p><img src="images/os/memoryrelease.png" alt="release命令"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验中，我们通过使用首次适应算法（First Fit）实现了动态的内存分配回收，实现了该模块之后，编写程序时不需要再考虑申请内存的大小，只需要在运行时动态地申请和释放内存空间即可，这增强了程序的灵活性，再辅助上交换内存之后，我们就可以使用比较小的内存去运行比内存容量大的多的程序。在现代的操作系统中，内存的分配回收使用了段页式管理的方法，在保证了内存的灵活使用同时，尽量减少了内存碎片的产生，提高了系统的吞吐量，同时也提高了程序的灵活性、可移植性和兼容性</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li><p>连续内存分配和离散内存分配相比有何优缺点？</p><p>连续内存分配提高了内存的利用率，同时便于程序在运行过程中动态地申请和释放内存，在程序的眼中，内存空间就像是无限大，编写程序时不必考虑内存容量的限制。连续内存分配也便于程序之间的信息共享，适用于多道程序系统</p></li><li><p>动态连续内存分配的难点是什么？</p><p>内存的动态分配策略和回收策略，如果系统没有选择一个好的分配回收算法，随着系统运行时间的加长，内存的碎片化会越来越严重，系统花费在维护内存分配表上的时间越来越多，导致系统吞吐量降低，甚至出现死机等问题</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;操作系统系列博客的所有实验源自于课程&lt;code&gt;&amp;quot;操作系统原理与实践检验&amp;quot;&lt;/code&gt;，代码是参考老师给的&lt;code&gt;&amp;quot;软件工程专业操作系统实验指导书&amp;quot;&lt;/code&gt;文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题二</title>
    <link href="http://www.fisheryung.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%BA%8C.html"/>
    <id>http://www.fisheryung.top/操作系统习题二.html</id>
    <published>2019-12-18T11:23:49.000Z</published>
    <updated>2019-12-18T11:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>一、为什么要配置层次式储存器？</p><p>为了使存储器跟上处理机的运行速度，提高处理机的使用率，同时尽量降低存储器的成本，采用多层结构的存储器系统是性价比最高的方案</p><p>二、可采用哪几种方式将程序装入内存？它们分别适合用于何种场合？</p><p>绝对装入方式：将目标模块装入到内存中事先指定的位置，计算机系统很小时，完全有可能知道程序将驻留在内存的什么位置。因此可采用绝对装入的方式将程序装入内存指定位置中</p><a id="more"></a><p>可重定位装入方式：可以根据内存使用的具体情况将装入模块装入到内存的适当位置，但不允许程序运行时在内存中移动位置，这种方式适用于在多道程序环境下</p><p>动态运行时的装入方式：程序在运行过程中，内存的位置因为页面的置换而经常发生改变，这种方式适用于拥有段页式储存管理的操作系统中</p><p>三、何谓静态链接？静态链接时需要解决两个什么问题？</p><p>在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。静态链接时需要解决对相对地址进行修改和变换外部调用符号这两个问题</p><p>对相对地址进行修改：编译产生的模块中，内存地址都是从0开始，在装入内存时需要进行内存偏移操作，即加上相对地址L</p><p>变换外部调用符号：将每个模块中所用的外部调用符号变换为相对地址</p><p>四、何谓装入时动态链接？装入时动态链接方式有何优点？</p><p>用户将源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的方式。该方式便于修改和更新库函数，便于实现对库函数模块的共享</p><p>五、何谓运行时动态链接？运行时动态链接方式有何优点？</p><p>对某些模块和链接推迟到程序执行时才进行，这种方式不仅能加快程序的装入过程，还能节省大量的内存空间</p><p>六、在动态分区分配方式中，应如何将各空闲分区连接成空闲分区链？</p><p>使用空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况</p><p>使用空闲分区链：对每一个分区设置一个前向指针和后向指针，用于链接前一个空闲分区和后一个空闲分区</p><p>七、为什么要引入动态重定位？如何实现？</p><p>为了充分利用内存空间中的碎片空间，并且降低计算机整理内存的频次，由此引入了动态重定位。动态重定位使用了一个重定位寄存器，用于记录偏移的地址量，在每次取址时用程序的逻辑地址加上重定位寄存器中的地址，得到内存中的物理地址，在进行内存碎片整理之后，只需要修改重定位寄存器中的地址即可</p><p>八、什么是基于顺序搜索的动态分区分配算法？它可以分为哪几种？</p><p>在内存空闲链中，依次搜索空闲分区上的空闲分区，寻找一个大小能满足要求的分区，它可以分为以下4种算法：</p><ul><li>首次适应（first     fit, FF）算法：该算法要求空闲分区链以地址递增的次序链接，在分配内存时从链的头部开始寻找，直至找到一个大小能满足要求的空闲分区</li><li>循环首次适应算法（next     fit, NF）：为避免低地址部分留下许多很小的空闲分区，该算法从上次找到的空闲分区开始向后寻找，直至找到一个能满足要求的空闲分区</li><li>最佳适应（best     fit, BF）算法：该算法要求将所有的空闲分区按照容量从小到大的顺序形成空闲分区链。总是把能满足要求的、又是最小的空闲分区分配给作业</li><li>最坏适应（worst     fir, WF）算法：与最佳适应算法相反，总是把最大的空闲区分割一部分存储空间给作业使用</li></ul><p>九、在采用首次适应算法回收内存时，可能出现哪几种情况？应该怎样处理这种情况？</p><p>回收区与插入点的前一个空闲分区相邻接：此时应该将回收区与插入点的前一分区合并</p><p>回收区与插入点的后一个空闲分区相邻接：此时应该将两个分区合并，回收区的首地址作为新空闲区的地址，更新空闲分区链表信息</p><p>回收区同时与插入点的前、后两个空闲分区邻接：此时将三个分区合并，使用前分区的地址作为新空闲区的地址，更新空闲分区链表信息</p><p>回收区与前后空闲分区不邻接：此时应单独为回收区新建一个表项，并插入到空闲分区链表中的适当位置</p><p>十、什么是基于索引搜索的动态分区分配算法？它可分为哪几种？</p><p>利用空闲分区索引快速搜索空闲分区，分配空闲分区的算法，它可以分为以下三种算法：</p><ul><li>快速适应（quick fit）算法：又称为分类搜索法，对于每一类具有相同容量的所有空闲分区，单独设立一张管理索引表。首先根据进程长度，从索引表中找到能够容纳它的最小空闲区链表，再从链表中取下第一块进行分配。该算法的优点是分配速度快，但缺点是内存回收整理时算法十分复杂</li><li>伙伴系统（buddy system）：将所有分区划分为大小均为2的k次幂的空间，将相同大小空间的分区使用双向链表建立索引。在伙伴系统中，空间的分配和回收性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。该算法比快速适应算法好，比顺序搜索算法略差</li><li>哈希算法：利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造哈希表。当空闲分区进行分配时，根据所需空闲分区大小，通过哈希函数计算，获得分区在哈希表中的位置，从而得到相应的空闲分区链表，实现最佳分配策略</li></ul><p>十一、分区储存管理中常用哪些分配策略？比较它们的优缺点。</p><p>常用的分配策略：首次适应算法，循环首次适应算法，最佳适应算法，最坏适应算法</p><ul><li>首次适应算法：保留了高位地址部分较大的储存空间，有利于后来的大型作业分配，但同时低位地址不断被划分，碎片化更加严重</li><li>循环首次适应算法：内存空间分配均匀，减少了系统查找的开销，但缺乏大空间内存区域，导致不能装入大型作业</li><li>最佳适应算法：每次给进程分配的空间区域都最适合该进程，在内存中留下难以利用的空间</li><li>最坏适应算法：剩下的空间都不太小，产生碎片的几率小，对中小型作业的分配有利，但不利于大型作业的分配</li></ul><p>十二、为什么要引入对换？对换可分为哪几种类型？</p><p>一方面由于内存中的某些进程由于某事件尚未发生而被阻塞运行，却占用了大量的内存空间，导致内存空间不足，使系统的吞吐量下降，为了解决这个问题而引入了对换功能。对换可以分为：整体对换，页面对换</p><p>十三、对文件区管理的目标和对对换空间管理的目标有何不同？</p><p>对文件区的管理目标：首先是提高文件储存空间的利用率，然后才是提高对文件的访问速度</p><p>对对换空间的管理目标：提高进程换入和换出的速度，然后才是提高文件储存空间的利用率</p><p>十四、为实现对换，系统应具备哪几方面的功能？</p><p>系统应具备的功能：进程的换出，进程的换入，对换空间管理</p><p>十五、在以进程为单位进行对换时，每次是否将整个进程换出？为什么？</p><p>不一定将整个进程换出，因为进程中包含了进程信息，程序代码和数据。其中的数据可能由几个进程共享使用，因此不一定将整个进程换出</p><p>十六、基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？</p><p>可分为：分页储存管理，分段储存管理，段页式储存管理</p><p>十七、什么是页面？什么是物理块？页面的大小应如何确定？</p><p>页面是进程逻辑地址空间的划分，一个进程可以划分为若干个页面</p><p>物理块是内存物理地址空间的划分，并对每个块加以编号</p><p>页面太小会导致页表过长，占用内存且降低效率，页面太长会导致内存空间的浪费，降低换进换出的效率。因此页面一般划分为1KB～8KB</p><p>十八、什么是页表？页表的作用是什么？</p><p>页表中记录了每个页面所对应的物理块，实现了从页号到物理块号的地址映射</p><p>十九、为实现分页存储管理，需要哪些硬件支持？</p><p>动态重定位技术，虚拟储存技术，多道程序设计技术</p><p>二十、在分页系统中是如何实现地址变换的？</p><p>首先通过页表去寻找该进程的内存基址，然后检查该地址是否合法，最后通过内存偏移计算，得出逻辑地址</p><p>二十一、具有快表时是如何实现地址变换的？</p><p>在CPU给出有效地址之后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的也好，便表示所要访问的页表在快表中，则可以直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在快表中未找到对应的页表项，则需要访问内存中的页表，找到之后把页表读出的物理块号送往地址寄存器，同时更新快表项</p><p>二十二、在具有快表的段页式存储管理方式中，如何实现地址变换？</p><p>首先通过快表直接查找目标块号，若越界则执行中断操作，如果找到则直接送往地址寄存器，未找到则在内存页表中查找，找到之后送往地址寄存器</p><p>二十三、为什么说分段系统比分页系统更易于实现信息的共享和保护？</p><p>分页系统中的“页”只是单纯地存放物理信息，并没有完整的数据逻辑意义，而段是信息的逻辑单位，因此更容易实现信息的共享和保护</p><p>二十四、分页和分段存储管理有何区别？</p><p>页是信息的物理单位，分页是为了实现离散的分配方式，而段是信息的逻辑单位，其包含了有意义的、完整的信息。页的大小由系统决定，而段的大小是不确定的。分页的地址空间是一维的，只需要一个记忆符号就可以表示一个地址，段的地址空间是二位的，需要同时给出段名和段内地址</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>一、常规储存器管理方式具有哪两大特征？它对系统性能有何影响？</p><p>一次性：作业必须一次性地全部装入内存后才能开始运行</p><p>驻留性：作业被装入内存之后，整个作业需要一直驻留在内存中，直至作业运行结束</p><p>这两个特征占据了大量的内存空间，使得一些需要运行的作业因为内存不足而无法装入运行，降低了系统的吞吐量</p><p>二、什么是程序运行时的时间局限性和空间局限性？</p><p>时间局限性：如果程序中的某条指令被执行，则不久以后该指令可能再次执行。产生的原因是在程序中存在着大量的循环操作</p><p>空间局限性：一旦程序访问了某个储存单元，在不久之后，其附近的储存单元也将被访问，典型的情况便是程序的顺序执行</p><p>三、虚拟存储器有哪些特征？其中最本质的特征是什么？</p><p>多次性：作业不需要一次性地装入内存后运行，而是将当前要运行的一部分装入运行，通过多次的装入完成整个作业的运行</p><p>对换性：允许作业在运行过程中，在内存与外存之间换入换出</p><p>虚拟性：能够从逻辑上扩充内存容量，使小容量的内存能够运行比它容量更大的程序</p><p>其中多次性是最本质的特征，有了多次性的特征，作业能够在内存和外存之间交换</p><p>四、实现虚拟存储器需要哪些硬件支持？</p><p>请求分页的页表机制和请求分段的段表机制</p><p>缺页中断机构和缺段中断机构</p><p>地址变换机构</p><p>五、实现虚拟存储器需要哪几个关键技术？</p><p>请求调页的软件和实现页面置换的软件，请求调段的软件和实现段置换的软件</p><p>六、在请求分页系统中，页表应包括哪些数据项？每项的作用是什么？</p><p>页号：分页系统中的页面号码</p><p>物理块号：内存中的物理地址</p><p>状态位P：表示该页是否已调入内存，供程序访问时参考</p><p>访问字段A：记录本页在一段时间内被访问的次数</p><p>修改位M：标示该页在调入内存后是否被修改过</p><p>外存地址：指出该页在外存上的地址，通常是物理块号</p><p>七、在请求分页系统中，应从何处将所需页面调入内存？</p><p>分为以下三种情况：</p><ul><li>系统拥有足够的对换区空间：这时可以全部从对换区调入所需页面，以提高调页的速度</li><li>系统缺少足够的对换区空间：这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘，以后都直接调入。但对于那些可能被修改的部分，在将它们换出时便需要调到对换区，以后需要时再从对换区调入</li><li>UNIX方式：由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应该从文件区调入。而对于曾经运行过但又被换出的页面就放在对换区，在下次调入时从对换区调入</li></ul><p>八、试说明在请求分页系统中页面的调入过程。</p><p>首先向CPU发出缺页中断，中断处理程序保留当前运行环境，分析中断原因后转入缺页中断处理程序。该程序通过查找页表得到该页在外存的物理块后，如果此时内存能够容纳新页，则启动磁盘I/O，将所缺页面调入内存，然后修改页表。如果内存已满，则需要先按照某种置换算法，从内存中选出一页准备换出，如果该页面的修改位为1，则需要将其写入对换区中，如果修改位为0，则可以直接将要换入的页面写到该页面上，然后修改页表。最后程序将页表写入到快表中，同时形成所要访问数据的物理地址，再去访问内存数据</p><p>九、在请求分页系统中，常采用哪几种页面置换算法？</p><p>最佳置换（Optimal）算法：选择的被淘汰的页面将是以后永不使用的，或者是未来最长时间内不会被访问的页面。但由于程序运行无法预知，因此该算法无法实现</p><p>先进先出（FIFO）算法：总是淘汰最先进入内存的页面，即在内存驻留最久的页面将被淘汰</p><p>最近最久未使用（LRU）算法：选择最近一段时间内最久没有被访问的页面，然后将其淘汰</p><p>最少使用（LFU）算法：选择最少使用的页面予以淘汰</p><p>十、在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。</p><p>M为3时，总共发生了10次缺页，缺页率为83.4%</p><p>M为4时，总共发生了7次缺页，缺页率为58.4%</p><p>十一、试说明改进型Clock置换算法的基本原理。</p><p>在简单的Clock置换算法的基础上再添加一个“置换代价”因素，描述该因素的字段是修改位，也就是优先选择最近即未被访问、又未被修改的页面作为淘汰页面。整个算法的过程就是，在页表中检查表项，如果有未访问的页面，则将其选择为被淘汰页面，如果该页面已被防伪，则在检查下一项的同时将检查到的表项的访问位置0。这样子一轮下来，整个页表的访问位都会被重置为0，第二次寻找修改位为0的页面即可。如果仍然选不出淘汰页面，则在第三次寻找时选修改位为1的页面，此时一定可以选出淘汰页面</p><p>十二、在请求分页系统中，产生“抖动”的原因是什么？</p><p>同时在系统中运行的进程太多，分配给每一个进程的页面太少，致使每个进程在运行时频繁地发生缺页，系统频繁地进行页面换入换出，而因为磁盘I/O较慢的原因，每个进程把大量时间用于页面的置换，几乎不能有效地工作，导致处理机的利用率极具下降并趋近于0</p><p>十三、何谓工作集？它是基于什么原理确定的？</p><p>工作集是只某段时间间隔中，进程实际所要访问的页面的集合。它是基于程序访问页面的序列和窗口大小确定的</p><p>十四、当前可以利用哪几种方法来防止“抖动”？</p><p>采用局部置换策略，把工作集算法融入到处理机调度中，利用“L=S”准则调节缺页率，选择暂停的进程</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h1&gt;&lt;p&gt;一、为什么要配置层次式储存器？&lt;/p&gt;&lt;p&gt;为了使存储器跟上处理机的运行速度，提高处理机的使用率，同时尽量降低存储器的成本，采用多层结构的存储器系统是性价比最高的方案&lt;/p&gt;&lt;p&gt;二、可采用哪几种方式将程序装入内存？它们分别适合用于何种场合？&lt;/p&gt;&lt;p&gt;绝对装入方式：将目标模块装入到内存中事先指定的位置，计算机系统很小时，完全有可能知道程序将驻留在内存的什么位置。因此可采用绝对装入的方式将程序装入内存指定位置中&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://www.fisheryung.top/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实验五：银行家算法</title>
    <link href="http://www.fisheryung.top/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.html"/>
    <id>http://www.fisheryung.top/银行家算法.html</id>
    <published>2019-12-11T11:35:43.000Z</published>
    <updated>2019-12-13T11:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统系列博客的所有实验源自于课程<code>&quot;操作系统原理与实践检验&quot;</code>，代码是参考老师给的<code>&quot;软件工程专业操作系统实验指导书&quot;</code>文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法</p><a id="more"></a><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>进一步理解利用银行家算法避免死锁的问题</li><li>在了解和掌握银行家算法的基础上，编制银行家算法通用程序，将调试结果显示在计算机屏幕上，再检测和笔算的一致性</li><li>理解和掌握安全序列、安全性算法</li></ol><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><ol><li>了解和理解死锁</li><li>理解利用银行家算法避免死锁的原理</li></ol><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><ul><li><p>数据结构：</p><p>Available：一维数组，系统可用资源列表</p><p>Max：二维数组，进程运行完成所需要的资源总数</p><p>Need：二维数组，进程到达就绪状态还需要的资源数</p><p>Allocation：二维数组，进程已经获得的资源数</p></li><li><p>安全状态</p><p>首先要了解的是：什么是系统的安全状态？</p><p>安全状态是指：在当前情况下，系统能够按照某种执行顺序，为每个进程分配足够的资源，使它们能够顺利完成</p></li><li><p>银行家算法</p><p>顾名思义，银行家算法的就是把计算机系统比喻为银行，进程比喻为来贷款的人。要发放贷款最基本的要求是银行金库中还有钱，并且贷款的人有能力还款，这对应了计算机系统中的剩余资源和进程申请资源时不能超过进程需要的最大资源。核心的要求是银行在发放了贷款之后，能通过某种还款顺序保证不出现坏账，对应计算机系统中就是进程能够以某种安全序列完成任务</p><p>其中安全检查的步骤如下：</p><ol><li><p>如果<code>Request_i &lt;= Need_i</code>，则继续以下检查，否则显示需求申请超过该进程最大需求值的错误</p></li><li><p>如果<code>Request &lt;= Available</code>，则继续以下检查，否则显示系统无足够资源，该进程需要继续阻塞等待</p></li><li><p>系统试着把资源先分配给该进程，并修改相应的数据结构值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i是进程ID的索引，j是资源的索引</span></span><br><span class="line">Available[j] -= Request[j];</span><br><span class="line">Allocation[i][j] += Request[j];</span><br><span class="line">Need[i][j] -= Request[j];</span><br></pre></td></tr></table></figure></li><li><p>系统执行安全性算法，检查此次资源分配之后，系统是否处于安全状态。若系统找到了一个安全序列，则本次分配正式结束。若系统找不到安全序列，则本次分配作废，系统恢复到未分配之前的状态</p></li></ol></li><li><p>安全性算法</p><p>安全性算法就是判断系统能否找到一个安全序列的算法。在本次实验中，我们使用了两个数组变量：</p><ul><li>工作向量<code>Work</code>：它表示系统可用资源的数目，在安全算法刚开始时，<code>Work = Available</code></li><li>标记向量<code>Finish</code>：它表示系统能否有足够的资源分配给进程，使进程运行完成，同时也记录了安全序列</li></ul><p>从进程集合中找到一个能满足下述条件的进程，若找到则执行下一步</p><ul><li><code>Finish[i] = false</code></li><li><code>Need[i][j] &lt;= Work[j]</code></li></ul><p>当进程获得资源后，该进程可顺利运行至完成，并释放出分配给该进程的所有资源，此时可回收资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Work[j] += Allocation[i][j];</span><br><span class="line">Finish[i] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>重复执行上两个步骤，如果所有进程都完成了，则表示系统处于安全状态，否则系统处于不安全状态</p></li></ul><h1 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试模式</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEBUG true</span></span><br><span class="line"><span class="comment">// 系统资源的数量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> RESOURCES 3</span></span><br><span class="line"><span class="comment">// 系统进程数量</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PROCESS 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统可用资源列表</span></span><br><span class="line"><span class="keyword">int</span> Available[RESOURCES] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 进程运行所需要的总资源</span></span><br><span class="line"><span class="keyword">int</span> Max[PROCESS][RESOURCES] = &#123;&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 进程达到就绪状态还需要的资源</span></span><br><span class="line"><span class="keyword">int</span> Need[PROCESS][RESOURCES] = &#123;&#123;<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 已经分配给进程的资源</span></span><br><span class="line"><span class="keyword">int</span> Allocation[PROCESS][RESOURCES] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Debug模式，银行家账本使用书中的例子\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"非Debug模式，银行家账本随机生成\n"</span>);</span><br><span class="line">        <span class="comment">// 随机产生资源和使用情况</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; RESOURCES; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Available[j] = rand() % <span class="number">5</span> + <span class="number">15</span>;</span><br><span class="line">                Max[i][j] = rand() % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">                Allocation[i][j] = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                Need[i][j] = Max[i][j] - Allocation[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前账本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n====================银行家账本===================\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nAvailable: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d "</span>, Available[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nProcess | Allocation | Need\n"</span>);</span><br><span class="line">    <span class="comment">// Process</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%5d |"</span>, i);</span><br><span class="line">        <span class="comment">// Allocation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; RESOURCES; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, Allocation[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" | "</span>);</span><br><span class="line">        <span class="comment">// Need</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RESOURCES; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, Need[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行家算法</span></span><br><span class="line"><span class="comment"> * pid：当前要运行的进程</span></span><br><span class="line"><span class="comment"> * no：当前运行的进程顺序</span></span><br><span class="line"><span class="comment"> * work：当前系统可用资源</span></span><br><span class="line"><span class="comment"> * finish：记录进程完成状态和顺序</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bank</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> no, <span class="keyword">int</span> work[], <span class="keyword">int</span> finish[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新一轮运行尝试，尝试的pid: %d，no: %d\n"</span>, pid, no);</span><br><span class="line">    <span class="comment">// 判断当前系统资源能否满足当前进程运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不满足运行条件，终止本次尝试，向上回溯</span></span><br><span class="line">        <span class="keyword">if</span> (work[i] &lt; Need[pid][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"当前pid: %d, 可用的资源: %d, 需要的资源: %d。不满足运行条件！\n"</span>, pid, work[i], Need[pid][i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前资源满足了当前进程运行</span></span><br><span class="line">    <span class="comment">// 标记当前进程已完成</span></span><br><span class="line">    finish[pid] = no;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        work[i] += Allocation[pid][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前进程成功运行完成: %d, 是第 %d 个完成的进程。寻找下一个可运行的进程......\n"</span>, pid, no);</span><br><span class="line">    <span class="comment">// 判断系统是否运行完成</span></span><br><span class="line">    <span class="keyword">if</span> (no &gt;= PROCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配完毕，系统安全！安全序列："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= PROCESS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; PROCESS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (finish[j] == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"finish\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找下一个未完成的进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!finish[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = bank(i, no + <span class="number">1</span>, work, finish);</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有下一个可以运行的进程了，系统进入不安全状态，往上回溯</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        work[i] -= Allocation[pid][i];</span><br><span class="line">    &#125;</span><br><span class="line">    finish[pid] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"没有下一个可以运行的进程了，系统进入不安全状态，往上回溯。当前进程pid:%d,no:%d\n"</span>, pid, no);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 申请使用资源</span></span><br><span class="line"><span class="comment"> * pid：申请资源的进程ID</span></span><br><span class="line"><span class="comment"> * req_list：申请的资源列表</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> req_list[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pid校验</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt;= PROCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"进程ID非法！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// req_list校验</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (req_list[i] &gt; Need[pid][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请求了过多的资源，分配终止！\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (req_list[i] &gt; Available[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"系统可用资源不足，无法分配！\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用银行家算法判断系统是否安全</span></span><br><span class="line">    <span class="keyword">int</span> work[RESOURCES], finish[PROCESS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        finish[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 试探性分配，然后检查是否安全</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Available[i] -= req_list[i];</span><br><span class="line">        Allocation[pid][i] += req_list[i];</span><br><span class="line">        Need[pid][i] -= req_list[i];</span><br><span class="line">        work[i] = Available[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否安全</span></span><br><span class="line">    <span class="keyword">bool</span> safe = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bank(i, <span class="number">1</span>, work, finish))</span><br><span class="line">        &#123;</span><br><span class="line">            safe = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果系统安全，则本次分配完成</span></span><br><span class="line">    <span class="keyword">if</span> (safe)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"本次分配完成！\n"</span>);</span><br><span class="line">        ps();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配不安全，本次分配作废</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RESOURCES; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Available[i] += req_list[i];</span><br><span class="line">            Allocation[pid][i] -= req_list[i];</span><br><span class="line">            Need[pid][i] += req_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有安全的分配方案，请求资源失败！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmdstr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> cmd, req_id, req_list[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmdstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"exit"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"help"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n=================================================\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请求资源: request\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"查看当前银行家账本: ps\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"获取帮助: help\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"退出: exit\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"=================================================\n\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"ps"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ps();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cmdstr, <span class="string">"request"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请资源的进程ID: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;req_id);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"要申请的资源的数量: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;req_list[<span class="number">0</span>], &amp;req_list[<span class="number">1</span>], &amp;req_list[<span class="number">2</span>]);</span><br><span class="line">            request(req_id, req_list);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cmd: 未知的命令！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ps();</span><br><span class="line">    terminal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h1><ol><li><p>编译运行程序，这里就不放截图了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ bank.cpp -o bank</span><br><span class="line">./bank</span><br></pre></td></tr></table></figure></li><li><p>使用<code>help</code>命令查看帮助信息</p><p><img src="images/os/bankhelp.png" alt="帮助信息"></p></li><li><p>使用<code>ps</code>命令查看当前账本</p><p><img src="images/os/bankps.png" alt="ps命令"></p></li><li><p>使用<code>request</code>申请资源，查看系统运行过程</p><p><img src="images/os/bankrequest.png" alt="申请资源"></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验我们实现了银行家算法，了解了系统为了防止死锁发生所做的工作。在现代的商业系统中，可能有许多的进程，要防止死锁的代价是非常高的，所以这些系统都采取了消极的措施，就是不管死锁的发生，也不去处理，在真正出现问题的时候，重启还是一个比较快的方法。但在一些高可靠性的系统中，可能系统的进程数量比较少，而且因为业务的要求，系统必须采取措施来防止死锁的发生，这时候银行家算法就有用武之地了</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li><p>在编程中遇到了哪些问题？你是如何解决的？</p><p>一开始想要以非递归的方法实现安全性检测，但是发现代码十分混乱而且比较难理解，改用递归的方法之后就好很多了。有了思路之后，实现算法的速度还是挺快的</p></li><li><p>在安全性算法中，为什么不用变量<code>Available</code>，而又定义一个临时变量<code>Work</code>？</p><p>因为在递归调用安全性检测的算法过程中，一直需要对系统可用资源进行调整，直接用<code>Available</code>变量会导致算法在找到安全序列之后还要向上回溯，恢复<code>Available</code>的值，因此定义一个临时变量<code>Work</code>更为方便    </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;操作系统系列博客的所有实验源自于课程&lt;code&gt;&amp;quot;操作系统原理与实践检验&amp;quot;&lt;/code&gt;，代码是参考老师给的&lt;code&gt;&amp;quot;软件工程专业操作系统实验指导书&amp;quot;&lt;/code&gt;文档后的改进版本。操作系统是计算机系统的核心，因此了解操作系统的设计和实现思路是必不可少的。了解操作系统的基本要求是：理解进程的概念，理解死锁，掌握银行家算法；掌握页式储存管理的实现原理以及页面置换法&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统习题一</title>
    <link href="http://www.fisheryung.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E4%B8%80.html"/>
    <id>http://www.fisheryung.top/操作系统习题一.html</id>
    <published>2019-12-09T13:43:39.000Z</published>
    <updated>2019-12-30T12:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>一、设计现代OS的主要目标是什么？<br>  现代OS的主要目标有4个：方便性、有效性、可扩充性、开放性<br>  方便性：系统将用户采用高级语言编写的程序翻译成机器码，或直接通过OS所提供的各种命令操纵计算机系统，方便了用户，使计算机变得易学易用<br>  有效性：提高了系统资源的利用率，提高系统的吞吐量，缩短程序运行周期<br>  可扩充性：能够方便地添加新功能和模块，以及对原有的功能和模块进行修改<br>  开放性：能够遵循国际标准开发硬件和软件，都能彼此兼容，方便地实现互联</p><a id="more"></a><p>二、为什么说操作系统实现了对计算机资源的抽象？<br>  操作系统在裸机上覆盖了一层设备管理软件，隐藏了物理接口的实现细节。用户无需关心或了解某些功能具体是如何实现的，但也能够很好地利用计算机的资源，操作系统在这里就是实现了对计算机资源的抽象</p><p>三、OS有哪几大特征，其最基本的特征是什么？<br>  OS有并发、共享、虚拟、异步，这4大特征<br>  并发：指两个或多个事件在同一时间间隔内发生，在微观上就是多个程序交替执行<br>  共享：系统中的资源可供内存中多个并发执行的进程共同使用<br>  虚拟：通过某种技术将一个物理实体变为若干个逻辑上的对应物<br>  异步：异步使得处理器不需要等待进程IO，继续执行下一个程序，在程序IO中断完成后通过回调函数继续执行</p><p>四、是什么原因使操作系统具有异步性特征？<br>  为了提高CPU资源的利用率，在程序IO阻塞的过程中，如果没有异步执行的概念，CPU将会一直等待进程IO完成，这浪费了大量的CPU资源</p><p>五、处理机管理有哪些主要功能？其主要任务是什么？<br>  进程控制：为作业创建进程、撤销已结束的进程，控制进程在运行过程中的转换<br>  进程同步：保证多个进程运行时的协调，确保系统资源的合理分配<br>  进程通信：实现相互合作的进程之间的信息互换<br>  调度：包括作业调度和进程调度。作业调度的基本任务是从后背队列中按照一定的算法选择出若干个作业，为他们分配运行时所需的资源。进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给该进程</p><p>六、内存管理有哪些主要功能？其主要任务是什么？<br>  内存分配：为每道程序动态或静态地分配内存空间，提高储存器的利用率<br>  内存保护：确保每道程序仅在自己的内存空间内运行，互不干扰。不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行<br>  地址映射：将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址<br>  内存扩充：借助虚拟储存技术，从逻辑上扩大内存，其中包括了请求调入功能和置换功能</p><p>七、设备管理有哪些主要功能？其主要任务是什么？<br>  缓冲管理：在IO设备和CPU之间引入缓冲，缓解了CPU和IO设备速度不匹配的矛盾<br>  设备分配：根据用户的请求、系统现有资源情况以及按照某种预设分配策略，为之分配所需的设备<br>  设备处理：实现CPU和设备控制器之间的通信，又称为驱动程序</p><p>八、文件管理有哪些主要功能？其主要任务是什么？<br>  文件储存空间的管理：对文件以及文件的储存空间进行统一的管理<br>  目录管理：为每个文件建立一个目录项，提高检索文件的速度<br>  文件的读/写保护：防止系统中的文件被非法盗取和破坏，对读/写中的文件提供保护</p><p>九、什么是微内核OS？<br>  微内核OS是将系统服务的实现与系统的基本操作规则区分开来，让服务之间互相独立，减少了系统的耦合度，系统也可以根据功能的需要添加或更换模块使系统功能更具有弹性</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>一、为什么程序并发执行会产生间断性特征？<br>  程序在并发执行时，由于他们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。这种相互制约的关系导致并发程序具有“执行——暂停——执行”这种间断性规律</p><p>二、程序并发执行时为什么会失去封闭性和可再现性？<br>  系统中的资源被多个程序共享使用时，其中任一程序改变资源的状态时，其他程序也会受到影响，因此而失去了封闭性。程序失去封闭性后，并发执行的过程中会发生许多意想不到的状态值修改，也就是失去了可再现性</p><p>三、PCB提供了进程管理和进程调度所需要的哪些信息？<br>  进程管理：通用寄存器、指令计数器、程序状态字、用户栈指针<br>  进程调度：进程状态、进程优先级、事件、其他信息</p><p>四、进程控制块的组织方式有哪几种？<br>  线性方式、链接方式、索引方式</p><p>五、何谓操作系统的内核？内核的主要功能是什么？<br>  操作系统内核是一些与硬件紧密相关的模块（中断处理程序）、各种常用设备的驱动程序以及运行频率较高的模块（时钟管理、进程调度和许多公用模块），它们都常驻内存，主要提供以下功能：<br>  支撑功能：中断处理、时钟管理、原语操作<br>  资源管理功能：进程管理、储存器管理、设备管理</p><p>六、试说明进程在三个基本状态之间转换的典型原因。<br>  就绪 -&gt; 执行：进程获得分配的CPU时间片，开始执行<br>  执行 -&gt; 阻塞：执行中的进程发生IO中断，因而无法继续执行，此时进程又执行状态变为阻塞状态<br>  阻塞 -&gt; 就绪：进程IO完成，但还未分配到CPU时间片，因此转为就绪状态</p><p>七、试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。<br>  调度性：进程的调度包括了上下文的切换，开销较大。而线程的调度仅需保存和设置少量寄存器内容，切换的代价小于进程。在同一进程中的线程切换不会引起上下文的切换，但不同进程中的线程切换会引起上下文的切换<br>  并发性：同一进程不能并发，而同一进程中的不同线程可以并发。不同进程之间可以并发，不同进程的不同线程可以并发<br>  拥有资源：进程可以拥有资源，而线程本身不拥有系统资源，仅有保证独立运行的资源。线程的资源可以共享该进程拥有的资源<br>  系统开销：线程的创建、切换和撤销的花销都比进程要小得多</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>一、高级调度与低级调度的主要任务是什么？为什么要引入中级调度？<br>  高级调度：调度对象是作业，根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为他们创建进程、分配必要的资源，并将他们放入就绪队列<br>  低级调度：调度对象是进程，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程<br>  引入中级调度的目的：提高内存的利用率和系统的吞吐量。将暂时不能运行的进程调至外存等待，当具备运行条件时重新调入内存</p><p>二、处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？</p><p>  处理机调度算法的共同目标：</p><ul><li>提高系统资源利用率</li><li>提高公平性，使进程都获得合理CPU时间</li><li>保持系统资源使用的平衡</li><li><p>制订的策略强制执行</p><p>批处理系统的调度目标：</p></li><li>缩短平均周转时间</li><li>提高系统的吞吐量</li><li>提高处理机利用率</li></ul><p>三、在作业调度中应如何确定接纳多少个作业和接纳哪些作业？<br>  接纳作业的数量根据系统规模、运行速度、作业大小、以及能否获得较好的系统性能等情况作出适当的抉择<br>  接纳哪些作业根据不同的调度算法来判断，最简单的是先来先服务调度算法，较常用的是短作业优先调度算法和基于作业优先级的调度算法</p><p>四、试说明低级调度的主要功能。<br>  根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程</p><p>五、在选择调度方式和调度算法时，应遵循的准则是什么？<br>  应尽量保证公平，每个进程分得的CPU时间片应尽量平衡。保持系统资源使用的平衡性</p><p>六、试比较FCFS和SJF两种进程调度算法。<br>  先来先服务（FCFS）算法：每次从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行，该进程一直运行到完成或发生某时间而阻塞后，进程调度程序才将处理机分配给其他进程<br>  短作业优先（SJF）算法：按照作业的长短来计算优先级，作业越短，优先级越高<br>  与FCFS比，SJF需要预知作业的运行时间，而且对长作业非常不利，两种算法都不能实现人机交互，SJF没有考虑作业的紧迫程度，不能保证紧迫性作业能够得到及时的处理</p><p>七、在时间片轮转法中，应如何确定时间片的大小？<br>  一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，时间片过长会导致算法退化为FCFS，过短会增加系统执行进程调度的开销</p><p>八、为什么说多级反馈队列调度算法能较好地满足各个方面用户的需要？<br>  多级反馈队列调度算法不必事先知道各种进程所需的执行时间，不同类型的进程放在不同优先级的就绪队列中，每个队列采用FCFS算法，这种算法能够较好地满足各种类型进程的需要，因此能够很好地满足各个方面用户的需要</p><p>九、什么是最低松弛度优先调度算法？举例说明之。<br>  根据任务的紧急程度确定任务的优先级，紧急程度越高，该任务的优先级就越高<br>  例如：若一个任务A在200ms时必须完成，它本身运行所需的时间是100ms，因此调度程序必须在100ms之前调度执行，该任务的紧急程度为100ms。而另一个任务B在400ms时必须完成，它本身运行所需的时间是150ms，则松弛程度为250ms。根据算法可知，最低松弛度的任务是A，接下来应该执行A任务</p><p>十、何谓“优先级倒置”现象，可采取什么方法来解决？<br>  优先级倒置：低优先级的任务占有了高优先级任务的资源，导致高优先级任务阻塞，可采取优先级继承的方法解决</p><p>十一、试分别说明可重用资源和可消耗资源的性质。<br>  可重用资源：可供用户重复使用多次的资源，每一个可重用的资源只能分配给一个进程使用。进程在使用可重用资源时，必须参照：请求资源、使用资源、解放资源的顺序使用。系统中的可重用资源数量相对是固定的<br>  可消耗资源：又称临时性资源，是在进程运行期间不断变化的。进程在运行期间可以不断创造可消耗性资源的单元，在进程结束后可消耗资源也跟着消失</p><p>十二、试举例说明竞争不可抢占资源引起的死锁。<br>  假设A进程运行需要1号和2号资源，目前1号资源已经申请成功，由A进程占用。而B进程的运行也需要1号和2号资源，且B进程已经申请占用了2号资源。两个进程都在等待对方释放资源，从而引起了进程的死锁</p><p>十三、为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议。<br>  第一种协议：进程在运行之前必须一次性申请在整个运行过程中所需的全部资源。其优点是简单、易行且安全，但资源被严重浪费，并且进程会经常发生饥饿现象<br>  第二种协议：是第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行，运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。第二种协议不仅能使进程更快地完成任务，提高设备的利用率，还可以减少进程发生饥饿的概率</p><p>十四、何谓死锁？产生死锁的原因和必要条件是什么？<br>  如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的<br>  产生死锁的原因有：竞争不可抢占性资源引起死锁，竞争可消耗资源引起死锁<br>  产生死锁的必要条件：互斥条件-&gt;进程对所分配到的资源进行排他性使用；请求和保持条件-&gt;进程已经保持了至少一个资源，但又提出了新的资源请求；不可抢占条件-&gt;进程已获得的资源在未使用完之前不能被抢占；循环等待条件-&gt;在发生死锁时，必然存在一个进程——资源的循环链</p><p>十五、在解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？<br>  解决死锁问题有预防和解除2种思路。预防死锁有：破坏“请求和保持”条件，破坏“循环等待”条件，保持系统处于安全状态，银行家算法等方法。解除死锁有：终止进程，抢占资源等方法<br>  这几种方法中，破坏死锁产生的条件最容易实现，银行家算法和保持系统处于安全状态的资源利用率最高</p><p>十六、请详细说明可通过哪些途径预防死锁。<br>  破坏“请求和保持”条件：进程逐步申请、释放资源<br>  破坏“循环等待”条件：进程占有的资源可以被抢占<br>  保持系统处于安全状态：在分配资源之前计算资源分配的安全性<br>  银行家算法：在分配资源之前计算剩余资源的可用情况</p><p>十七、在银行家算法的例子中，如果P0发出的请求向量由Request(0,2,0)改为Request(0,1,0)，问系统可否将资源分配给它？<br>  假设资源分配给了P0，则剩余情况如下：Avalibale(2, 2, 0)。可以找到一个安全序列：{P1, P3, P2, P0, P4}，因此系统能将资源分配给他</p><p>十八、在银行家算法中，若出现下述资源分配情况，试问：</p><table><thead><tr><th>Process</th><th>Allocation</th><th>Need</th><th>Available</th></tr></thead><tbody><tr><td>P0</td><td>0 0 3 2</td><td>0 0 1 2</td><td>1 6 2 2</td></tr><tr><td>P1</td><td>1 0 0 0</td><td>1 7 5 0</td><td></td></tr><tr><td>P2</td><td>1 3 5 4</td><td>2 3 5 6</td><td></td></tr><tr><td>P3</td><td>0 3 3 2</td><td>0 6 5 2</td><td></td></tr><tr><td>P4</td><td>0 0 1 4</td><td>0 6 5 6</td></tr></tbody></table><p>（1）该状态是否安全？<br>​ 可以找到一个安全序列：{P0, P3, P1, P2, P4}，因此该状态是安全的<br>（2）若进程P2提出请求Request(1,2,2,2)后，系统能否将资源分配给它？<br>​ 因为Need(2,3,5,6)&lt;Request(1,2,2,2)且Request(1,2,2,2)&lt;Avaliable(1,6,2,2)。暂且认为可以分配之后，可用资源为Avaliable(0,4,0,0)，无法找到一个安全序列，因此系统不能将资源分配给它</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;一、设计现代OS的主要目标是什么？&lt;br&gt;  现代OS的主要目标有4个：方便性、有效性、可扩充性、开放性&lt;br&gt;  方便性：系统将用户采用高级语言编写的程序翻译成机器码，或直接通过OS所提供的各种命令操纵计算机系统，方便了用户，使计算机变得易学易用&lt;br&gt;  有效性：提高了系统资源的利用率，提高系统的吞吐量，缩短程序运行周期&lt;br&gt;  可扩充性：能够方便地添加新功能和模块，以及对原有的功能和模块进行修改&lt;br&gt;  开放性：能够遵循国际标准开发硬件和软件，都能彼此兼容，方便地实现互联&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.fisheryung.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="学习总结" scheme="http://www.fisheryung.top/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
